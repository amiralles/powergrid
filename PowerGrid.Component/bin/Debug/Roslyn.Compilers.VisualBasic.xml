<?xml version="1.0"?>
<doc>
<assembly>
<name>
Roslyn.Compilers.VisualBasic
</name>
</assembly>
<members>
<member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EmptyStatement">
	<summary>
 A class to represent an empty statement. This can occur when a colon is on a
 line without anything else.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndIfStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndUsingStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndWithStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndSelectStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndStructureStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndEnumStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndInterfaceStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndClassStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndModuleStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndNamespaceStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndSubStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndFunctionStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndGetStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndSetStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndPropertyStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndOperatorStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndEventStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndAddHandlerStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndRemoveHandlerStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndRaiseEventStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndWhileStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndTryStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndSyncLockStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CompilationUnit">
	<summary>
 Represents an entire source file of VB code.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OptionStatement">
	<summary>
 Represents an Option statement, such as "Option Strict On".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ImportsStatement">
	<summary>
 Represents an Imports statement, which has one or more imports clauses.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AliasImportsClause">
	<summary>
 Represents the clause of an Imports statement that defines an alias for a
 namespace or type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MembersImportsClause">
	<summary>
 Represents the clause of an Imports statement that imports all members of a
 namespace.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlNamespaceImportsClause">
	<summary>
 Defines a XML namespace for XML expressions.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NamespaceBlock">
	<summary>
 Represents a Namespace statement, its contents and the End Namespace statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NamespaceStatement">
	<summary>
 Represents the beginning statement of a namespace declaration. This node always
 appears as the Begin of a BlockStatement with Kind=NamespaceBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ModuleBlock">
	<summary>
 Represents a declaration of Module, its contents and the End statement that
 ends it.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StructureBlock">
	<summary>
 Represents a declaration of a Structure, its contents and the End statement
 that ends it.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.InterfaceBlock">
	<summary>
 Represents a declaration of a Interface, its contents and the End statement
 that ends it.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ClassBlock">
	<summary>
 Represents a declaration of a Class its contents and the End statement that
 ends it.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EnumBlock">
	<summary>
 Represents a declaration of an Enum, its contents and the End Enum statement
 that ends it.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.InheritsStatement">
	<summary>
 Represents an Inherits statement in a Class, Structure or Interface.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ImplementsStatement">
	<summary>
 Represents an Implements statement in a Class or Structure.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ModuleStatement">
	<summary>
 Represents the beginning statement of a Module declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StructureStatement">
	<summary>
 Represents the beginning statement of a Structure declaration. This node always
 appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.InterfaceStatement">
	<summary>
 Represents the beginning statement of a Interface declaration. This node always
 appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ClassStatement">
	<summary>
 Represents the beginning statement of a Class declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EnumStatement">
	<summary>
 Represents the beginning statement of an Enum declaration. This node always
 appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TypeParameterList">
	<summary>
 Represents the type parameter list in a declaration.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TypeParameter">
	<summary>
 Represents a type parameter on a generic type declaration.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TypeParameterSingleConstraintClause">
	<summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As Constraint".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TypeParameterMultipleConstraintClause">
	<summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As { Constraints }".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NewConstraint">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ClassConstraint">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StructureConstraint">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TypeConstraint">
	<summary>
 Represents a type parameter constraint that is a type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EnumMemberDeclaration">
	<summary>
 Represents a name and value in an EnumDeclarationBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SubBlock">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FunctionBlock">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ConstructorBlock">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OperatorBlock">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PropertyGetBlock">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PropertySetBlock">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AddHandlerBlock">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RemoveHandlerBlock">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RaiseEventBlock">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PropertyBlock">
	<summary>
 Represents a block property declaration: A declaration that has a beginning
 declaration, some get or set accessor blocks and an end statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EventBlock">
	<summary>
 Represents a custom event declaration: A declaration that has a beginning event
 declaration, some accessor blocks and an end statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ParameterList">
	<summary>
 Represents the parameter list in a method declaration.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SubStatement">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FunctionStatement">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ConstructorStatement">
	<summary>
 A statement that declares a constructor. This statement will be the Begin of a
 BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
 will be the Body of that BlockStatement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DeclareSubStatement">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DeclareFunctionStatement">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DelegateSubStatement">
	<summary>
 A statement that declares a delegate type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DelegateFunctionStatement">
	<summary>
 A statement that declares a delegate type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EventStatement">
	<summary>
 A statement that declares an event. If the event being declared is a custom
 event, this statement will be the Begin of a PropertyOrEventBlock, and the
 accessors will be part of the Accessors of that node.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OperatorStatement">
	<summary>
 A statement that declares an operator. If this operator has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PropertyStatement">
	<summary>
 Statement that declares a property. If this property has accessors declared,
 this statement will be the Begin of a BlockNode, and the accessors will be the
 Body of that node. Auto properties are property declarations without a
 PropertyBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GetAccessorStatement">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SetAccessorStatement">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AddHandlerAccessorStatement">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RemoveHandlerAccessorStatement">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RaiseEventHandlerAccessorStatement">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ImplementsClause">
	<summary>
 Represents the "Implements ..." clause on a type member, which describes which
 interface members this member implements.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.HandlesClause">
	<summary>
 Represents the "Handles ..." clause on a method declaration that describes
 which events this method handles.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.KeywordEventContainer">
	<summary>
 Represents event container specified through special keywords "Me", "MyBase" or
 "MyClass"..
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IdentifierEventContainer">
	<summary>
 Represents event container that refers to a WithEvents member.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.HandlesClauseItem">
	<summary>
 Represents a single handled event in a "Handles ..." clause.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IncompleteMember">
	<summary>
 Represents the beginning of a declaration. However, not enough syntax is
 detected to classify this as a field, method, property or event. This is node
 always represents a syntax error.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FieldDeclaration">
	<summary>
 Represents the declaration of one or more variables or constants, either as
 local variables or as class/structure members. In the case of a constant, it is
 represented by having "Const" in the Modifiers (although technically "Const" is
 not a modifier, it is represented as one in the parse trees.)
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.VariableDeclarator">
	<summary>
 Represents the part of a variable or constant declaration statement that
 associated one or more variable names with a type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SimpleAsClause">
	<summary>
 Represents an "As {type-name}" clause that does not have an initializer or
 "New". The type has optional attributes associated with it, although attributes
 are not permitted in all possible places where this node occurs.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AsNewClause">
	<summary>
 Represents an "As New {type-name} [arguments] [initializers]" clause in a
 declaration. The type has optional attributes associated with it, although
 attributes are not permitted in many places where this node occurs (they are
 permitted, for example, on automatically implemented properties.)
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ObjectMemberInitializer">
	<summary>
 Represents a "With {...} clause used to initialize a new object's members.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ObjectCollectionInitializer">
	<summary>
 Represents a "From {...} clause used to initialize a new collection object's
 elements.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.InferredFieldInitializer">
	<summary>
 Represent a field initializer in a With {...} initializer where the field name
 is inferred from the initializer expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NamedFieldInitializer">
	<summary>
 Represent a named field initializer in a With {...} initializer, such as ".x =
 expr".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EqualsValue">
	<summary>
 Represents an "= initializer" clause in a declaration for a variable,
 pararameter or automatic property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.Parameter">
	<summary>
 Represent a parameter to a method, property, constructor, etc.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ModifiedIdentifier">
	<summary>
 Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
 used in parameter declarations and variable declarations.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ArrayRankSpecifier">
	<summary>
 Represents a modifier that describes an array type, without bounds, such as
 "()" or "(,)".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AttributeList">
	<summary>
 Represents a group of attributes within "&lt;" and "&gt;" brackets.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.Attribute">
	<summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AttributeTarget">
	<summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AttributesStatement">
	<summary>
 Represents a file-level attribute, in which the attributes have no other
 syntactic element they are attached to.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExpressionStatement">
	<summary>
 Represent an expression in a statement context.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WhileBlock">
	<summary>
 Represents a While...End While statement, including the While, body and End
 While.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.UsingBlock">
	<summary>
 Represents an entire Using...End Using statement, including the Using, body and
 End Using statements.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SyncLockBlock">
	<summary>
 Represents a entire SyncLock...End SyncLock block, including the SyncLock
 statement, the enclosed statements, and the End SyncLock statment.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WithBlock">
	<summary>
 Represents a With...End With block, include the With statement, the body of the
 block and the End With statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LocalDeclarationStatement">
	<summary>
 Represents the declaration of one or more local variables or constants.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LabelStatement">
	<summary>
 Represents a label statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GoToStatement">
	<summary>
 Represents a "GoTo" statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IdentifierLabel">
	<summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NumericLabel">
	<summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NextLabel">
	<summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StopStatement">
	<summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndStatement">
	<summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExitDoStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExitForStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExitSubStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExitFunctionStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExitOperatorStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExitPropertyStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExitTryStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExitSelectStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExitWhileStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ContinueWhileStatement">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ContinueDoStatement">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ContinueForStatement">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ReturnStatement">
	<summary>
 Represents a "Return" statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SingleLineIfStatement">
	<summary>
 Represents a line If-Then-Else statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SingleLineIfPart">
	<summary>
 Represents part of a single line If statement, consisting of a beginning
 if-statement, followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an SingleLineIf.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SingleLineElsePart">
	<summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MultiLineIfBlock">
	<summary>
 Represents a block If...Then...Else...EndIf Statement. The Kind property can be
 used to determine if it is a block or line If.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IfPart">
	<summary>
 Represents part of an If statement, consisting of a beginning statement (If or
 ElseIf), followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an If or ElseIf.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ElseIfPart">
	<summary>
 Represents part of an If statement, consisting of a beginning statement (If or
 ElseIf), followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an If or ElseIf.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ElsePart">
	<summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IfStatement">
	<summary>
 Represents the If part or ElseIf part of a If...End If block (or line If). This
 statement is always the Begin of a IfPart. The Kind can be examined to
 determine if this is an If or an ElseIf statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ElseIfStatement">
	<summary>
 Represents the If part or ElseIf part of a If...End If block (or line If). This
 statement is always the Begin of a IfPart. The Kind can be examined to
 determine if this is an If or an ElseIf statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ElseStatement">
	<summary>
 Represents the Else part of a If...End If block (or line If). This statement is
 always the Begin of a ElsePart.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TryBlock">
	<summary>
 Represents an entire Try...Catch...Finally...End Try statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TryPart">
	<summary>
 Represents part of an Try...Catch...Finally...End Try statement, consisting of
 a beginning statement (Try, Catch or Finally), followed by a body of statements
 controlled by that beginning statement. The Kind property returns which kind of
 part this is.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CatchPart">
	<summary>
 Represents a Catch part of an Try...Catch...Finally...End Try statement,
 consisting of a Catch statement, followed by a body of statements controlled by
 that Catch statement. The Kind property returns which kind of part this is.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FinallyPart">
	<summary>
 Represents the Finally part of an Try...Catch...Finally...End Try statement,
 consisting of a Finally statement, followed by a body of statements controlled
 by the Finally.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TryStatement">
	<summary>
 Represents the Try part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a TryPart.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CatchStatement">
	<summary>
 Represents the Catch part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a CatchPart.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CatchFilterClause">
	<summary>
 Represents the When/Filter clause of a Catch statement
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FinallyStatement">
	<summary>
 Represents the Finally part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a FinallyPart.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ErrorStatement">
	<summary>
 Represents the "Error" statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OnErrorGoToZeroStatement">
	<summary>
 Represents an OnError Goto statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OnErrorGoToMinusOneStatement">
	<summary>
 Represents an OnError Goto statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OnErrorGoToLabelStatement">
	<summary>
 Represents an OnError Goto statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OnErrorResumeNextStatement">
	<summary>
 Represents an OnError Resume Next statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ResumeStatement">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ResumeLabelStatement">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ResumeNextStatement">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SelectBlock">
	<summary>
 Represents a Select Case block, including the Select Case that begins it, the
 contains Case blocks and the End Select.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SelectStatement">
	<summary>
 Represents a Select Case statement. This statement always occurs as the Begin
 of a SelectBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseBlock">
	<summary>
 Represents a case statement and its subsequent block.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseElseBlock">
	<summary>
 Represents a case statement and its subsequent block.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseStatement">
	<summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseElseStatement">
	<summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseElseClause">
	<summary>
 The "Else" part in a Case Else statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseValueClause">
	<summary>
 Represents a single value in a Case.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseRangeClause">
	<summary>
 Represents a range "expression To expression" in a Case.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseEqualsClause">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseNotEqualsClause">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseLessThanClause">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseLessThanOrEqualClause">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseGreaterThanOrEqualClause">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseGreaterThanClause">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SyncLockStatement">
	<summary>
 Represents the "SyncLock" statement. This statement always occurs as the Begin
 of a SyncLockBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DoLoopTopTestBlock">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DoLoopBottomTestBlock">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DoLoopForeverBlock">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DoStatement">
	<summary>
 The Do statement that begins a Do-Loop block. This statement always occurs as
 the Begin of a DoLoopBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LoopStatement">
	<summary>
 The Loop statement that ends a Do-Loop block. This statement always occurs as
 the End of a DoLoopBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WhileClause">
	<summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.UntilClause">
	<summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WhileStatement">
	<summary>
 The While statement that begins a While...End While block. This statement
 always occurs as the Begin of a WhileBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ForBlock">
	<summary>
 Represents a For or For Each block, including the introducting statement, the
 body and the "Next" (which can be omitted if a containing For has a Next with
 multiple variables).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ForEachBlock">
	<summary>
 Represents a For or For Each block, including the introducting statement, the
 body and the "Next" (which can be omitted if a containing For has a Next with
 multiple variables).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ForStatement">
	<summary>
 The For statement that begins a For-Next block. This statement always occurs as
 the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ForStepClause">
	<summary>
 The Step clause in a For Statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ForEachStatement">
	<summary>
 The For Each statement that begins a For Each-Next block. This statement always
 occurs as the Begin of a ForBlock, and the body of the For Each-Next is the
 Body of that ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NextStatement">
	<summary>
 The Next statement that ends a For-Next or For Each-Next block. This statement
 always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
 and the body of the For-Next is the Body of that ForBlock. The Begin of that
 ForBlock has the corresponding For or For Each statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.UsingStatement">
	<summary>
 The Using statement that begins a Using block. This statement always occurs as
 the Begin of a UsingBlock, and the body of the Using is the Body of that
 UsingBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ThrowStatement">
	<summary>
 Represents a Throw statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AssignmentStatement">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MidAssignment">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AddAssignment">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SubtractAssignment">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MultiplyAssignment">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DivideAssignment">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IntegerDivideAssignment">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PowerAssignment">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LeftShiftAssignment">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RightShiftAssignment">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ConcatenateAssignment">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CallStatement">
	<summary>
 Represent an call statement (also known as a invocation statement).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AddHandlerStatement">
	<summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RemoveHandlerStatement">
	<summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RaiseEventStatement">
	<summary>
 Represent a RaiseEvent statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WithStatement">
	<summary>
 Represents a "With" statement. This statement always occurs as the
 BeginStatement of a WithBlock, and the body of the With is the Body of that
 WithBlock.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ReDimStatement">
	<summary>
 Represents a ReDim statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ReDimPreserveStatement">
	<summary>
 Represents a ReDim statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EraseStatement">
	<summary>
 Represents an "Erase" statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CharacterLiteralExpression">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TrueLiteralExpression">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FalseLiteralExpression">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NumericLiteralExpression">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DateLiteralExpression">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StringLiteralExpression">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NothingLiteralExpression">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ParenthesizedExpression">
	<summary>
 Represents a parenthesized expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MeExpression">
	<summary>
 Identifies the special instance "Me"
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MyBaseExpression">
	<summary>
 Identifies the special instance "MyBase"
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MyClassExpression">
	<summary>
 Identifies the special instance "MyClass"
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GetTypeExpression">
	<summary>
 Represents a GetType expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TypeOfIsExpression">
	<summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TypeOfIsNotExpression">
	<summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GetXmlNamespaceExpression">
	<summary>
 Represents a GetXmlNamespace expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MemberAccessExpression">
	<summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DictionaryAccessExpression">
	<summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlElementAccessExpression">
	<summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlDescendantAccessExpression">
	<summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlAttributeAccessExpression">
	<summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.InvocationExpression">
	<summary>
 Represents an invocation expression consisting of an invocation target and an
 optional argument list or an array, parameterized property or object default
 property index.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ObjectCreationExpression">
	<summary>
 Represents a New expression that creates a new non-array object, possibly with
 a "With" or "From" clause.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AnonymousObjectCreationExpression">
	<summary>
 Represents a New expression that create an object of anonymous type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ArrayCreationExpression">
	<summary>
 Represents an expression that creates a new array.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CollectionInitializer">
	<summary>
 Represents an expression that creates a new array without naming the element
 type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PredefinedCastExpression">
	<summary>
 Represents a cast to a pre-defined type using a pre-defined cast expression,
 such as CInt or CLng.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AddExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SubtractExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MultiplyExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DivideExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IntegerDivideExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PowerExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LeftShiftExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RightShiftExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ConcatenateExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ModuloExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EqualsExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NotEqualsExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LessThanExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LessThanOrEqualExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GreaterThanOrEqualExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GreaterThanExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IsExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IsNotExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LikeExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OrExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XorExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AndExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OrElseExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AndAlsoExpression">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PlusExpression">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NegateExpression">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NotExpression">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AddressOfExpression">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.BinaryConditionalExpression">
	<summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TernaryConditionalExpression">
	<summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SingleLineFunctionLambdaExpression">
	<summary>
 Represents a single line lambda expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SingleLineSubLambdaExpression">
	<summary>
 Represents a single line lambda expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MultiLineFunctionLambdaExpression">
	<summary>
 Represents a multi-line lambda expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MultiLineSubLambdaExpression">
	<summary>
 Represents a multi-line lambda expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SubLambdaHeader">
	<summary>
 Represents the header part of a lambda expression
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FunctionLambdaHeader">
	<summary>
 Represents the header part of a lambda expression
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ArgumentList">
	<summary>
 Represents a parenthesized argument list.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OmittedArgument">
	<summary>
 Represents an omitted argument in an argument list. An omitted argument is not
 considered a syntax error but a valid case when no argument is required.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SimpleArgument">
	<summary>
 Represents a simple argument that is just an expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NamedArgument">
	<summary>
 Represents a named argument, such as "Value:=7".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RangeArgument">
	<summary>
 Represents a range argument, such as "0 to 5", used in array bounds. The
 "Value" property represents the upper bound of the range.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.QueryExpression">
	<summary>
 This class represents a query expression. A query expression is composed of one
 or more query operators in a row. The first query operator must be a From or
 Aggregate.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CollectionRangeVariable">
	<summary>
 Describes a single variable of the form "x [As Type] In expression" for use in
 query expressions.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExpressionRangeVariable">
	<summary>
 Describes a single variable of the form "[x [As Type] =] expression" for use in
 query expressions.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AggregationRangeVariable">
	<summary>
 Describes a single variable of the form "[x [As Type] =] aggregation-function"
 for use in the Into clause of Aggregate or Group By or Group Join query
 operators.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.VariableNameEquals">
	<summary>
 Represents the name and optional type of an expression range variable.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FunctionAggregation">
	<summary>
 Represents an invocation of an Aggregation function in the aggregation range
 variable declaration of a Group By, Group Join or Aggregate query operator.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GroupAggregation">
	<summary>
 Represents the use of "Group" as the aggregation function in the in the
 aggregation range variable declaration of a Group By or Group Join query
 operator.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FromClause">
	<summary>
 Represents a "From" query operator. If this is the beginning of a query, the
 Source will be Nothing. Otherwise, the Source will be the part of the query to
 the left of the From.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LetClause">
	<summary>
 Represents a "Let" query operator.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AggregateClause">
	<summary>
 Represents an Aggregate query operator.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DistinctClause">
	<summary>
 Represents the "Distinct" query operator.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WhereClause">
	<summary>
 Represents a "Where" query operator.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SkipWhileClause">
	<summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TakeWhileClause">
	<summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SkipClause">
	<summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TakeClause">
	<summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GroupByClause">
	<summary>
 Represents the "Group By" query operator.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.JoinClause">
	<summary>
 Represents a Join query operator.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.JoinCondition">
	<summary>
 Represents the "expression Equals expression" condition in a Join.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GroupJoinClause">
	<summary>
 Represents the "Group Join" query operator.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OrderByClause">
	<summary>
 Represents the "Order By" query operator.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AscendingOrdering">
	<summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DescendingOrdering">
	<summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SelectClause">
	<summary>
 Represents the "Select" query operator.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlDocument">
	<summary>
 Represents and XML Document literal expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlDeclaration">
	<summary>
 Represents the XML declaration prologue in an XML literal expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlDeclarationOption">
	<summary>
 Represents an XML document prologue option - version, encoding, standalone or
 whitespace in an XML literal expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlElement">
	<summary>
 Represents an XML element with content in an XML literal expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlText">
	<summary>
 Represents Xml text.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlElementStartTag">
	<summary>
 Represents the start tag of an XML element of the form &lt;element&gt;.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlElementEndTag">
	<summary>
 Represents the end tag of an XML element of the form &lt;/element&gt;.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlEmptyElement">
	<summary>
 Represents an empty XML element of the form &lt;element /&gt;
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlAttribute">
	<summary>
 Represents an XML attribute in an XML literal expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlString">
	<summary>
 Represents a string of XML characters embedded as the content of an XML
 element.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlPrefixName">
	<summary>
 Represents an XML name of the form 'name' appearing in GetXmlNamespace().
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlName">
	<summary>
 Represents an XML name of the form 'name' or 'namespace:name' appearing in
 source as part of an XML literal or member access expression or an XML
 namespace import clause.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlBracketedName">
	<summary>
 Represents an XML name of the form &lt;xml-name&gt; appearing in source as part
 of an XML literal or member access expression or an XML namespace import
 clause.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlPrefix">
	<summary>
 Represents and XML namespace prefix of the form 'prefix:' as in xml:ns="".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlComment">
	<summary>
 Represents an XML comment of the form &lt;-- Comment --&gt; appearing in an XML
 literal expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlProcessingInstruction">
	<summary>
 Represents an XML processing instruction of the form '&lt;? XMLProcessingTarget
 XMLProcessingValue ?&gt;'.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlCDataSection">
	<summary>
 Represents an XML CDATA section in an XML literal expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlEmbeddedExpression">
	<summary>
 Represents an embedded expression in an XML literal e.g. '&lt;name&gt;&lt;%=
 obj.Name =%&gt;&lt;/name&gt;'.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ArrayType">
	<summary>
 Represents an array type, such as "A() or "A(,)", without bounds specified for
 the array.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NullableType">
	<summary>
 A type name that represents a nullable type, such as "Integer?".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PredefinedType">
	<summary>
 Represents an occurrence of a Visual Basic built-in type such as Integer or
 String in source code.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IdentifierName">
	<summary>
 Represents a type name consisting of a single identifier (which might include
 brackets or a type character).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GenericName">
	<summary>
 Represents a simple type name with one or more generic arguments, such as "X(Of
 Y, Z).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.QualifiedName">
	<summary>
 Represents a qualified type name, for example X.Y or X(Of Z).Y.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GlobalName">
	<summary>
 Represents a name in the global namespace.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TypeArgumentList">
	<summary>
 Represents a parenthesized list of generic type arguments.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AddHandlerKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AddressOfKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AliasKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AndKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AndAlsoKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AsKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.BooleanKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ByRefKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ByteKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ByValKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CallKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaseKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CatchKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CBoolKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CByteKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CCharKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CDateKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CDecKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CDblKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CharKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CIntKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ClassKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CLngKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CObjKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ConstKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ReferenceKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ContinueKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CSByteKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CShortKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CSngKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CStrKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CTypeKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CUIntKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CULngKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CUShortKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DateKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DecimalKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DeclareKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DefaultKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DelegateKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DimKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DirectCastKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DoKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DoubleKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EachKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ElseKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ElseIfKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EnumKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EraseKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ErrorKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EventKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExitKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FalseKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FinallyKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ForKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FriendKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FunctionKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GetKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GetTypeKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GetXmlNamespaceKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GlobalKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GoToKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.HandlesKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IfKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ImplementsKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ImportsKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.InKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.InheritsKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IntegerKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.InterfaceKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IsKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IsNotKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LetKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LibKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LikeKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LongKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LoopKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MeKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ModKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ModuleKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MustInheritKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MustOverrideKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MyBaseKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MyClassKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NamespaceKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NarrowingKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NextKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NewKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NotKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NothingKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NotInheritableKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.NotOverridableKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ObjectKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OfKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OnKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OperatorKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OptionKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OptionalKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OrKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OrElseKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OverloadsKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OverridableKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OverridesKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ParamArrayKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PartialKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PrivateKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PropertyKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ProtectedKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PublicKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RaiseEventKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ReadOnlyKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ReDimKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.REMKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RemoveHandlerKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ResumeKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ReturnKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SByteKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SelectKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SetKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ShadowsKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SharedKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ShortKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SingleKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StaticKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StepKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StopKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StringKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StructureKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SubKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SyncLockKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ThenKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ThrowKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ToKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TrueKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TryKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TryCastKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TypeOfKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.UIntegerKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ULongKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.UShortKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.UsingKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WhenKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WhileKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WideningKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WithKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WithEventsKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WriteOnlyKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XorKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndIfKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GosubKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.VariantKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WendKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AggregateKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AllKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AnsiKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AscendingKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AssemblyKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AutoKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.BinaryKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ByKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CompareKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CustomKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DescendingKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DistinctKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EqualsKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExplicitKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExternalSourceKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExternalChecksumKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FromKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GroupKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.InferKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IntoKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IsFalseKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IsTrueKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.JoinKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.KeyKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MidKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OffKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OrderKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OutKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PreserveKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RegionKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SkipKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StrictKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TakeKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TextKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.UnicodeKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.UntilKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WhereKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.TypeKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlKeyword">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExclamationToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AtToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CommaToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.HashToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AmpersandToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SingleQuoteToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OpenParenToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CloseParenToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.OpenBraceToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CloseBraceToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SemicolonToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AsteriskToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PlusToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MinusToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DotToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SlashToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ColonToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LessThanToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LessThanEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LessThanGreaterThanToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GreaterThanToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GreaterThanEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.BackslashToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaretToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ColonEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AmpersandEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.AsteriskEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PlusEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MinusEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SlashEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.BackslashEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CaretEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LessThanLessThanToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GreaterThanGreaterThanToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LessThanLessThanEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.GreaterThanGreaterThanEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.QuestionToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DoubleQuoteToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StatementTerminatorToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndOfFileToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EmptyToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SlashGreaterThanToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LessThanSlashToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LessThanMinusMinusToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.MinusMinusGreaterThanToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LessThanQuestionToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.QuestionGreaterThanToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LessThanPercentEqualsToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.PercentGreaterThanToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.BeginCDataToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndCDataToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndOfXmlToken">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.BadToken">
	<summary>
 Represents a sequence of characters appearing in source with no possible
 meaning in the Visual Basic language (e.g. the semicolon ';'). This token
 should only appear in SkippedTokenTrivia as an artifact of parsing error
 recovery.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlNameToken">
	<summary>
 Represents an Xml NCName per Namespaces in XML 1.0
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlTextLiteralToken">
	<summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.XmlEntityLiteralToken">
	<summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DocumentationCommentLineBreakToken">
	<summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IdentifierToken">
	<summary>
 Represents an identifier token. This might include brackets around the name and
 a type character.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IntegerLiteralToken">
	<summary>
 Represents an integer literal token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.FloatingLiteralToken">
	<summary>
 Represents an floating literal token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DecimalLiteralToken">
	<summary>
 Represents a Decimal literal token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DateLiteralToken">
	<summary>
 Represents an Date literal token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.StringLiteralToken">
	<summary>
 Represents an string literal token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CharacterLiteralToken">
	<summary>
 Represents an string literal token.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.SkippedTokensTrivia">
	<summary>
 Represents tokens that were skipped by the parser as part of error recovery,
 and thus are not part of any syntactic structure.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DocumentationCommentTrivia">
	<summary>
 Represents a documentation comment e.g. ''' &lt;Summary&gt; apearing in source.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DirectiveTrivia">
	<summary>
 Represents a preprocessor directive
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.WhitespaceTrivia">
	<summary>
 Represents true whitespace: spaces, tabs, newlines and the like.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndOfLineTrivia">
	<summary>
 Represents line breaks that are syntactically insignificant.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ColonTrivia">
	<summary>
 Represents colons that are syntactically insignificant.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.CommentTrivia">
	<summary>
 Represents a comment.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.LineContinuationTrivia">
	<summary>
 Represents an explicit line continuation character at the end of a line, i.e.,
 _
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ImplicitLineContinuationTrivia">
	<summary>
 Represents an implicit line continuation.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DocumentationCommentExteriorTrivia">
	<summary>
 Represents a ''' prefix for an XML Documentation Comment.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.DisabledTextTrivia">
	<summary>
 Represents text in a false preprocessor block
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ConstDirective">
	<summary>
 Represents a #Const pre-processing constant declaration appearing in source.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.IfDirective">
	<summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ElseIfDirective">
	<summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ElseDirective">
	<summary>
 Represents an #Else pre-processing directive appearing in source.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndIfDirective">
	<summary>
 Represents an #End If pre-processing directive appearing in source.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.RegionDirective">
	<summary>
 Represents the beginning of a #Region directive appearing in source.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndRegionDirective">
	<summary>
 Represents an #End Region directive appearing in source.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExternalSourceDirective">
	<summary>
 Represents the beginning of a #ExternalSource pre-processing directive
 appearing in source.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.EndExternalSourceDirective">
	<summary>
 Represents an #End ExternalSource pre-processing directive appearing in source.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ExternalChecksumDirective">
	<summary>
 Represents an #ExternalChecksum pre-processing directive appearing in source.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.ReferenceDirective">
	<summary>
 Represents an #r directive appearing in scripts.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxKind.BadDirective">
	<summary>
 Represents an unrecognized pre-processing directive. This occurs when the
 parser encounters a hash '#' token at the beginning of a physical line but does
 recognize the text that follows as a valid Visual Basic pre-processing
 directive.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyntaxKind">
	<summary>
 Enumeration with all Visual Basic syntax node kinds.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.Integer">
	<summary>
 The "%" type character."
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.Long">
	<summary>
 The "&amp;" type character."
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.Decimal">
	<summary>
 The "@" type character."
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.Single">
	<summary>
 The "!" type character."
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.Double">
	<summary>
 The "#" type character."
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.String">
	<summary>
 The "$" type character."
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.ShortLiteral">
	<summary>
 The "S" literal suffix denoting "Short"
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.UShortLiteral">
	<summary>
 The "US" literal suffix denoting "UShort"
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.IntegerLiteral">
	<summary>
 The "I" literal suffix denoting "Integer"
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.UIntegerLiteral">
	<summary>
 The "UI" literal suffix denoting "UInteger"
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.LongLiteral">
	<summary>
 The "L" literal suffix denoting "Long"
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.ULongLiteral">
	<summary>
 The "UL" literal suffix denoting "ULong"
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.SingleLiteral">
	<summary>
 The "F" literal suffix denoting "Single"
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.DoubleLiteral">
	<summary>
 The "R" literal suffix denoting "Double"
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCharacter.DecimalLiteral">
	<summary>
 The "D" literal suffix denoting "Decimal"
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeCharacter">
	<summary>
 Represents one of the type characters or literal suffixes of VB. Used to
 describe a) the type character suffixes that can be placed on identifers, and
 b) the suffixes that can be placed on integer literals.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LiteralBase">
	<summary>
 The three possible number bases that a literal can be written in.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyntaxNode">
	<summary>
 The base class for all nodes in the VB syntax tree.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.StatementSyntax">
	<summary>
 The base class for all nodes that represent statements. This includes both
 declaration statements, such as class declarations as well as executable
 statements.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ExecutableStatementSyntax">
	<summary>
 The base class for all nodes that represent executable statements.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.DeclarationStatementSyntax">
	<summary>
 The base class for all nodes that represent statements that declare options,
 imports, members, etc.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EmptyStatementSyntax.Empty">
	<summary>
 An empty token because all non terminals must have a token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EmptyStatementSyntax.WithEmpty(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Empty property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EmptyStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new EmptyStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="empty">
 The new Empty to update this EmptyStatementSyntaxSyntax node with. If not
 specified the current Empty will be used in the new EmptyStatementSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.EmptyStatementSyntax">
	<summary>
 A class to represent an empty statement. This can occur when a colon is on a
 line without anything else.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax.EndKeyword">
	<summary>
 The "End" keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax.WithEndKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the EndKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax.BlockKeyword">
	<summary>
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax.WithBlockKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BlockKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new EndBlockStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="endKeyword">
 The new EndKeyword to update this EndBlockStatementSyntaxSyntax node with. If
 not specified the current EndKeyword will be used in the new
 EndBlockStatementSyntaxSyntax node.
 </param>
	<param name="blockKeyword">
 The new BlockKeyword to update this EndBlockStatementSyntaxSyntax node with. If
 not specified the current BlockKeyword will be used in the new
 EndBlockStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationUnitSyntax.Options">
	<summary>
 Represents the list of Option statements at the beginning of a source file.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CompilationUnitSyntax.WithOptions(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.OptionStatementSyntax})">
	<summary>
 Creates a new node and sets the Options property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationUnitSyntax.Imports">
	<summary>
 Represents the list of Imports statements at the beginning of a source file.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CompilationUnitSyntax.WithImports(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImportsStatementSyntax})">
	<summary>
 Creates a new node and sets the [Imports] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationUnitSyntax.Attributes">
	<summary>
 Represents the list of AttributeStatements at the beginning of a source file
 that contain the Assembly and Module attributes.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CompilationUnitSyntax.WithAttributes(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AttributesStatementSyntax})">
	<summary>
 Creates a new node and sets the Attributes property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationUnitSyntax.Members">
	<summary>
 Represents the members of the default namespace for this source file: all the
 top-level type and namespace declarations in the file. May also contain
 Statements that are not valid
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CompilationUnitSyntax.WithMembers(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new node and sets the Members property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationUnitSyntax.EndOfFileToken">
	<summary>
 Represents the end of the source file. This token may have trivia (whitespace,
 comments, ...) attached to it.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CompilationUnitSyntax.WithEndOfFileToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the EndOfFileToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CompilationUnitSyntax.Update(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.OptionStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImportsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AttributesStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new CompilationUnitSyntaxSyntax node with the specified changes.
 </summary>
	<param name="options">
 The new Options to update this CompilationUnitSyntaxSyntax node with. If not
 specified the current Options will be used in the new
 CompilationUnitSyntaxSyntax node.
 </param>
	<param name="imports">
 The new Imports to update this CompilationUnitSyntaxSyntax node with. If not
 specified the current Imports will be used in the new
 CompilationUnitSyntaxSyntax node.
 </param>
	<param name="attributes">
 The new Attributes to update this CompilationUnitSyntaxSyntax node with. If not
 specified the current Attributes will be used in the new
 CompilationUnitSyntaxSyntax node.
 </param>
	<param name="members">
 The new Members to update this CompilationUnitSyntaxSyntax node with. If not
 specified the current Members will be used in the new
 CompilationUnitSyntaxSyntax node.
 </param>
	<param name="endOfFileToken">
 The new EndOfFileToken to update this CompilationUnitSyntaxSyntax node with. If
 not specified the current EndOfFileToken will be used in the new
 CompilationUnitSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CompilationUnitSyntax">
	<summary>
 Represents an entire source file of VB code.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OptionStatementSyntax.OptionKeyword">
	<summary>
 The "Option" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OptionStatementSyntax.WithOptionKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OptionKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.OptionStatementSyntax.NameKeyword">
	<summary>
 The keyword that identifies the option being set: Explicit, Strict, Compare or
 Infer.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OptionStatementSyntax.WithNameKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the NameKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.OptionStatementSyntax.ValueKeyword">
	<summary>
 The keyword that identifiers the value being set for the opition: On, Off, Text
 or Binary.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OptionStatementSyntax.WithValueKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ValueKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OptionStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new OptionStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="optionKeyword">
 The new OptionKeyword to update this OptionStatementSyntaxSyntax node with. If
 not specified the current OptionKeyword will be used in the new
 OptionStatementSyntaxSyntax node.
 </param>
	<param name="nameKeyword">
 The new NameKeyword to update this OptionStatementSyntaxSyntax node with. If
 not specified the current NameKeyword will be used in the new
 OptionStatementSyntaxSyntax node.
 </param>
	<param name="valueKeyword">
 The new ValueKeyword to update this OptionStatementSyntaxSyntax node with. If
 not specified the current ValueKeyword will be used in the new
 OptionStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.OptionStatementSyntax">
	<summary>
 Represents an Option statement, such as "Option Strict On".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ImportsStatementSyntax.ImportsKeyword">
	<summary>
 The "Imports" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImportsStatementSyntax.WithImportsKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ImportsKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ImportsStatementSyntax.ImportsClauses">
	<summary>
 A list of one or more import clauses. Each clause is either an alias, namespace
 or XML namespace import.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImportsStatementSyntax.WithImportsClauses(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImportsClauseSyntax})">
	<summary>
 Creates a new node and sets the ImportsClauses property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImportsStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImportsClauseSyntax})">
	<summary>
 Creates a new ImportsStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="importsKeyword">
 The new ImportsKeyword to update this ImportsStatementSyntaxSyntax node with.
 If not specified the current ImportsKeyword will be used in the new
 ImportsStatementSyntaxSyntax node.
 </param>
	<param name="importsClauses">
 The new ImportsClauses to update this ImportsStatementSyntaxSyntax node with.
 If not specified the current ImportsClauses will be used in the new
 ImportsStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ImportsStatementSyntax">
	<summary>
 Represents an Imports statement, which has one or more imports clauses.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ImportsClauseSyntax">
	<summary>
 The base class for the possible clauses of an Imports statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AliasImportsClauseSyntax.Alias">
	<summary>
 The identifier that the alias is being defined for.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AliasImportsClauseSyntax.WithAlias(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the [Alias] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AliasImportsClauseSyntax.EqualsToken">
	<summary>
 The equals sign token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AliasImportsClauseSyntax.WithEqualsToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the EqualsToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AliasImportsClauseSyntax.Name">
	<summary>
 The namespace or type the alias refers to.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AliasImportsClauseSyntax.WithName(Roslyn.Compilers.VisualBasic.NameSyntax)">
	<summary>
 Creates a new node and sets the Name property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AliasImportsClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.NameSyntax)">
	<summary>
 Creates a new AliasImportsClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="alias">
 The new Alias to update this AliasImportsClauseSyntaxSyntax node with. If not
 specified the current Alias will be used in the new
 AliasImportsClauseSyntaxSyntax node.
 </param>
	<param name="equalsToken">
 The new EqualsToken to update this AliasImportsClauseSyntaxSyntax node with. If
 not specified the current EqualsToken will be used in the new
 AliasImportsClauseSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this AliasImportsClauseSyntaxSyntax node with. If not
 specified the current Name will be used in the new
 AliasImportsClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AliasImportsClauseSyntax">
	<summary>
 Represents the clause of an Imports statement that defines an alias for a
 namespace or type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MembersImportsClauseSyntax.Name">
	<summary>
 The namespace or type being imported.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MembersImportsClauseSyntax.WithName(Roslyn.Compilers.VisualBasic.NameSyntax)">
	<summary>
 Creates a new node and sets the Name property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MembersImportsClauseSyntax.Update(Roslyn.Compilers.VisualBasic.NameSyntax)">
	<summary>
 Creates a new MembersImportsClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="name">
 The new Name to update this MembersImportsClauseSyntaxSyntax node with. If not
 specified the current Name will be used in the new
 MembersImportsClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.MembersImportsClauseSyntax">
	<summary>
 Represents the clause of an Imports statement that imports all members of a
 namespace.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlNamespaceImportsClauseSyntax.WithLessThanToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the LessThanToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlNamespaceImportsClauseSyntax.XmlNamespace">
	<summary>
 Identifies the XML namespace alias and URI.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlNamespaceImportsClauseSyntax.WithXmlNamespace(Roslyn.Compilers.VisualBasic.XmlAttributeSyntax)">
	<summary>
 Creates a new node and sets the XmlNamespace property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlNamespaceImportsClauseSyntax.WithGreaterThanToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the GreaterThanToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlNamespaceImportsClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlAttributeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlNamespaceImportsClauseSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="lessThanToken">
 The new LessThanToken to update this XmlNamespaceImportsClauseSyntaxSyntax node
 with. If not specified the current LessThanToken will be used in the new
 XmlNamespaceImportsClauseSyntaxSyntax node.
 </param>
	<param name="xmlNamespace">
 The new XmlNamespace to update this XmlNamespaceImportsClauseSyntaxSyntax node
 with. If not specified the current XmlNamespace will be used in the new
 XmlNamespaceImportsClauseSyntaxSyntax node.
 </param>
	<param name="greaterThanToken">
 The new GreaterThanToken to update this XmlNamespaceImportsClauseSyntaxSyntax
 node with. If not specified the current GreaterThanToken will be used in the
 new XmlNamespaceImportsClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlNamespaceImportsClauseSyntax">
	<summary>
 Defines a XML namespace for XML expressions.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceBlockSyntax.Begin">
	<summary>
 The statement that begins the NamespaceBlock.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceBlockSyntax.WithBegin(Roslyn.Compilers.VisualBasic.NamespaceStatementSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceBlockSyntax.WithBeginTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginTerminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceBlockSyntax.Members">
	<summary>
 The declarations contained in the namespace statement.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceBlockSyntax.WithMembers(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new node and sets the Members property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceBlockSyntax.End">
	<summary>
 The End Namespace statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceBlockSyntax.WithEnd(Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new node and sets the [End] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceBlockSyntax.Update(Roslyn.Compilers.VisualBasic.NamespaceStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new NamespaceBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this NamespaceBlockSyntaxSyntax node with. If not
 specified the current Begin will be used in the new NamespaceBlockSyntaxSyntax
 node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this NamespaceBlockSyntaxSyntax node with. If
 not specified the current BeginTerminator will be used in the new
 NamespaceBlockSyntaxSyntax node.
 </param>
	<param name="members">
 The new Members to update this NamespaceBlockSyntaxSyntax node with. If not
 specified the current Members will be used in the new
 NamespaceBlockSyntaxSyntax node.
 </param>
	<param name="end">
 The new End to update this NamespaceBlockSyntaxSyntax node with. If not
 specified the current End will be used in the new NamespaceBlockSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.NamespaceBlockSyntax">
	<summary>
 Represents a Namespace statement, its contents and the End Namespace statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceStatementSyntax.NamespaceKeyword">
	<summary>
 The "Namespace" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceStatementSyntax.WithNamespaceKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the NamespaceKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceStatementSyntax.Name">
	<summary>
 A (possibly dotted) name denoting the namespace being declared.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceStatementSyntax.WithName(Roslyn.Compilers.VisualBasic.NameSyntax)">
	<summary>
 Creates a new node and sets the Name property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.NameSyntax)">
	<summary>
 Creates a new NamespaceStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="namespaceKeyword">
 The new NamespaceKeyword to update this NamespaceStatementSyntaxSyntax node
 with. If not specified the current NamespaceKeyword will be used in the new
 NamespaceStatementSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this NamespaceStatementSyntaxSyntax node with. If not
 specified the current Name will be used in the new
 NamespaceStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.NamespaceStatementSyntax">
	<summary>
 Represents the beginning statement of a namespace declaration. This node always
 appears as the Begin of a BlockStatement with Kind=NamespaceBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeBlockSyntax.Begin">
	<summary>
 The statement that begins the type or module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeBlockSyntax.Inherits">
	<summary>
 A list of the Inherits declarations for the type.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeBlockSyntax.Implements">
	<summary>
 A list of the Implements declarations for the type.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeBlockSyntax.Members">
	<summary>
 The declarations contained in the type or module.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeBlockSyntax.End">
	<summary>
 The End XXX statement that ends the block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeBlockSyntax">
	<summary>
 Represents a declaration of a Class, Interface, Structure, Module, its contents
 and the End statement that ends it.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleBlockSyntax.Begin">
	<summary>
 The statement that begins the type or module.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleBlockSyntax.WithBegin(Roslyn.Compilers.VisualBasic.ModuleStatementSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleBlockSyntax.WithBeginTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginTerminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleBlockSyntax.Inherits">
	<summary>
 A list of the Inherits declarations for the type.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleBlockSyntax.WithInherits(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InheritsStatementSyntax})">
	<summary>
 Creates a new node and sets the [Inherits] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleBlockSyntax.Implements">
	<summary>
 A list of the Implements declarations for the type.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleBlockSyntax.WithImplements(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax})">
	<summary>
 Creates a new node and sets the [Implements] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleBlockSyntax.Members">
	<summary>
 The declarations contained in the type or module.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleBlockSyntax.WithMembers(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new node and sets the Members property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleBlockSyntax.End">
	<summary>
 The End XXX statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleBlockSyntax.WithEnd(Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new node and sets the [End] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleBlockSyntax.Update(Roslyn.Compilers.VisualBasic.ModuleStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new ModuleBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this ModuleBlockSyntaxSyntax node with. If not
 specified the current Begin will be used in the new ModuleBlockSyntaxSyntax
 node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this ModuleBlockSyntaxSyntax node with. If
 not specified the current BeginTerminator will be used in the new
 ModuleBlockSyntaxSyntax node.
 </param>
	<param name="inherits">
 The new Inherits to update this ModuleBlockSyntaxSyntax node with. If not
 specified the current Inherits will be used in the new ModuleBlockSyntaxSyntax
 node.
 </param>
	<param name="implements">
 The new Implements to update this ModuleBlockSyntaxSyntax node with. If not
 specified the current Implements will be used in the new
 ModuleBlockSyntaxSyntax node.
 </param>
	<param name="members">
 The new Members to update this ModuleBlockSyntaxSyntax node with. If not
 specified the current Members will be used in the new ModuleBlockSyntaxSyntax
 node.
 </param>
	<param name="end">
 The new End to update this ModuleBlockSyntaxSyntax node with. If not specified
 the current End will be used in the new ModuleBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ModuleBlockSyntax">
	<summary>
 Represents a declaration of Module, its contents and the End statement that
 ends it.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.StructureBlockSyntax.Begin">
	<summary>
 The statement that begins the type or module.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.StructureBlockSyntax.WithBegin(Roslyn.Compilers.VisualBasic.StructureStatementSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.StructureBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.StructureBlockSyntax.WithBeginTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginTerminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.StructureBlockSyntax.Inherits">
	<summary>
 A list of the Inherits declarations for the type.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.StructureBlockSyntax.WithInherits(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InheritsStatementSyntax})">
	<summary>
 Creates a new node and sets the [Inherits] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.StructureBlockSyntax.Implements">
	<summary>
 A list of the Implements declarations for the type.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.StructureBlockSyntax.WithImplements(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax})">
	<summary>
 Creates a new node and sets the [Implements] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.StructureBlockSyntax.Members">
	<summary>
 The declarations contained in the type or module.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.StructureBlockSyntax.WithMembers(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new node and sets the Members property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.StructureBlockSyntax.End">
	<summary>
 The End XXX statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.StructureBlockSyntax.WithEnd(Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new node and sets the [End] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.StructureBlockSyntax.Update(Roslyn.Compilers.VisualBasic.StructureStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new StructureBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this StructureBlockSyntaxSyntax node with. If not
 specified the current Begin will be used in the new StructureBlockSyntaxSyntax
 node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this StructureBlockSyntaxSyntax node with. If
 not specified the current BeginTerminator will be used in the new
 StructureBlockSyntaxSyntax node.
 </param>
	<param name="inherits">
 The new Inherits to update this StructureBlockSyntaxSyntax node with. If not
 specified the current Inherits will be used in the new
 StructureBlockSyntaxSyntax node.
 </param>
	<param name="implements">
 The new Implements to update this StructureBlockSyntaxSyntax node with. If not
 specified the current Implements will be used in the new
 StructureBlockSyntaxSyntax node.
 </param>
	<param name="members">
 The new Members to update this StructureBlockSyntaxSyntax node with. If not
 specified the current Members will be used in the new
 StructureBlockSyntaxSyntax node.
 </param>
	<param name="end">
 The new End to update this StructureBlockSyntaxSyntax node with. If not
 specified the current End will be used in the new StructureBlockSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.StructureBlockSyntax">
	<summary>
 Represents a declaration of a Structure, its contents and the End statement
 that ends it.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InterfaceBlockSyntax.Begin">
	<summary>
 The statement that begins the type or module.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InterfaceBlockSyntax.WithBegin(Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InterfaceBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InterfaceBlockSyntax.WithBeginTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginTerminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InterfaceBlockSyntax.Inherits">
	<summary>
 A list of the Inherits declarations for the type.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InterfaceBlockSyntax.WithInherits(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InheritsStatementSyntax})">
	<summary>
 Creates a new node and sets the [Inherits] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InterfaceBlockSyntax.Implements">
	<summary>
 A list of the Implements declarations for the type.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InterfaceBlockSyntax.WithImplements(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax})">
	<summary>
 Creates a new node and sets the [Implements] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InterfaceBlockSyntax.Members">
	<summary>
 The declarations contained in the type or module.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InterfaceBlockSyntax.WithMembers(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new node and sets the Members property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InterfaceBlockSyntax.End">
	<summary>
 The End XXX statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InterfaceBlockSyntax.WithEnd(Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new node and sets the [End] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InterfaceBlockSyntax.Update(Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new InterfaceBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this InterfaceBlockSyntaxSyntax node with. If not
 specified the current Begin will be used in the new InterfaceBlockSyntaxSyntax
 node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this InterfaceBlockSyntaxSyntax node with. If
 not specified the current BeginTerminator will be used in the new
 InterfaceBlockSyntaxSyntax node.
 </param>
	<param name="inherits">
 The new Inherits to update this InterfaceBlockSyntaxSyntax node with. If not
 specified the current Inherits will be used in the new
 InterfaceBlockSyntaxSyntax node.
 </param>
	<param name="implements">
 The new Implements to update this InterfaceBlockSyntaxSyntax node with. If not
 specified the current Implements will be used in the new
 InterfaceBlockSyntaxSyntax node.
 </param>
	<param name="members">
 The new Members to update this InterfaceBlockSyntaxSyntax node with. If not
 specified the current Members will be used in the new
 InterfaceBlockSyntaxSyntax node.
 </param>
	<param name="end">
 The new End to update this InterfaceBlockSyntaxSyntax node with. If not
 specified the current End will be used in the new InterfaceBlockSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.InterfaceBlockSyntax">
	<summary>
 Represents a declaration of a Interface, its contents and the End statement
 that ends it.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ClassBlockSyntax.Begin">
	<summary>
 The statement that begins the type or module.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ClassBlockSyntax.WithBegin(Roslyn.Compilers.VisualBasic.ClassStatementSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ClassBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ClassBlockSyntax.WithBeginTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginTerminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ClassBlockSyntax.Inherits">
	<summary>
 A list of the Inherits declarations for the type.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ClassBlockSyntax.WithInherits(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InheritsStatementSyntax})">
	<summary>
 Creates a new node and sets the [Inherits] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ClassBlockSyntax.Implements">
	<summary>
 A list of the Implements declarations for the type.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ClassBlockSyntax.WithImplements(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax})">
	<summary>
 Creates a new node and sets the [Implements] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ClassBlockSyntax.Members">
	<summary>
 The declarations contained in the type or module.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ClassBlockSyntax.WithMembers(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new node and sets the Members property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ClassBlockSyntax.End">
	<summary>
 The End XXX statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ClassBlockSyntax.WithEnd(Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new node and sets the [End] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ClassBlockSyntax.Update(Roslyn.Compilers.VisualBasic.ClassStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new ClassBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this ClassBlockSyntaxSyntax node with. If not specified
 the current Begin will be used in the new ClassBlockSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this ClassBlockSyntaxSyntax node with. If not
 specified the current BeginTerminator will be used in the new
 ClassBlockSyntaxSyntax node.
 </param>
	<param name="inherits">
 The new Inherits to update this ClassBlockSyntaxSyntax node with. If not
 specified the current Inherits will be used in the new ClassBlockSyntaxSyntax
 node.
 </param>
	<param name="implements">
 The new Implements to update this ClassBlockSyntaxSyntax node with. If not
 specified the current Implements will be used in the new ClassBlockSyntaxSyntax
 node.
 </param>
	<param name="members">
 The new Members to update this ClassBlockSyntaxSyntax node with. If not
 specified the current Members will be used in the new ClassBlockSyntaxSyntax
 node.
 </param>
	<param name="end">
 The new End to update this ClassBlockSyntaxSyntax node with. If not specified
 the current End will be used in the new ClassBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ClassBlockSyntax">
	<summary>
 Represents a declaration of a Class its contents and the End statement that
 ends it.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EnumBlockSyntax.Begin">
	<summary>
 The statement that begins the type or module.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EnumBlockSyntax.WithBegin(Roslyn.Compilers.VisualBasic.EnumStatementSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EnumBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EnumBlockSyntax.WithBeginTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginTerminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EnumBlockSyntax.Members">
	<summary>
 The declarations contained in the enumeration.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EnumBlockSyntax.WithMembers(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new node and sets the Members property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EnumBlockSyntax.End">
	<summary>
 The End XXX statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EnumBlockSyntax.WithEnd(Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new node and sets the [End] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EnumBlockSyntax.Update(Roslyn.Compilers.VisualBasic.EnumStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new EnumBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this EnumBlockSyntaxSyntax node with. If not specified
 the current Begin will be used in the new EnumBlockSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this EnumBlockSyntaxSyntax node with. If not
 specified the current BeginTerminator will be used in the new
 EnumBlockSyntaxSyntax node.
 </param>
	<param name="members">
 The new Members to update this EnumBlockSyntaxSyntax node with. If not
 specified the current Members will be used in the new EnumBlockSyntaxSyntax
 node.
 </param>
	<param name="end">
 The new End to update this EnumBlockSyntaxSyntax node with. If not specified
 the current End will be used in the new EnumBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.EnumBlockSyntax">
	<summary>
 Represents a declaration of an Enum, its contents and the End Enum statement
 that ends it.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InheritsOrImplementsStatementSyntax">
	<summary>
 Represents an Inherits or Implements statement in a Class, Structure or
 Interface.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InheritsStatementSyntax.InheritsKeyword">
	<summary>
 The "Inherits" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InheritsStatementSyntax.WithInheritsKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the InheritsKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InheritsStatementSyntax.Types">
	<summary>
 A list of the types being inherited.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InheritsStatementSyntax.WithTypes(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeSyntax})">
	<summary>
 Creates a new node and sets the Types property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InheritsStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeSyntax})">
	<summary>
 Creates a new InheritsStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="inheritsKeyword">
 The new InheritsKeyword to update this InheritsStatementSyntaxSyntax node with.
 If not specified the current InheritsKeyword will be used in the new
 InheritsStatementSyntaxSyntax node.
 </param>
	<param name="types">
 The new Types to update this InheritsStatementSyntaxSyntax node with. If not
 specified the current Types will be used in the new
 InheritsStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.InheritsStatementSyntax">
	<summary>
 Represents an Inherits statement in a Class, Structure or Interface.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax.ImplementsKeyword">
	<summary>
 The "Implements" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax.WithImplementsKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ImplementsKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax.Types">
	<summary>
 A list of the types being implemented.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax.WithTypes(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeSyntax})">
	<summary>
 Creates a new node and sets the Types property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeSyntax})">
	<summary>
 Creates a new ImplementsStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="implementsKeyword">
 The new ImplementsKeyword to update this ImplementsStatementSyntaxSyntax node
 with. If not specified the current ImplementsKeyword will be used in the new
 ImplementsStatementSyntaxSyntax node.
 </param>
	<param name="types">
 The new Types to update this ImplementsStatementSyntaxSyntax node with. If not
 specified the current Types will be used in the new
 ImplementsStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax">
	<summary>
 Represents an Implements statement in a Class or Structure.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeStatementSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeStatementSyntax.Keyword">
	<summary>
 The "Module", "Class", "Interface" or "Structure" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeStatementSyntax.Identifier">
	<summary>
 The name of the type being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeStatementSyntax.TypeParameterList">
	<summary>
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeStatementSyntax">
	<summary>
 Abstract class for the beginning statement of a Module, Class, Interface or
 Structure declaration. This node always appears as the Begin of a TypeBlock
 with Kind=ModuleDeclarationBlock, ClassDeclarationBlock,
 InterfaceDeclarationBlock or StructureDeclarationBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleStatementSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleStatementSyntax.WithAttributeLists(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Creates a new node and sets the AttributeLists property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleStatementSyntax.WithModifiers(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the Modifiers property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleStatementSyntax.Keyword">
	<summary>
 The "Module", "Class", "Interface" or "Structure" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleStatementSyntax.WithKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Keyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleStatementSyntax.Identifier">
	<summary>
 The name of the type being declared.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleStatementSyntax.WithIdentifier(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Identifier property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleStatementSyntax.TypeParameterList">
	<summary>
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleStatementSyntax.WithTypeParameterList(Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Creates a new node and sets the TypeParameterList property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Creates a new ModuleStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributeLists">
 The new AttributeLists to update this ModuleStatementSyntaxSyntax node with. If
 not specified the current AttributeLists will be used in the new
 ModuleStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this ModuleStatementSyntaxSyntax node with. If not
 specified the current Modifiers will be used in the new
 ModuleStatementSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this ModuleStatementSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 ModuleStatementSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this ModuleStatementSyntaxSyntax node with. If not
 specified the current Identifier will be used in the new
 ModuleStatementSyntaxSyntax node.
 </param>
	<param name="typeParameterList">
 The new TypeParameterList to update this ModuleStatementSyntaxSyntax node with.
 If not specified the current TypeParameterList will be used in the new
 ModuleStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ModuleStatementSyntax">
	<summary>
 Represents the beginning statement of a Module declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.StructureStatementSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.StructureStatementSyntax.WithAttributeLists(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Creates a new node and sets the AttributeLists property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.StructureStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.StructureStatementSyntax.WithModifiers(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the Modifiers property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.StructureStatementSyntax.Keyword">
	<summary>
 The "Module", "Class", "Interface" or "Structure" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.StructureStatementSyntax.WithKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Keyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.StructureStatementSyntax.Identifier">
	<summary>
 The name of the type being declared.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.StructureStatementSyntax.WithIdentifier(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Identifier property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.StructureStatementSyntax.TypeParameterList">
	<summary>
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.StructureStatementSyntax.WithTypeParameterList(Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Creates a new node and sets the TypeParameterList property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.StructureStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Creates a new StructureStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributeLists">
 The new AttributeLists to update this StructureStatementSyntaxSyntax node with.
 If not specified the current AttributeLists will be used in the new
 StructureStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this StructureStatementSyntaxSyntax node with. If
 not specified the current Modifiers will be used in the new
 StructureStatementSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this StructureStatementSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 StructureStatementSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this StructureStatementSyntaxSyntax node with. If
 not specified the current Identifier will be used in the new
 StructureStatementSyntaxSyntax node.
 </param>
	<param name="typeParameterList">
 The new TypeParameterList to update this StructureStatementSyntaxSyntax node
 with. If not specified the current TypeParameterList will be used in the new
 StructureStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.StructureStatementSyntax">
	<summary>
 Represents the beginning statement of a Structure declaration. This node always
 appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax.WithAttributeLists(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Creates a new node and sets the AttributeLists property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax.WithModifiers(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the Modifiers property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax.Keyword">
	<summary>
 The "Module", "Class", "Interface" or "Structure" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax.WithKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Keyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax.Identifier">
	<summary>
 The name of the type being declared.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax.WithIdentifier(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Identifier property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax.TypeParameterList">
	<summary>
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax.WithTypeParameterList(Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Creates a new node and sets the TypeParameterList property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Creates a new InterfaceStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributeLists">
 The new AttributeLists to update this InterfaceStatementSyntaxSyntax node with.
 If not specified the current AttributeLists will be used in the new
 InterfaceStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this InterfaceStatementSyntaxSyntax node with. If
 not specified the current Modifiers will be used in the new
 InterfaceStatementSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this InterfaceStatementSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 InterfaceStatementSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this InterfaceStatementSyntaxSyntax node with. If
 not specified the current Identifier will be used in the new
 InterfaceStatementSyntaxSyntax node.
 </param>
	<param name="typeParameterList">
 The new TypeParameterList to update this InterfaceStatementSyntaxSyntax node
 with. If not specified the current TypeParameterList will be used in the new
 InterfaceStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax">
	<summary>
 Represents the beginning statement of a Interface declaration. This node always
 appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ClassStatementSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ClassStatementSyntax.WithAttributeLists(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Creates a new node and sets the AttributeLists property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ClassStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ClassStatementSyntax.WithModifiers(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the Modifiers property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ClassStatementSyntax.Keyword">
	<summary>
 The "Module", "Class", "Interface" or "Structure" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ClassStatementSyntax.WithKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Keyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ClassStatementSyntax.Identifier">
	<summary>
 The name of the type being declared.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ClassStatementSyntax.WithIdentifier(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Identifier property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ClassStatementSyntax.TypeParameterList">
	<summary>
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ClassStatementSyntax.WithTypeParameterList(Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Creates a new node and sets the TypeParameterList property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ClassStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Creates a new ClassStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributeLists">
 The new AttributeLists to update this ClassStatementSyntaxSyntax node with. If
 not specified the current AttributeLists will be used in the new
 ClassStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this ClassStatementSyntaxSyntax node with. If not
 specified the current Modifiers will be used in the new
 ClassStatementSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this ClassStatementSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 ClassStatementSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this ClassStatementSyntaxSyntax node with. If not
 specified the current Identifier will be used in the new
 ClassStatementSyntaxSyntax node.
 </param>
	<param name="typeParameterList">
 The new TypeParameterList to update this ClassStatementSyntaxSyntax node with.
 If not specified the current TypeParameterList will be used in the new
 ClassStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ClassStatementSyntax">
	<summary>
 Represents the beginning statement of a Class declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EnumStatementSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EnumStatementSyntax.WithAttributeLists(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Creates a new node and sets the AttributeLists property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EnumStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EnumStatementSyntax.WithModifiers(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the Modifiers property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EnumStatementSyntax.EnumKeyword">
	<summary>
 The "Enum" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EnumStatementSyntax.WithEnumKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the EnumKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EnumStatementSyntax.Identifier">
	<summary>
 The name of the enum being declared.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EnumStatementSyntax.WithIdentifier(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Identifier property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EnumStatementSyntax.UnderlyingType">
	<summary>
 Optional "As XXX" clause describing the underlying type of the enumeration. If
 no As clause was specified, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EnumStatementSyntax.WithUnderlyingType(Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new node and sets the UnderlyingType property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EnumStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new EnumStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributeLists">
 The new AttributeLists to update this EnumStatementSyntaxSyntax node with. If
 not specified the current AttributeLists will be used in the new
 EnumStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this EnumStatementSyntaxSyntax node with. If not
 specified the current Modifiers will be used in the new
 EnumStatementSyntaxSyntax node.
 </param>
	<param name="enumKeyword">
 The new EnumKeyword to update this EnumStatementSyntaxSyntax node with. If not
 specified the current EnumKeyword will be used in the new
 EnumStatementSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this EnumStatementSyntaxSyntax node with. If not
 specified the current Identifier will be used in the new
 EnumStatementSyntaxSyntax node.
 </param>
	<param name="underlyingType">
 The new UnderlyingType to update this EnumStatementSyntaxSyntax node with. If
 not specified the current UnderlyingType will be used in the new
 EnumStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.EnumStatementSyntax">
	<summary>
 Represents the beginning statement of an Enum declaration. This node always
 appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterListSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterListSyntax.WithOpenParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OpenParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterListSyntax.OfKeyword">
	<summary>
 The "Of" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterListSyntax.WithOfKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OfKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterListSyntax.Parameters">
	<summary>
 A list of the type parameters. There must be at least one type parameter in the
 list.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterListSyntax.WithParameters(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeParameterSyntax})">
	<summary>
 Creates a new node and sets the Parameters property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterListSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterListSyntax.WithCloseParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CloseParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterListSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeParameterSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new TypeParameterListSyntaxSyntax node with the specified changes.
 </summary>
	<param name="openParenToken">
 The new OpenParenToken to update this TypeParameterListSyntaxSyntax node with.
 If not specified the current OpenParenToken will be used in the new
 TypeParameterListSyntaxSyntax node.
 </param>
	<param name="ofKeyword">
 The new OfKeyword to update this TypeParameterListSyntaxSyntax node with. If
 not specified the current OfKeyword will be used in the new
 TypeParameterListSyntaxSyntax node.
 </param>
	<param name="parameters">
 The new Parameters to update this TypeParameterListSyntaxSyntax node with. If
 not specified the current Parameters will be used in the new
 TypeParameterListSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this TypeParameterListSyntaxSyntax node with.
 If not specified the current CloseParenToken will be used in the new
 TypeParameterListSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeParameterListSyntax">
	<summary>
 Represents the type parameter list in a declaration.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterSyntax.VarianceKeyword">
	<summary>
 Represents the "In" or "Out" variance keyword on a type parameter, if present.
 If no variance modifier was present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterSyntax.WithVarianceKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the VarianceKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterSyntax.Identifier">
	<summary>
 The name of the type parameter
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterSyntax.WithIdentifier(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Identifier property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterSyntax.TypeParameterConstraintClause">
	<summary>
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterSyntax.WithTypeParameterConstraintClause(Roslyn.Compilers.VisualBasic.TypeParameterConstraintClauseSyntax)">
	<summary>
 Creates a new node and sets the TypeParameterConstraintClause property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterConstraintClauseSyntax)">
	<summary>
 Creates a new TypeParameterSyntaxSyntax node with the specified changes.
 </summary>
	<param name="varianceKeyword">
 The new VarianceKeyword to update this TypeParameterSyntaxSyntax node with. If
 not specified the current VarianceKeyword will be used in the new
 TypeParameterSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this TypeParameterSyntaxSyntax node with. If not
 specified the current Identifier will be used in the new
 TypeParameterSyntaxSyntax node.
 </param>
	<param name="typeParameterConstraintClause">
 The new TypeParameterConstraintClause to update this TypeParameterSyntaxSyntax
 node with. If not specified the current TypeParameterConstraintClause will be
 used in the new TypeParameterSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeParameterSyntax">
	<summary>
 Represents a type parameter on a generic type declaration.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeParameterConstraintClauseSyntax">
	<summary>
 An abstract node class that is the parent of classes that describe type
 parameter constraint clauses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterSingleConstraintClauseSyntax.AsKeyword">
	<summary>
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterSingleConstraintClauseSyntax.WithAsKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the AsKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterSingleConstraintClauseSyntax.Constraint">
	<summary>
 A list of the supplied constraints. If no constraints were supplied, Nothing is
 returned.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterSingleConstraintClauseSyntax.WithConstraint(Roslyn.Compilers.VisualBasic.ConstraintSyntax)">
	<summary>
 Creates a new node and sets the Constraint property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterSingleConstraintClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ConstraintSyntax)">
	<summary>
 Creates a new TypeParameterSingleConstraintClauseSyntaxSyntax node with the
 specified changes.
 </summary>
	<param name="asKeyword">
 The new AsKeyword to update this
 TypeParameterSingleConstraintClauseSyntaxSyntax node with. If not specified the
 current AsKeyword will be used in the new
 TypeParameterSingleConstraintClauseSyntaxSyntax node.
 </param>
	<param name="constraint">
 The new Constraint to update this
 TypeParameterSingleConstraintClauseSyntaxSyntax node with. If not specified the
 current Constraint will be used in the new
 TypeParameterSingleConstraintClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeParameterSingleConstraintClauseSyntax">
	<summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As Constraint".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterMultipleConstraintClauseSyntax.AsKeyword">
	<summary>
 The "As" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterMultipleConstraintClauseSyntax.WithAsKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the AsKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterMultipleConstraintClauseSyntax.OpenBraceToken">
	<summary>
 The "{" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterMultipleConstraintClauseSyntax.WithOpenBraceToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OpenBraceToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterMultipleConstraintClauseSyntax.Constraints">
	<summary>
 A list of the supplied constraints. If no constraints were supplied, an empty
 list is returned.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterMultipleConstraintClauseSyntax.WithConstraints(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ConstraintSyntax})">
	<summary>
 Creates a new node and sets the Constraints property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterMultipleConstraintClauseSyntax.CloseBraceToken">
	<summary>
 The "}" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterMultipleConstraintClauseSyntax.WithCloseBraceToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CloseBraceToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterMultipleConstraintClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ConstraintSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new TypeParameterMultipleConstraintClauseSyntaxSyntax node with the
 specified changes.
 </summary>
	<param name="asKeyword">
 The new AsKeyword to update this
 TypeParameterMultipleConstraintClauseSyntaxSyntax node with. If not specified
 the current AsKeyword will be used in the new
 TypeParameterMultipleConstraintClauseSyntaxSyntax node.
 </param>
	<param name="openBraceToken">
 The new OpenBraceToken to update this
 TypeParameterMultipleConstraintClauseSyntaxSyntax node with. If not specified
 the current OpenBraceToken will be used in the new
 TypeParameterMultipleConstraintClauseSyntaxSyntax node.
 </param>
	<param name="constraints">
 The new Constraints to update this
 TypeParameterMultipleConstraintClauseSyntaxSyntax node with. If not specified
 the current Constraints will be used in the new
 TypeParameterMultipleConstraintClauseSyntaxSyntax node.
 </param>
	<param name="closeBraceToken">
 The new CloseBraceToken to update this
 TypeParameterMultipleConstraintClauseSyntaxSyntax node with. If not specified
 the current CloseBraceToken will be used in the new
 TypeParameterMultipleConstraintClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeParameterMultipleConstraintClauseSyntax">
	<summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As { Constraints }".
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ConstraintSyntax">
	<summary>
 An abstract node class that is the parent of classes that describe type
 parameter constraints.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SpecialConstraintSyntax.ConstraintKeyword">
	<summary>
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SpecialConstraintSyntax.WithConstraintKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ConstraintKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SpecialConstraintSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new SpecialConstraintSyntaxSyntax node with the specified changes.
 </summary>
	<param name="constraintKeyword">
 The new ConstraintKeyword to update this SpecialConstraintSyntaxSyntax node
 with. If not specified the current ConstraintKeyword will be used in the new
 SpecialConstraintSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SpecialConstraintSyntax">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeConstraintSyntax.Type">
	<summary>
 The type describing the constraint.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeConstraintSyntax.WithType(Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Creates a new node and sets the Type property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeConstraintSyntax.Update(Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Creates a new TypeConstraintSyntaxSyntax node with the specified changes.
 </summary>
	<param name="type">
 The new Type to update this TypeConstraintSyntaxSyntax node with. If not
 specified the current Type will be used in the new TypeConstraintSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeConstraintSyntax">
	<summary>
 Represents a type parameter constraint that is a type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EnumMemberDeclarationSyntax.AttributeLists">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EnumMemberDeclarationSyntax.WithAttributeLists(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Creates a new node and sets the AttributeLists property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EnumMemberDeclarationSyntax.WithIdentifier(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Identifier property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EnumMemberDeclarationSyntax.Initializer">
	<summary>
 An optional value for the enum member.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EnumMemberDeclarationSyntax.WithInitializer(Roslyn.Compilers.VisualBasic.EqualsValueSyntax)">
	<summary>
 Creates a new node and sets the Initializer property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EnumMemberDeclarationSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.EqualsValueSyntax)">
	<summary>
 Creates a new EnumMemberDeclarationSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="attributeLists">
 The new AttributeLists to update this EnumMemberDeclarationSyntaxSyntax node
 with. If not specified the current AttributeLists will be used in the new
 EnumMemberDeclarationSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this EnumMemberDeclarationSyntaxSyntax node with.
 If not specified the current Identifier will be used in the new
 EnumMemberDeclarationSyntaxSyntax node.
 </param>
	<param name="initializer">
 The new Initializer to update this EnumMemberDeclarationSyntaxSyntax node with.
 If not specified the current Initializer will be used in the new
 EnumMemberDeclarationSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.EnumMemberDeclarationSyntax">
	<summary>
 Represents a name and value in an EnumDeclarationBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodBlockSyntax.Begin">
	<summary>
 The declaration that begins the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodBlockSyntax.WithBegin(Roslyn.Compilers.VisualBasic.MethodBaseSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodBlockSyntax.WithBeginTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginTerminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodBlockSyntax.Statements">
	<summary>
 The statements contained in the block statement. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodBlockSyntax.WithStatements(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new node and sets the Statements property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodBlockSyntax.End">
	<summary>
 The End XXX statement that ends the block declaration.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodBlockSyntax.WithEnd(Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new node and sets the [End] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodBlockSyntax.Update(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new MethodBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this MethodBlockSyntaxSyntax node with. If not
 specified the current Begin will be used in the new MethodBlockSyntaxSyntax
 node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this MethodBlockSyntaxSyntax node with. If
 not specified the current BeginTerminator will be used in the new
 MethodBlockSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this MethodBlockSyntaxSyntax node with. If not
 specified the current Statements will be used in the new
 MethodBlockSyntaxSyntax node.
 </param>
	<param name="end">
 The new End to update this MethodBlockSyntaxSyntax node with. If not specified
 the current End will be used in the new MethodBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.MethodBlockSyntax">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertyBlockSyntax.Begin">
	<summary>
 The property declaration that begins the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PropertyBlockSyntax.WithBegin(Roslyn.Compilers.VisualBasic.PropertyStatementSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertyBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PropertyBlockSyntax.WithBeginTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginTerminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertyBlockSyntax.Accessors">
	<summary>
 The accessor blocks contained in the property, between the Property and the End
 Property statements.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PropertyBlockSyntax.WithAccessors(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.MethodBlockSyntax})">
	<summary>
 Creates a new node and sets the Accessors property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertyBlockSyntax.End">
	<summary>
 The End Property statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PropertyBlockSyntax.WithEnd(Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new node and sets the [End] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.PropertyBlockSyntax.Update(Roslyn.Compilers.VisualBasic.PropertyStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.MethodBlockSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new PropertyBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this PropertyBlockSyntaxSyntax node with. If not
 specified the current Begin will be used in the new PropertyBlockSyntaxSyntax
 node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this PropertyBlockSyntaxSyntax node with. If
 not specified the current BeginTerminator will be used in the new
 PropertyBlockSyntaxSyntax node.
 </param>
	<param name="accessors">
 The new Accessors to update this PropertyBlockSyntaxSyntax node with. If not
 specified the current Accessors will be used in the new
 PropertyBlockSyntaxSyntax node.
 </param>
	<param name="end">
 The new End to update this PropertyBlockSyntaxSyntax node with. If not
 specified the current End will be used in the new PropertyBlockSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.PropertyBlockSyntax">
	<summary>
 Represents a block property declaration: A declaration that has a beginning
 declaration, some get or set accessor blocks and an end statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventBlockSyntax.Begin">
	<summary>
 The event declaration that begins the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EventBlockSyntax.WithBegin(Roslyn.Compilers.VisualBasic.EventStatementSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EventBlockSyntax.WithBeginTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginTerminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventBlockSyntax.Accessors">
	<summary>
 The accessor blocks contained in the custom event declaration, between the
 Event statement and the End Event statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EventBlockSyntax.WithAccessors(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.MethodBlockSyntax})">
	<summary>
 Creates a new node and sets the Accessors property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventBlockSyntax.End">
	<summary>
 The End Event statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EventBlockSyntax.WithEnd(Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new node and sets the [End] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EventBlockSyntax.Update(Roslyn.Compilers.VisualBasic.EventStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.MethodBlockSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new EventBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this EventBlockSyntaxSyntax node with. If not specified
 the current Begin will be used in the new EventBlockSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this EventBlockSyntaxSyntax node with. If not
 specified the current BeginTerminator will be used in the new
 EventBlockSyntaxSyntax node.
 </param>
	<param name="accessors">
 The new Accessors to update this EventBlockSyntaxSyntax node with. If not
 specified the current Accessors will be used in the new EventBlockSyntaxSyntax
 node.
 </param>
	<param name="end">
 The new End to update this EventBlockSyntaxSyntax node with. If not specified
 the current End will be used in the new EventBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.EventBlockSyntax">
	<summary>
 Represents a custom event declaration: A declaration that has a beginning event
 declaration, some accessor blocks and an end statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodBaseSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodBaseSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodBaseSyntax.Keyword">
	<summary>
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodBaseSyntax.ParameterList">
	<summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodBaseSyntax.AsClause">
	<summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.MethodBaseSyntax">
	<summary>
 An abstract node class that is the parent for declarations that are
 "method-like"; i.e., that have a parameter list and return type. This includes
 methods, constructors, properties, events, operators, declares, delegates,
 property accessors and custom event accessors.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterListSyntax.OpenParenToken">
	<summary>
 The "(" token that introduces the parameter list. If no parameter list was
 present, Nothing is returned.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ParameterListSyntax.WithOpenParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OpenParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterListSyntax.Parameters">
	<summary>
 The list of parameters. If no parameter list was present, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ParameterListSyntax.WithParameters(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ParameterSyntax})">
	<summary>
 Creates a new node and sets the Parameters property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterListSyntax.CloseParenToken">
	<summary>
 The ")" token that concludes the parameter list. If no parameter list was
 present, Nothing is returned.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ParameterListSyntax.WithCloseParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CloseParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ParameterListSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ParameterSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new ParameterListSyntaxSyntax node with the specified changes.
 </summary>
	<param name="openParenToken">
 The new OpenParenToken to update this ParameterListSyntaxSyntax node with. If
 not specified the current OpenParenToken will be used in the new
 ParameterListSyntaxSyntax node.
 </param>
	<param name="parameters">
 The new Parameters to update this ParameterListSyntaxSyntax node with. If not
 specified the current Parameters will be used in the new
 ParameterListSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this ParameterListSyntaxSyntax node with. If
 not specified the current CloseParenToken will be used in the new
 ParameterListSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ParameterListSyntax">
	<summary>
 Represents the parameter list in a method declaration.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.WithAttributeLists(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Creates a new node and sets the AttributeLists property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.WithModifiers(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the Modifiers property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.Keyword">
	<summary>
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.WithKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Keyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.Identifier">
	<summary>
 The name of the method being declared.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.WithIdentifier(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Identifier property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.TypeParameterList">
	<summary>
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.WithTypeParameterList(Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Creates a new node and sets the TypeParameterList property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.ParameterList">
	<summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.WithParameterList(Roslyn.Compilers.VisualBasic.ParameterListSyntax)">
	<summary>
 Creates a new node and sets the ParameterList property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.AsClause">
	<summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.WithAsClause(Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new node and sets the AsClause property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.HandlesClause">
	<summary>
 If present, a Handles clause indicated the events that this method handles.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.WithHandlesClause(Roslyn.Compilers.VisualBasic.HandlesClauseSyntax)">
	<summary>
 Creates a new node and sets the HandlesClause property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.ImplementsClause">
	<summary>
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.WithImplementsClause(Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax)">
	<summary>
 Creates a new node and sets the ImplementsClause property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.HandlesClauseSyntax,Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax)">
	<summary>
 Creates a new MethodStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributeLists">
 The new AttributeLists to update this MethodStatementSyntaxSyntax node with. If
 not specified the current AttributeLists will be used in the new
 MethodStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this MethodStatementSyntaxSyntax node with. If not
 specified the current Modifiers will be used in the new
 MethodStatementSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this MethodStatementSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 MethodStatementSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this MethodStatementSyntaxSyntax node with. If not
 specified the current Identifier will be used in the new
 MethodStatementSyntaxSyntax node.
 </param>
	<param name="typeParameterList">
 The new TypeParameterList to update this MethodStatementSyntaxSyntax node with.
 If not specified the current TypeParameterList will be used in the new
 MethodStatementSyntaxSyntax node.
 </param>
	<param name="parameterList">
 The new ParameterList to update this MethodStatementSyntaxSyntax node with. If
 not specified the current ParameterList will be used in the new
 MethodStatementSyntaxSyntax node.
 </param>
	<param name="asClause">
 The new AsClause to update this MethodStatementSyntaxSyntax node with. If not
 specified the current AsClause will be used in the new
 MethodStatementSyntaxSyntax node.
 </param>
	<param name="handlesClause">
 The new HandlesClause to update this MethodStatementSyntaxSyntax node with. If
 not specified the current HandlesClause will be used in the new
 MethodStatementSyntaxSyntax node.
 </param>
	<param name="implementsClause">
 The new ImplementsClause to update this MethodStatementSyntaxSyntax node with.
 If not specified the current ImplementsClause will be used in the new
 MethodStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.MethodStatementSyntax">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax.WithAttributeLists(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Creates a new node and sets the AttributeLists property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax.WithModifiers(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the Modifiers property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax.Keyword">
	<summary>
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax.WithKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Keyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax.NewKeyword">
	<summary>
 The "New" keyword in the constructor declaration.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax.WithNewKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the NewKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax.ParameterList">
	<summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax.WithParameterList(Roslyn.Compilers.VisualBasic.ParameterListSyntax)">
	<summary>
 Creates a new node and sets the ParameterList property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax.AsClause">
	<summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax.WithAsClause(Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new node and sets the AsClause property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new ConstructorStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributeLists">
 The new AttributeLists to update this ConstructorStatementSyntaxSyntax node
 with. If not specified the current AttributeLists will be used in the new
 ConstructorStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this ConstructorStatementSyntaxSyntax node with. If
 not specified the current Modifiers will be used in the new
 ConstructorStatementSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this ConstructorStatementSyntaxSyntax node with. If
 not specified the current Keyword will be used in the new
 ConstructorStatementSyntaxSyntax node.
 </param>
	<param name="newKeyword">
 The new NewKeyword to update this ConstructorStatementSyntaxSyntax node with.
 If not specified the current NewKeyword will be used in the new
 ConstructorStatementSyntaxSyntax node.
 </param>
	<param name="parameterList">
 The new ParameterList to update this ConstructorStatementSyntaxSyntax node
 with. If not specified the current ParameterList will be used in the new
 ConstructorStatementSyntaxSyntax node.
 </param>
	<param name="asClause">
 The new AsClause to update this ConstructorStatementSyntaxSyntax node with. If
 not specified the current AsClause will be used in the new
 ConstructorStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax">
	<summary>
 A statement that declares a constructor. This statement will be the Begin of a
 BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
 will be the Body of that BlockStatement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.WithAttributeLists(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Creates a new node and sets the AttributeLists property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.WithModifiers(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the Modifiers property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.DeclareKeyword">
	<summary>
 The "Declare" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.WithDeclareKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the DeclareKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.CharsetKeyword">
	<summary>
 If present, the keyword that defines the string translation semantics of the
 external method.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.WithCharsetKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CharsetKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.Keyword">
	<summary>
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.WithKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Keyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.Identifier">
	<summary>
 The name of the method being declared.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.WithIdentifier(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Identifier property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.LibKeyword">
	<summary>
 The "Lib" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.WithLibKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the LibKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.LibraryName">
	<summary>
 The string literal with the library name.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.WithLibraryName(Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax)">
	<summary>
 Creates a new node and sets the LibraryName property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.AliasKeyword">
	<summary>
 If present, the "Alias" keyword. If not present, returns Nothing.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.WithAliasKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the AliasKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.AliasName">
	<summary>
 The string literal with the alias. If not present, returns Nothing.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.WithAliasName(Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax)">
	<summary>
 Creates a new node and sets the AliasName property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.ParameterList">
	<summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.WithParameterList(Roslyn.Compilers.VisualBasic.ParameterListSyntax)">
	<summary>
 Creates a new node and sets the ParameterList property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.AsClause">
	<summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.WithAsClause(Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new node and sets the AsClause property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new DeclareStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributeLists">
 The new AttributeLists to update this DeclareStatementSyntaxSyntax node with.
 If not specified the current AttributeLists will be used in the new
 DeclareStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this DeclareStatementSyntaxSyntax node with. If not
 specified the current Modifiers will be used in the new
 DeclareStatementSyntaxSyntax node.
 </param>
	<param name="declareKeyword">
 The new DeclareKeyword to update this DeclareStatementSyntaxSyntax node with.
 If not specified the current DeclareKeyword will be used in the new
 DeclareStatementSyntaxSyntax node.
 </param>
	<param name="charsetKeyword">
 The new CharsetKeyword to update this DeclareStatementSyntaxSyntax node with.
 If not specified the current CharsetKeyword will be used in the new
 DeclareStatementSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this DeclareStatementSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 DeclareStatementSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this DeclareStatementSyntaxSyntax node with. If
 not specified the current Identifier will be used in the new
 DeclareStatementSyntaxSyntax node.
 </param>
	<param name="libKeyword">
 The new LibKeyword to update this DeclareStatementSyntaxSyntax node with. If
 not specified the current LibKeyword will be used in the new
 DeclareStatementSyntaxSyntax node.
 </param>
	<param name="libraryName">
 The new LibraryName to update this DeclareStatementSyntaxSyntax node with. If
 not specified the current LibraryName will be used in the new
 DeclareStatementSyntaxSyntax node.
 </param>
	<param name="aliasKeyword">
 The new AliasKeyword to update this DeclareStatementSyntaxSyntax node with. If
 not specified the current AliasKeyword will be used in the new
 DeclareStatementSyntaxSyntax node.
 </param>
	<param name="aliasName">
 The new AliasName to update this DeclareStatementSyntaxSyntax node with. If not
 specified the current AliasName will be used in the new
 DeclareStatementSyntaxSyntax node.
 </param>
	<param name="parameterList">
 The new ParameterList to update this DeclareStatementSyntaxSyntax node with. If
 not specified the current ParameterList will be used in the new
 DeclareStatementSyntaxSyntax node.
 </param>
	<param name="asClause">
 The new AsClause to update this DeclareStatementSyntaxSyntax node with. If not
 specified the current AsClause will be used in the new
 DeclareStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.DeclareStatementSyntax">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.WithAttributeLists(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Creates a new node and sets the AttributeLists property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.WithModifiers(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the Modifiers property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.DelegateKeyword">
	<summary>
 The "Delegate" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.WithDelegateKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the DelegateKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.Keyword">
	<summary>
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.WithKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Keyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.Identifier">
	<summary>
 The name of the delegate being declared.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.WithIdentifier(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Identifier property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.TypeParameterList">
	<summary>
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.WithTypeParameterList(Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Creates a new node and sets the TypeParameterList property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.ParameterList">
	<summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.WithParameterList(Roslyn.Compilers.VisualBasic.ParameterListSyntax)">
	<summary>
 Creates a new node and sets the ParameterList property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.AsClause">
	<summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.WithAsClause(Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new node and sets the AsClause property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new DelegateStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributeLists">
 The new AttributeLists to update this DelegateStatementSyntaxSyntax node with.
 If not specified the current AttributeLists will be used in the new
 DelegateStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this DelegateStatementSyntaxSyntax node with. If
 not specified the current Modifiers will be used in the new
 DelegateStatementSyntaxSyntax node.
 </param>
	<param name="delegateKeyword">
 The new DelegateKeyword to update this DelegateStatementSyntaxSyntax node with.
 If not specified the current DelegateKeyword will be used in the new
 DelegateStatementSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this DelegateStatementSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 DelegateStatementSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this DelegateStatementSyntaxSyntax node with. If
 not specified the current Identifier will be used in the new
 DelegateStatementSyntaxSyntax node.
 </param>
	<param name="typeParameterList">
 The new TypeParameterList to update this DelegateStatementSyntaxSyntax node
 with. If not specified the current TypeParameterList will be used in the new
 DelegateStatementSyntaxSyntax node.
 </param>
	<param name="parameterList">
 The new ParameterList to update this DelegateStatementSyntaxSyntax node with.
 If not specified the current ParameterList will be used in the new
 DelegateStatementSyntaxSyntax node.
 </param>
	<param name="asClause">
 The new AsClause to update this DelegateStatementSyntaxSyntax node with. If not
 specified the current AsClause will be used in the new
 DelegateStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.DelegateStatementSyntax">
	<summary>
 A statement that declares a delegate type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventStatementSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EventStatementSyntax.WithAttributeLists(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Creates a new node and sets the AttributeLists property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EventStatementSyntax.WithModifiers(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the Modifiers property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventStatementSyntax.CustomKeyword">
	<summary>
 The optional Custom keyword for custom event declarations.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EventStatementSyntax.WithCustomKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CustomKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventStatementSyntax.Keyword">
	<summary>
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EventStatementSyntax.WithKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Keyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventStatementSyntax.Identifier">
	<summary>
 The name of the event being declared.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EventStatementSyntax.WithIdentifier(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Identifier property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventStatementSyntax.ParameterList">
	<summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EventStatementSyntax.WithParameterList(Roslyn.Compilers.VisualBasic.ParameterListSyntax)">
	<summary>
 Creates a new node and sets the ParameterList property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventStatementSyntax.AsClause">
	<summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EventStatementSyntax.WithAsClause(Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new node and sets the AsClause property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventStatementSyntax.ImplementsClause">
	<summary>
 If present, an Implements clause indicates the interface methods that this
 method implements.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EventStatementSyntax.WithImplementsClause(Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax)">
	<summary>
 Creates a new node and sets the ImplementsClause property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EventStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax)">
	<summary>
 Creates a new EventStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributeLists">
 The new AttributeLists to update this EventStatementSyntaxSyntax node with. If
 not specified the current AttributeLists will be used in the new
 EventStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this EventStatementSyntaxSyntax node with. If not
 specified the current Modifiers will be used in the new
 EventStatementSyntaxSyntax node.
 </param>
	<param name="customKeyword">
 The new CustomKeyword to update this EventStatementSyntaxSyntax node with. If
 not specified the current CustomKeyword will be used in the new
 EventStatementSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this EventStatementSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 EventStatementSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this EventStatementSyntaxSyntax node with. If not
 specified the current Identifier will be used in the new
 EventStatementSyntaxSyntax node.
 </param>
	<param name="parameterList">
 The new ParameterList to update this EventStatementSyntaxSyntax node with. If
 not specified the current ParameterList will be used in the new
 EventStatementSyntaxSyntax node.
 </param>
	<param name="asClause">
 The new AsClause to update this EventStatementSyntaxSyntax node with. If not
 specified the current AsClause will be used in the new
 EventStatementSyntaxSyntax node.
 </param>
	<param name="implementsClause">
 The new ImplementsClause to update this EventStatementSyntaxSyntax node with.
 If not specified the current ImplementsClause will be used in the new
 EventStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.EventStatementSyntax">
	<summary>
 A statement that declares an event. If the event being declared is a custom
 event, this statement will be the Begin of a PropertyOrEventBlock, and the
 accessors will be part of the Accessors of that node.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OperatorStatementSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OperatorStatementSyntax.WithAttributeLists(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Creates a new node and sets the AttributeLists property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.OperatorStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OperatorStatementSyntax.WithModifiers(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the Modifiers property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.OperatorStatementSyntax.Keyword">
	<summary>
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OperatorStatementSyntax.WithKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Keyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.OperatorStatementSyntax.Operator">
	<summary>
 The operator being defined.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OperatorStatementSyntax.WithOperator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the [Operator] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.OperatorStatementSyntax.ParameterList">
	<summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OperatorStatementSyntax.WithParameterList(Roslyn.Compilers.VisualBasic.ParameterListSyntax)">
	<summary>
 Creates a new node and sets the ParameterList property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.OperatorStatementSyntax.AsClause">
	<summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OperatorStatementSyntax.WithAsClause(Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new node and sets the AsClause property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OperatorStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new OperatorStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributeLists">
 The new AttributeLists to update this OperatorStatementSyntaxSyntax node with.
 If not specified the current AttributeLists will be used in the new
 OperatorStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this OperatorStatementSyntaxSyntax node with. If
 not specified the current Modifiers will be used in the new
 OperatorStatementSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this OperatorStatementSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 OperatorStatementSyntaxSyntax node.
 </param>
	<param name="operator">
 The new Operator to update this OperatorStatementSyntaxSyntax node with. If not
 specified the current Operator will be used in the new
 OperatorStatementSyntaxSyntax node.
 </param>
	<param name="parameterList">
 The new ParameterList to update this OperatorStatementSyntaxSyntax node with.
 If not specified the current ParameterList will be used in the new
 OperatorStatementSyntaxSyntax node.
 </param>
	<param name="asClause">
 The new AsClause to update this OperatorStatementSyntaxSyntax node with. If not
 specified the current AsClause will be used in the new
 OperatorStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.OperatorStatementSyntax">
	<summary>
 A statement that declares an operator. If this operator has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.WithAttributeLists(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Creates a new node and sets the AttributeLists property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.WithModifiers(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the Modifiers property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.Keyword">
	<summary>
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.WithKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Keyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.Identifier">
	<summary>
 The name of the property being declared.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.WithIdentifier(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Identifier property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.ParameterList">
	<summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.WithParameterList(Roslyn.Compilers.VisualBasic.ParameterListSyntax)">
	<summary>
 Creates a new node and sets the ParameterList property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.AsClause">
	<summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.WithAsClause(Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new node and sets the AsClause property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.Initializer">
	<summary>
 If present, an "= initial-value" clause describing the initial value of the
 property.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.WithInitializer(Roslyn.Compilers.VisualBasic.EqualsValueSyntax)">
	<summary>
 Creates a new node and sets the Initializer property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.ImplementsClause">
	<summary>
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.WithImplementsClause(Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax)">
	<summary>
 Creates a new node and sets the ImplementsClause property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.EqualsValueSyntax,Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax)">
	<summary>
 Creates a new PropertyStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributeLists">
 The new AttributeLists to update this PropertyStatementSyntaxSyntax node with.
 If not specified the current AttributeLists will be used in the new
 PropertyStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this PropertyStatementSyntaxSyntax node with. If
 not specified the current Modifiers will be used in the new
 PropertyStatementSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this PropertyStatementSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 PropertyStatementSyntaxSyntax node.
 </param>
	<param name="identifier">
 The new Identifier to update this PropertyStatementSyntaxSyntax node with. If
 not specified the current Identifier will be used in the new
 PropertyStatementSyntaxSyntax node.
 </param>
	<param name="parameterList">
 The new ParameterList to update this PropertyStatementSyntaxSyntax node with.
 If not specified the current ParameterList will be used in the new
 PropertyStatementSyntaxSyntax node.
 </param>
	<param name="asClause">
 The new AsClause to update this PropertyStatementSyntaxSyntax node with. If not
 specified the current AsClause will be used in the new
 PropertyStatementSyntaxSyntax node.
 </param>
	<param name="initializer">
 The new Initializer to update this PropertyStatementSyntaxSyntax node with. If
 not specified the current Initializer will be used in the new
 PropertyStatementSyntaxSyntax node.
 </param>
	<param name="implementsClause">
 The new ImplementsClause to update this PropertyStatementSyntaxSyntax node
 with. If not specified the current ImplementsClause will be used in the new
 PropertyStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.PropertyStatementSyntax">
	<summary>
 Statement that declares a property. If this property has accessors declared,
 this statement will be the Begin of a BlockNode, and the accessors will be the
 Body of that node. Auto properties are property declarations without a
 PropertyBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AccessorStatementSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessorStatementSyntax.WithAttributeLists(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Creates a new node and sets the AttributeLists property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AccessorStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessorStatementSyntax.WithModifiers(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the Modifiers property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AccessorStatementSyntax.Keyword">
	<summary>
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessorStatementSyntax.WithKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Keyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AccessorStatementSyntax.ParameterList">
	<summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessorStatementSyntax.WithParameterList(Roslyn.Compilers.VisualBasic.ParameterListSyntax)">
	<summary>
 Creates a new node and sets the ParameterList property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AccessorStatementSyntax.AsClause">
	<summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessorStatementSyntax.WithAsClause(Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new node and sets the AsClause property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessorStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new AccessorStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributeLists">
 The new AttributeLists to update this AccessorStatementSyntaxSyntax node with.
 If not specified the current AttributeLists will be used in the new
 AccessorStatementSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this AccessorStatementSyntaxSyntax node with. If
 not specified the current Modifiers will be used in the new
 AccessorStatementSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this AccessorStatementSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 AccessorStatementSyntaxSyntax node.
 </param>
	<param name="parameterList">
 The new ParameterList to update this AccessorStatementSyntaxSyntax node with.
 If not specified the current ParameterList will be used in the new
 AccessorStatementSyntaxSyntax node.
 </param>
	<param name="asClause">
 The new AsClause to update this AccessorStatementSyntaxSyntax node with. If not
 specified the current AsClause will be used in the new
 AccessorStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AccessorStatementSyntax">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax.ImplementsKeyword">
	<summary>
 The "Implements" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax.WithImplementsKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ImplementsKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax.InterfaceMembers">
	<summary>
 The list of interface members being implemented.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax.WithInterfaceMembers(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.QualifiedNameSyntax})">
	<summary>
 Creates a new node and sets the InterfaceMembers property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.QualifiedNameSyntax})">
	<summary>
 Creates a new ImplementsClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="implementsKeyword">
 The new ImplementsKeyword to update this ImplementsClauseSyntaxSyntax node
 with. If not specified the current ImplementsKeyword will be used in the new
 ImplementsClauseSyntaxSyntax node.
 </param>
	<param name="interfaceMembers">
 The new InterfaceMembers to update this ImplementsClauseSyntaxSyntax node with.
 If not specified the current InterfaceMembers will be used in the new
 ImplementsClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax">
	<summary>
 Represents the "Implements ..." clause on a type member, which describes which
 interface members this member implements.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.HandlesClauseSyntax.HandlesKeyword">
	<summary>
 The "Handles" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.HandlesClauseSyntax.WithHandlesKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the HandlesKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.HandlesClauseSyntax.Events">
	<summary>
 The list of event members being handled.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.HandlesClauseSyntax.WithEvents(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.HandlesClauseItemSyntax})">
	<summary>
 Creates a new node and sets the Events property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.HandlesClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.HandlesClauseItemSyntax})">
	<summary>
 Creates a new HandlesClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="handlesKeyword">
 The new HandlesKeyword to update this HandlesClauseSyntaxSyntax node with. If
 not specified the current HandlesKeyword will be used in the new
 HandlesClauseSyntaxSyntax node.
 </param>
	<param name="events">
 The new Events to update this HandlesClauseSyntaxSyntax node with. If not
 specified the current Events will be used in the new HandlesClauseSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.HandlesClauseSyntax">
	<summary>
 Represents the "Handles ..." clause on a method declaration that describes
 which events this method handles.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.EventContainerSyntax">
	<summary>
 Represents container of an event in a Handles clause item.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.KeywordEventContainerSyntax.Keyword">
	<summary>
 The container of the event. This can be one of the special keywords: "Me",
 "MyBase" or "MyClass".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.KeywordEventContainerSyntax.WithKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Keyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.KeywordEventContainerSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new KeywordEventContainerSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="keyword">
 The new Keyword to update this KeywordEventContainerSyntaxSyntax node with. If
 not specified the current Keyword will be used in the new
 KeywordEventContainerSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.KeywordEventContainerSyntax">
	<summary>
 Represents event container specified through special keywords "Me", "MyBase" or
 "MyClass"..
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.IdentifierEventContainerSyntax.Identifier">
	<summary>
 The container of the event. It is a simple identifier that refers to a
 WithEvents member of the containing type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.IdentifierEventContainerSyntax.WithIdentifier(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Identifier property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.IdentifierEventContainerSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new IdentifierEventContainerSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="identifier">
 The new Identifier to update this IdentifierEventContainerSyntaxSyntax node
 with. If not specified the current Identifier will be used in the new
 IdentifierEventContainerSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.IdentifierEventContainerSyntax">
	<summary>
 Represents event container that refers to a WithEvents member.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.HandlesClauseItemSyntax.EventContainer">
	<summary>
 The container of the event. This can either be a simple identifier (identifying
 a members of the containing type) or one of the special keywords "Me", "MyBase"
 or "MyClass".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.HandlesClauseItemSyntax.WithEventContainer(Roslyn.Compilers.VisualBasic.EventContainerSyntax)">
	<summary>
 Creates a new node and sets the EventContainer property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.HandlesClauseItemSyntax.DotToken">
	<summary>
 The "." token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.HandlesClauseItemSyntax.WithDotToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the DotToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.HandlesClauseItemSyntax.EventMember">
	<summary>
 The event being handled. This must be a simple identifier.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.HandlesClauseItemSyntax.WithEventMember(Roslyn.Compilers.VisualBasic.IdentifierNameSyntax)">
	<summary>
 Creates a new node and sets the EventMember property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.HandlesClauseItemSyntax.Update(Roslyn.Compilers.VisualBasic.EventContainerSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.IdentifierNameSyntax)">
	<summary>
 Creates a new HandlesClauseItemSyntaxSyntax node with the specified changes.
 </summary>
	<param name="eventContainer">
 The new EventContainer to update this HandlesClauseItemSyntaxSyntax node with.
 If not specified the current EventContainer will be used in the new
 HandlesClauseItemSyntaxSyntax node.
 </param>
	<param name="dotToken">
 The new DotToken to update this HandlesClauseItemSyntaxSyntax node with. If not
 specified the current DotToken will be used in the new
 HandlesClauseItemSyntaxSyntax node.
 </param>
	<param name="eventMember">
 The new EventMember to update this HandlesClauseItemSyntaxSyntax node with. If
 not specified the current EventMember will be used in the new
 HandlesClauseItemSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.HandlesClauseItemSyntax">
	<summary>
 Represents a single handled event in a "Handles ..." clause.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.IncompleteMemberSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.IncompleteMemberSyntax.WithAttributeLists(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Creates a new node and sets the AttributeLists property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.IncompleteMemberSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.IncompleteMemberSyntax.WithModifiers(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the Modifiers property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.IncompleteMemberSyntax.MissingIdentifier">
	<summary>
 The missing identifier token for this incomplete member. Should only be used to
 have a location for error reporting.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.IncompleteMemberSyntax.WithMissingIdentifier(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the MissingIdentifier property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.IncompleteMemberSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new IncompleteMemberSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributeLists">
 The new AttributeLists to update this IncompleteMemberSyntaxSyntax node with.
 If not specified the current AttributeLists will be used in the new
 IncompleteMemberSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this IncompleteMemberSyntaxSyntax node with. If not
 specified the current Modifiers will be used in the new
 IncompleteMemberSyntaxSyntax node.
 </param>
	<param name="missingIdentifier">
 The new MissingIdentifier to update this IncompleteMemberSyntaxSyntax node
 with. If not specified the current MissingIdentifier will be used in the new
 IncompleteMemberSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.IncompleteMemberSyntax">
	<summary>
 Represents the beginning of a declaration. However, not enough syntax is
 detected to classify this as a field, method, property or event. This is node
 always represents a syntax error.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldDeclarationSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.FieldDeclarationSyntax.WithAttributeLists(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Creates a new node and sets the AttributeLists property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldDeclarationSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.FieldDeclarationSyntax.WithModifiers(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the Modifiers property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldDeclarationSyntax.Declarators">
	<summary>
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.FieldDeclarationSyntax.WithDeclarators(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax})">
	<summary>
 Creates a new node and sets the Declarators property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.FieldDeclarationSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax})">
	<summary>
 Creates a new FieldDeclarationSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributeLists">
 The new AttributeLists to update this FieldDeclarationSyntaxSyntax node with.
 If not specified the current AttributeLists will be used in the new
 FieldDeclarationSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this FieldDeclarationSyntaxSyntax node with. If not
 specified the current Modifiers will be used in the new
 FieldDeclarationSyntaxSyntax node.
 </param>
	<param name="declarators">
 The new Declarators to update this FieldDeclarationSyntaxSyntax node with. If
 not specified the current Declarators will be used in the new
 FieldDeclarationSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.FieldDeclarationSyntax">
	<summary>
 Represents the declaration of one or more variables or constants, either as
 local variables or as class/structure members. In the case of a constant, it is
 represented by having "Const" in the Modifiers (although technically "Const" is
 not a modifier, it is represented as one in the parse trees.)
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax.Names">
	<summary>
 The names of the variables being declared. Each name might have a "?" or "()"
 modifier(s) attached.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax.WithNames(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax})">
	<summary>
 Creates a new node and sets the Names property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax.AsClause">
	<summary>
 The "As" clause that describes the return type, and possibly includes "New",
 "With" or "From". If no As clause was present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax.WithAsClause(Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new node and sets the AsClause property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax.Initializer">
	<summary>
 If present, an "= initial-value" clause describing the initial value of the
 variable or the value of the constant.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax.WithInitializer(Roslyn.Compilers.VisualBasic.EqualsValueSyntax)">
	<summary>
 Creates a new node and sets the Initializer property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax.Update(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax},Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.EqualsValueSyntax)">
	<summary>
 Creates a new VariableDeclaratorSyntaxSyntax node with the specified changes.
 </summary>
	<param name="names">
 The new Names to update this VariableDeclaratorSyntaxSyntax node with. If not
 specified the current Names will be used in the new
 VariableDeclaratorSyntaxSyntax node.
 </param>
	<param name="asClause">
 The new AsClause to update this VariableDeclaratorSyntaxSyntax node with. If
 not specified the current AsClause will be used in the new
 VariableDeclaratorSyntaxSyntax node.
 </param>
	<param name="initializer">
 The new Initializer to update this VariableDeclaratorSyntaxSyntax node with. If
 not specified the current Initializer will be used in the new
 VariableDeclaratorSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax">
	<summary>
 Represents the part of a variable or constant declaration statement that
 associated one or more variable names with a type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AsClauseSyntax.AsKeyword">
	<summary>
 The "As" keyword.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AsClauseSyntax">
	<summary>
 Abstract node class that represents the different kinds of "As {type-name}"
 clauses in a declaration: simple "As" clauses and "As New" clauses. The type
 has optional attributes associated with it, although attributes are not
 permitted in all possible places where this node occurs.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax.AsKeyword">
	<summary>
 The "As" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax.WithAsKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the AsKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax.WithAttributeLists(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Creates a new node and sets the AttributeLists property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax.Type">
	<summary>
 The type-name part of the As clause.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax.WithType(Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Creates a new node and sets the Type property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Creates a new SimpleAsClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="asKeyword">
 The new AsKeyword to update this SimpleAsClauseSyntaxSyntax node with. If not
 specified the current AsKeyword will be used in the new
 SimpleAsClauseSyntaxSyntax node.
 </param>
	<param name="attributeLists">
 The new AttributeLists to update this SimpleAsClauseSyntaxSyntax node with. If
 not specified the current AttributeLists will be used in the new
 SimpleAsClauseSyntaxSyntax node.
 </param>
	<param name="type">
 The new Type to update this SimpleAsClauseSyntaxSyntax node with. If not
 specified the current Type will be used in the new SimpleAsClauseSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax">
	<summary>
 Represents an "As {type-name}" clause that does not have an initializer or
 "New". The type has optional attributes associated with it, although attributes
 are not permitted in all possible places where this node occurs.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AsNewClauseSyntax.AsKeyword">
	<summary>
 The "As" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AsNewClauseSyntax.WithAsKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the AsKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AsNewClauseSyntax.NewExpression">
	<summary>
 The New expression
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AsNewClauseSyntax.WithNewExpression(Roslyn.Compilers.VisualBasic.NewExpressionSyntax)">
	<summary>
 Creates a new node and sets the NewExpression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AsNewClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.NewExpressionSyntax)">
	<summary>
 Creates a new AsNewClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="asKeyword">
 The new AsKeyword to update this AsNewClauseSyntaxSyntax node with. If not
 specified the current AsKeyword will be used in the new AsNewClauseSyntaxSyntax
 node.
 </param>
	<param name="newExpression">
 The new NewExpression to update this AsNewClauseSyntaxSyntax node with. If not
 specified the current NewExpression will be used in the new
 AsNewClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AsNewClauseSyntax">
	<summary>
 Represents an "As New {type-name} [arguments] [initializers]" clause in a
 declaration. The type has optional attributes associated with it, although
 attributes are not permitted in many places where this node occurs (they are
 permitted, for example, on automatically implemented properties.)
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ObjectCreationInitializerSyntax">
	<summary>
 An abstract node class that represents a "With" or "From" clause used to
 initializer an new object.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ObjectMemberInitializerSyntax.WithKeyword">
	<summary>
 The "With" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ObjectMemberInitializerSyntax.WithWithKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the WithKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ObjectMemberInitializerSyntax.OpenBraceToken">
	<summary>
 The "{" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ObjectMemberInitializerSyntax.WithOpenBraceToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OpenBraceToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ObjectMemberInitializerSyntax.Initializers">
	<summary>
 The comma-separated list of field initializers.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ObjectMemberInitializerSyntax.WithInitializers(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.FieldInitializerSyntax})">
	<summary>
 Creates a new node and sets the Initializers property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ObjectMemberInitializerSyntax.CloseBraceToken">
	<summary>
 The "}" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ObjectMemberInitializerSyntax.WithCloseBraceToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CloseBraceToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ObjectMemberInitializerSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.FieldInitializerSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new ObjectMemberInitializerSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="withKeyword">
 The new WithKeyword to update this ObjectMemberInitializerSyntaxSyntax node
 with. If not specified the current WithKeyword will be used in the new
 ObjectMemberInitializerSyntaxSyntax node.
 </param>
	<param name="openBraceToken">
 The new OpenBraceToken to update this ObjectMemberInitializerSyntaxSyntax node
 with. If not specified the current OpenBraceToken will be used in the new
 ObjectMemberInitializerSyntaxSyntax node.
 </param>
	<param name="initializers">
 The new Initializers to update this ObjectMemberInitializerSyntaxSyntax node
 with. If not specified the current Initializers will be used in the new
 ObjectMemberInitializerSyntaxSyntax node.
 </param>
	<param name="closeBraceToken">
 The new CloseBraceToken to update this ObjectMemberInitializerSyntaxSyntax node
 with. If not specified the current CloseBraceToken will be used in the new
 ObjectMemberInitializerSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ObjectMemberInitializerSyntax">
	<summary>
 Represents a "With {...} clause used to initialize a new object's members.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ObjectCollectionInitializerSyntax.FromKeyword">
	<summary>
 The "From" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ObjectCollectionInitializerSyntax.WithFromKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the FromKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ObjectCollectionInitializerSyntax.Initializer">
	<summary>
 The initializer including the braces.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ObjectCollectionInitializerSyntax.WithInitializer(Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax)">
	<summary>
 Creates a new node and sets the Initializer property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ObjectCollectionInitializerSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax)">
	<summary>
 Creates a new ObjectCollectionInitializerSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="fromKeyword">
 The new FromKeyword to update this ObjectCollectionInitializerSyntaxSyntax node
 with. If not specified the current FromKeyword will be used in the new
 ObjectCollectionInitializerSyntaxSyntax node.
 </param>
	<param name="initializer">
 The new Initializer to update this ObjectCollectionInitializerSyntaxSyntax node
 with. If not specified the current Initializer will be used in the new
 ObjectCollectionInitializerSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ObjectCollectionInitializerSyntax">
	<summary>
 Represents a "From {...} clause used to initialize a new collection object's
 elements.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldInitializerSyntax.KeyKeyword">
	<summary>
 The optional "Key" keyword.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.FieldInitializerSyntax">
	<summary>
 Abstract class that represent a single field initializer used in a "With {...}"
 field initializer list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InferredFieldInitializerSyntax.KeyKeyword">
	<summary>
 The optional "Key" keyword.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InferredFieldInitializerSyntax.WithKeyKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the KeyKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InferredFieldInitializerSyntax.Expression">
	<summary>
 The value being assigned.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InferredFieldInitializerSyntax.WithExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Expression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InferredFieldInitializerSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new InferredFieldInitializerSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="keyKeyword">
 The new KeyKeyword to update this InferredFieldInitializerSyntaxSyntax node
 with. If not specified the current KeyKeyword will be used in the new
 InferredFieldInitializerSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this InferredFieldInitializerSyntaxSyntax node
 with. If not specified the current Expression will be used in the new
 InferredFieldInitializerSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.InferredFieldInitializerSyntax">
	<summary>
 Represent a field initializer in a With {...} initializer where the field name
 is inferred from the initializer expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedFieldInitializerSyntax.KeyKeyword">
	<summary>
 The optional "Key" keyword.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedFieldInitializerSyntax.WithKeyKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the KeyKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedFieldInitializerSyntax.DotToken">
	<summary>
 The "." token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedFieldInitializerSyntax.WithDotToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the DotToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedFieldInitializerSyntax.Name">
	<summary>
 The name of the field being initialized.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedFieldInitializerSyntax.WithName(Roslyn.Compilers.VisualBasic.IdentifierNameSyntax)">
	<summary>
 Creates a new node and sets the Name property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedFieldInitializerSyntax.EqualsToken">
	<summary>
 The "=" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedFieldInitializerSyntax.WithEqualsToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the EqualsToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedFieldInitializerSyntax.Expression">
	<summary>
 The value being assigned to the field.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedFieldInitializerSyntax.WithExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Expression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedFieldInitializerSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.IdentifierNameSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new NamedFieldInitializerSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="keyKeyword">
 The new KeyKeyword to update this NamedFieldInitializerSyntaxSyntax node with.
 If not specified the current KeyKeyword will be used in the new
 NamedFieldInitializerSyntaxSyntax node.
 </param>
	<param name="dotToken">
 The new DotToken to update this NamedFieldInitializerSyntaxSyntax node with. If
 not specified the current DotToken will be used in the new
 NamedFieldInitializerSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this NamedFieldInitializerSyntaxSyntax node with. If not
 specified the current Name will be used in the new
 NamedFieldInitializerSyntaxSyntax node.
 </param>
	<param name="equalsToken">
 The new EqualsToken to update this NamedFieldInitializerSyntaxSyntax node with.
 If not specified the current EqualsToken will be used in the new
 NamedFieldInitializerSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this NamedFieldInitializerSyntaxSyntax node with.
 If not specified the current Expression will be used in the new
 NamedFieldInitializerSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.NamedFieldInitializerSyntax">
	<summary>
 Represent a named field initializer in a With {...} initializer, such as ".x =
 expr".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EqualsValueSyntax.EqualsToken">
	<summary>
 The "=" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EqualsValueSyntax.WithEqualsToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the EqualsToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EqualsValueSyntax.Value">
	<summary>
 The expression used as the initial value.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EqualsValueSyntax.WithValue(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Value property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EqualsValueSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new EqualsValueSyntaxSyntax node with the specified changes.
 </summary>
	<param name="equalsToken">
 The new EqualsToken to update this EqualsValueSyntaxSyntax node with. If not
 specified the current EqualsToken will be used in the new
 EqualsValueSyntaxSyntax node.
 </param>
	<param name="value">
 The new Value to update this EqualsValueSyntaxSyntax node with. If not
 specified the current Value will be used in the new EqualsValueSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.EqualsValueSyntax">
	<summary>
 Represents an "= initializer" clause in a declaration for a variable,
 pararameter or automatic property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this parameter. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ParameterSyntax.WithAttributeLists(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Creates a new node and sets the AttributeLists property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSyntax.Modifiers">
	<summary>
 A list of the modifier tokens "ByVal", "ByRef", "Optional" or "ParamArray" that
 modify this parameter.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ParameterSyntax.WithModifiers(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the Modifiers property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSyntax.Identifier">
	<summary>
 The name of the parameter, including any "?" or "()" modifiers.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ParameterSyntax.WithIdentifier(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax)">
	<summary>
 Creates a new node and sets the Identifier property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSyntax.AsClause">
	<summary>
 If present, the "As type-name" clause describing the type of the parameter. If
 no As clause is present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ParameterSyntax.WithAsClause(Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax)">
	<summary>
 Creates a new node and sets the AsClause property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSyntax.Default">
	<summary>
 If present, an initializer with the default value of the parameter. If no
 default value is present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ParameterSyntax.WithDefault(Roslyn.Compilers.VisualBasic.EqualsValueSyntax)">
	<summary>
 Creates a new node and sets the [Default] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ParameterSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.EqualsValueSyntax)">
	<summary>
 Creates a new ParameterSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributeLists">
 The new AttributeLists to update this ParameterSyntaxSyntax node with. If not
 specified the current AttributeLists will be used in the new
 ParameterSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this ParameterSyntaxSyntax node with. If not
 specified the current Modifiers will be used in the new ParameterSyntaxSyntax
 node.
 </param>
	<param name="identifier">
 The new Identifier to update this ParameterSyntaxSyntax node with. If not
 specified the current Identifier will be used in the new ParameterSyntaxSyntax
 node.
 </param>
	<param name="asClause">
 The new AsClause to update this ParameterSyntaxSyntax node with. If not
 specified the current AsClause will be used in the new ParameterSyntaxSyntax
 node.
 </param>
	<param name="default">
 The new Default to update this ParameterSyntaxSyntax node with. If not
 specified the current Default will be used in the new ParameterSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ParameterSyntax">
	<summary>
 Represent a parameter to a method, property, constructor, etc.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax.Identifier">
	<summary>
 The identifier that names the item being declared.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax.WithIdentifier(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Identifier property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax.Nullable">
	<summary>
 The "?" token that indicates a nullable type.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax.WithNullable(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Nullable property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax.ArrayBounds">
	<summary>
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax.WithArrayBounds(Roslyn.Compilers.VisualBasic.ArgumentListSyntax)">
	<summary>
 Creates a new node and sets the ArrayBounds property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax.ArrayRankSpecifiers">
	<summary>
 A list of array modifiers for the type. If no array modifiers were present, an
 empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax.WithArrayRankSpecifiers(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax})">
	<summary>
 Creates a new node and sets the ArrayRankSpecifiers property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ArgumentListSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax})">
	<summary>
 Creates a new ModifiedIdentifierSyntaxSyntax node with the specified changes.
 </summary>
	<param name="identifier">
 The new Identifier to update this ModifiedIdentifierSyntaxSyntax node with. If
 not specified the current Identifier will be used in the new
 ModifiedIdentifierSyntaxSyntax node.
 </param>
	<param name="nullable">
 The new Nullable to update this ModifiedIdentifierSyntaxSyntax node with. If
 not specified the current Nullable will be used in the new
 ModifiedIdentifierSyntaxSyntax node.
 </param>
	<param name="arrayBounds">
 The new ArrayBounds to update this ModifiedIdentifierSyntaxSyntax node with. If
 not specified the current ArrayBounds will be used in the new
 ModifiedIdentifierSyntaxSyntax node.
 </param>
	<param name="arrayRankSpecifiers">
 The new ArrayRankSpecifiers to update this ModifiedIdentifierSyntaxSyntax node
 with. If not specified the current ArrayRankSpecifiers will be used in the new
 ModifiedIdentifierSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax">
	<summary>
 Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
 used in parameter declarations and variable declarations.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax.WithOpenParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OpenParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax.CommaTokens">
	<summary>
 The comma tokens in the array type. There is one less comma than the rank.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax.WithCommaTokens(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the CommaTokens property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax.WithCloseParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CloseParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new ArrayRankSpecifierSyntaxSyntax node with the specified changes.
 </summary>
	<param name="openParenToken">
 The new OpenParenToken to update this ArrayRankSpecifierSyntaxSyntax node with.
 If not specified the current OpenParenToken will be used in the new
 ArrayRankSpecifierSyntaxSyntax node.
 </param>
	<param name="commaTokens">
 The new CommaTokens to update this ArrayRankSpecifierSyntaxSyntax node with. If
 not specified the current CommaTokens will be used in the new
 ArrayRankSpecifierSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this ArrayRankSpecifierSyntaxSyntax node
 with. If not specified the current CloseParenToken will be used in the new
 ArrayRankSpecifierSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax">
	<summary>
 Represents a modifier that describes an array type, without bounds, such as
 "()" or "(,)".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeListSyntax.LessThanToken">
	<summary>
 The "&lt;" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributeListSyntax.WithLessThanToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the LessThanToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeListSyntax.Attributes">
	<summary>
 A comma separated list of attribute declarations in this attribute list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributeListSyntax.WithAttributes(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AttributeSyntax})">
	<summary>
 Creates a new node and sets the Attributes property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeListSyntax.GreaterThanToken">
	<summary>
 The "&gt;" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributeListSyntax.WithGreaterThanToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the GreaterThanToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributeListSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AttributeSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new AttributeListSyntaxSyntax node with the specified changes.
 </summary>
	<param name="lessThanToken">
 The new LessThanToken to update this AttributeListSyntaxSyntax node with. If
 not specified the current LessThanToken will be used in the new
 AttributeListSyntaxSyntax node.
 </param>
	<param name="attributes">
 The new Attributes to update this AttributeListSyntaxSyntax node with. If not
 specified the current Attributes will be used in the new
 AttributeListSyntaxSyntax node.
 </param>
	<param name="greaterThanToken">
 The new GreaterThanToken to update this AttributeListSyntaxSyntax node with. If
 not specified the current GreaterThanToken will be used in the new
 AttributeListSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AttributeListSyntax">
	<summary>
 Represents a group of attributes within "&lt;" and "&gt;" brackets.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeSyntax.Target">
	<summary>
 Optional attribute target. Assembly|Module :
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributeSyntax.WithTarget(Roslyn.Compilers.VisualBasic.AttributeTargetSyntax)">
	<summary>
 Creates a new node and sets the Target property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeSyntax.Name">
	<summary>
 The name of the attribute.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributeSyntax.WithName(Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Creates a new node and sets the Name property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeSyntax.ArgumentList">
	<summary>
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributeSyntax.WithArgumentList(Roslyn.Compilers.VisualBasic.ArgumentListSyntax)">
	<summary>
 Creates a new node and sets the ArgumentList property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributeSyntax.Update(Roslyn.Compilers.VisualBasic.AttributeTargetSyntax,Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.ArgumentListSyntax)">
	<summary>
 Creates a new AttributeSyntaxSyntax node with the specified changes.
 </summary>
	<param name="target">
 The new Target to update this AttributeSyntaxSyntax node with. If not specified
 the current Target will be used in the new AttributeSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this AttributeSyntaxSyntax node with. If not specified
 the current Name will be used in the new AttributeSyntaxSyntax node.
 </param>
	<param name="argumentList">
 The new ArgumentList to update this AttributeSyntaxSyntax node with. If not
 specified the current ArgumentList will be used in the new
 AttributeSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AttributeSyntax">
	<summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeTargetSyntax.AttributeModifier">
	<summary>
 The "Assembly" or "Module" attribute modifier, is present. If no attribute
 modifier is present, Nothing is returned.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributeTargetSyntax.WithAttributeModifier(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the AttributeModifier property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeTargetSyntax.ColonToken">
	<summary>
 The ":" token, if an attribute modifier is present. If no attribute modifier is
 present, Nothing is returned.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributeTargetSyntax.WithColonToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ColonToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributeTargetSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new AttributeTargetSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributeModifier">
 The new AttributeModifier to update this AttributeTargetSyntaxSyntax node with.
 If not specified the current AttributeModifier will be used in the new
 AttributeTargetSyntaxSyntax node.
 </param>
	<param name="colonToken">
 The new ColonToken to update this AttributeTargetSyntaxSyntax node with. If not
 specified the current ColonToken will be used in the new
 AttributeTargetSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AttributeTargetSyntax">
	<summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributesStatementSyntax.AttributeLists">
	<summary>
 The list of attribute lists.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributesStatementSyntax.WithAttributeLists(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Creates a new node and sets the AttributeLists property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributesStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Creates a new AttributesStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributeLists">
 The new AttributeLists to update this AttributesStatementSyntaxSyntax node
 with. If not specified the current AttributeLists will be used in the new
 AttributesStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AttributesStatementSyntax">
	<summary>
 Represents a file-level attribute, in which the attributes have no other
 syntactic element they are attached to.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ExpressionStatementSyntax.QuestionToken">
	<summary>
 "?" token, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExpressionStatementSyntax.WithQuestionToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the QuestionToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ExpressionStatementSyntax.Expression">
	<summary>
 The expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExpressionStatementSyntax.WithExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Expression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExpressionStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new ExpressionStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="questionToken">
 The new QuestionToken to update this ExpressionStatementSyntaxSyntax node with.
 If not specified the current QuestionToken will be used in the new
 ExpressionStatementSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this ExpressionStatementSyntaxSyntax node with. If
 not specified the current Expression will be used in the new
 ExpressionStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ExpressionStatementSyntax">
	<summary>
 Represent an expression in a statement context.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WhileBlockSyntax.Begin">
	<summary>
 The While statement that begins the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.WhileBlockSyntax.WithBegin(Roslyn.Compilers.VisualBasic.WhileStatementSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.WhileBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.WhileBlockSyntax.WithBeginTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginTerminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.WhileBlockSyntax.Statements">
	<summary>
 The statements contained in the While...End While. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.WhileBlockSyntax.WithStatements(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new node and sets the Statements property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.WhileBlockSyntax.End">
	<summary>
 The End While statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.WhileBlockSyntax.WithEnd(Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new node and sets the [End] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.WhileBlockSyntax.Update(Roslyn.Compilers.VisualBasic.WhileStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new WhileBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this WhileBlockSyntaxSyntax node with. If not specified
 the current Begin will be used in the new WhileBlockSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this WhileBlockSyntaxSyntax node with. If not
 specified the current BeginTerminator will be used in the new
 WhileBlockSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this WhileBlockSyntaxSyntax node with. If not
 specified the current Statements will be used in the new WhileBlockSyntaxSyntax
 node.
 </param>
	<param name="end">
 The new End to update this WhileBlockSyntaxSyntax node with. If not specified
 the current End will be used in the new WhileBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.WhileBlockSyntax">
	<summary>
 Represents a While...End While statement, including the While, body and End
 While.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.UsingBlockSyntax.Begin">
	<summary>
 The UsingStatement that begins the Using...End Using block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.UsingBlockSyntax.WithBegin(Roslyn.Compilers.VisualBasic.UsingStatementSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.UsingBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.UsingBlockSyntax.WithBeginTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginTerminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.UsingBlockSyntax.Statements">
	<summary>
 The statements contained in the Using...End Using block. This might be an empty
 list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.UsingBlockSyntax.WithStatements(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new node and sets the Statements property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.UsingBlockSyntax.End">
	<summary>
 The End Using statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.UsingBlockSyntax.WithEnd(Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new node and sets the [End] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.UsingBlockSyntax.Update(Roslyn.Compilers.VisualBasic.UsingStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new UsingBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this UsingBlockSyntaxSyntax node with. If not specified
 the current Begin will be used in the new UsingBlockSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this UsingBlockSyntaxSyntax node with. If not
 specified the current BeginTerminator will be used in the new
 UsingBlockSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this UsingBlockSyntaxSyntax node with. If not
 specified the current Statements will be used in the new UsingBlockSyntaxSyntax
 node.
 </param>
	<param name="end">
 The new End to update this UsingBlockSyntaxSyntax node with. If not specified
 the current End will be used in the new UsingBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.UsingBlockSyntax">
	<summary>
 Represents an entire Using...End Using statement, including the Using, body and
 End Using statements.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyncLockBlockSyntax.Begin">
	<summary>
 The SyncLock statement that begins the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyncLockBlockSyntax.WithBegin(Roslyn.Compilers.VisualBasic.SyncLockStatementSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyncLockBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyncLockBlockSyntax.WithBeginTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginTerminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyncLockBlockSyntax.Statements">
	<summary>
 The statements contained in the SyncLock...End SyncLock statement. This might
 be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyncLockBlockSyntax.WithStatements(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new node and sets the Statements property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyncLockBlockSyntax.End">
	<summary>
 The End SyncLock statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyncLockBlockSyntax.WithEnd(Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new node and sets the [End] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyncLockBlockSyntax.Update(Roslyn.Compilers.VisualBasic.SyncLockStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new SyncLockBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this SyncLockBlockSyntaxSyntax node with. If not
 specified the current Begin will be used in the new SyncLockBlockSyntaxSyntax
 node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this SyncLockBlockSyntaxSyntax node with. If
 not specified the current BeginTerminator will be used in the new
 SyncLockBlockSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this SyncLockBlockSyntaxSyntax node with. If not
 specified the current Statements will be used in the new
 SyncLockBlockSyntaxSyntax node.
 </param>
	<param name="end">
 The new End to update this SyncLockBlockSyntaxSyntax node with. If not
 specified the current End will be used in the new SyncLockBlockSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyncLockBlockSyntax">
	<summary>
 Represents a entire SyncLock...End SyncLock block, including the SyncLock
 statement, the enclosed statements, and the End SyncLock statment.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WithBlockSyntax.Begin">
	<summary>
 The WithStatement that begins the With...End With block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.WithBlockSyntax.WithBegin(Roslyn.Compilers.VisualBasic.WithStatementSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.WithBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.WithBlockSyntax.WithBeginTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginTerminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.WithBlockSyntax.Statements">
	<summary>
 The statements contained in the With...End With block. This might be an empty
 list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.WithBlockSyntax.WithStatements(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new node and sets the Statements property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.WithBlockSyntax.End">
	<summary>
 The End With statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.WithBlockSyntax.WithEnd(Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new node and sets the [End] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.WithBlockSyntax.Update(Roslyn.Compilers.VisualBasic.WithStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new WithBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this WithBlockSyntaxSyntax node with. If not specified
 the current Begin will be used in the new WithBlockSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this WithBlockSyntaxSyntax node with. If not
 specified the current BeginTerminator will be used in the new
 WithBlockSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this WithBlockSyntaxSyntax node with. If not
 specified the current Statements will be used in the new WithBlockSyntaxSyntax
 node.
 </param>
	<param name="end">
 The new End to update this WithBlockSyntaxSyntax node with. If not specified
 the current End will be used in the new WithBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.WithBlockSyntax">
	<summary>
 Represents a With...End With block, include the With statement, the body of the
 block and the End With statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LocalDeclarationStatementSyntax.Modifiers">
	<summary>
 The modifier token (Static, Dim or Const) that introduces this local variable
 declaration.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalDeclarationStatementSyntax.WithModifiers(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the Modifiers property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.LocalDeclarationStatementSyntax.Declarators">
	<summary>
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalDeclarationStatementSyntax.WithDeclarators(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax})">
	<summary>
 Creates a new node and sets the Declarators property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalDeclarationStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax})">
	<summary>
 Creates a new LocalDeclarationStatementSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="modifiers">
 The new Modifiers to update this LocalDeclarationStatementSyntaxSyntax node
 with. If not specified the current Modifiers will be used in the new
 LocalDeclarationStatementSyntaxSyntax node.
 </param>
	<param name="declarators">
 The new Declarators to update this LocalDeclarationStatementSyntaxSyntax node
 with. If not specified the current Declarators will be used in the new
 LocalDeclarationStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.LocalDeclarationStatementSyntax">
	<summary>
 Represents the declaration of one or more local variables or constants.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LabelStatementSyntax.LabelToken">
	<summary>
 The name of the label. If the label is a line number, returns an IntegerLiteral
 that is the line number, otherwise, returns an Identifier.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LabelStatementSyntax.WithLabelToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the LabelToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LabelStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new LabelStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="labelToken">
 The new LabelToken to update this LabelStatementSyntaxSyntax node with. If not
 specified the current LabelToken will be used in the new
 LabelStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.LabelStatementSyntax">
	<summary>
 Represents a label statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GoToStatementSyntax.GoToKeyword">
	<summary>
 The "GoTo" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GoToStatementSyntax.WithGoToKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the GoToKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.GoToStatementSyntax.Label">
	<summary>
 The name of the label. If the label is a line number, wraps an IntegerLiteral
 that is the line number, otherwise, wraps an Identifier.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GoToStatementSyntax.WithLabel(Roslyn.Compilers.VisualBasic.LabelSyntax)">
	<summary>
 Creates a new node and sets the Label property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.GoToStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LabelSyntax)">
	<summary>
 Creates a new GoToStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="goToKeyword">
 The new GoToKeyword to update this GoToStatementSyntaxSyntax node with. If not
 specified the current GoToKeyword will be used in the new
 GoToStatementSyntaxSyntax node.
 </param>
	<param name="label">
 The new Label to update this GoToStatementSyntaxSyntax node with. If not
 specified the current Label will be used in the new GoToStatementSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.GoToStatementSyntax">
	<summary>
 Represents a "GoTo" statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LabelSyntax.LabelToken">
	<summary>
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LabelSyntax.WithLabelToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the LabelToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LabelSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new LabelSyntaxSyntax node with the specified changes.
 </summary>
	<param name="labelToken">
 The new LabelToken to update this LabelSyntaxSyntax node with. If not specified
 the current LabelToken will be used in the new LabelSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.LabelSyntax">
	<summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.StopOrEndStatementSyntax.StopOrEndKeyword">
	<summary>
 The "Stop" or "End" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.StopOrEndStatementSyntax.WithStopOrEndKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the StopOrEndKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.StopOrEndStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new StopOrEndStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="stopOrEndKeyword">
 The new StopOrEndKeyword to update this StopOrEndStatementSyntaxSyntax node
 with. If not specified the current StopOrEndKeyword will be used in the new
 StopOrEndStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.StopOrEndStatementSyntax">
	<summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ExitStatementSyntax.ExitKeyword">
	<summary>
 The "Exit" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExitStatementSyntax.WithExitKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ExitKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ExitStatementSyntax.BlockKeyword">
	<summary>
 The keyword describing the block to exit.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExitStatementSyntax.WithBlockKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BlockKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExitStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new ExitStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="exitKeyword">
 The new ExitKeyword to update this ExitStatementSyntaxSyntax node with. If not
 specified the current ExitKeyword will be used in the new
 ExitStatementSyntaxSyntax node.
 </param>
	<param name="blockKeyword">
 The new BlockKeyword to update this ExitStatementSyntaxSyntax node with. If not
 specified the current BlockKeyword will be used in the new
 ExitStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ExitStatementSyntax">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ContinueStatementSyntax.ContinueKeyword">
	<summary>
 The "Continue" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ContinueStatementSyntax.WithContinueKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ContinueKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ContinueStatementSyntax.BlockKeyword">
	<summary>
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ContinueStatementSyntax.WithBlockKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BlockKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ContinueStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new ContinueStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="continueKeyword">
 The new ContinueKeyword to update this ContinueStatementSyntaxSyntax node with.
 If not specified the current ContinueKeyword will be used in the new
 ContinueStatementSyntaxSyntax node.
 </param>
	<param name="blockKeyword">
 The new BlockKeyword to update this ContinueStatementSyntaxSyntax node with. If
 not specified the current BlockKeyword will be used in the new
 ContinueStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ContinueStatementSyntax">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ReturnStatementSyntax.ReturnKeyword">
	<summary>
 The "Return" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ReturnStatementSyntax.WithReturnKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ReturnKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ReturnStatementSyntax.Expression">
	<summary>
 The expression being returned, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ReturnStatementSyntax.WithExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Expression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ReturnStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new ReturnStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="returnKeyword">
 The new ReturnKeyword to update this ReturnStatementSyntaxSyntax node with. If
 not specified the current ReturnKeyword will be used in the new
 ReturnStatementSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this ReturnStatementSyntaxSyntax node with. If not
 specified the current Expression will be used in the new
 ReturnStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ReturnStatementSyntax">
	<summary>
 Represents a "Return" statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SingleLineIfStatementSyntax.IfPart">
	<summary>
 The If part of the statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SingleLineIfStatementSyntax.WithIfPart(Roslyn.Compilers.VisualBasic.SingleLineIfPartSyntax)">
	<summary>
 Creates a new node and sets the IfPart property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SingleLineIfStatementSyntax.ElsePart">
	<summary>
 The Else part of the statement. If there is no Else part, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SingleLineIfStatementSyntax.WithElsePart(Roslyn.Compilers.VisualBasic.SingleLineElsePartSyntax)">
	<summary>
 Creates a new node and sets the ElsePart property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SingleLineIfStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SingleLineIfPartSyntax,Roslyn.Compilers.VisualBasic.SingleLineElsePartSyntax)">
	<summary>
 Creates a new SingleLineIfStatementSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="ifPart">
 The new IfPart to update this SingleLineIfStatementSyntaxSyntax node with. If
 not specified the current IfPart will be used in the new
 SingleLineIfStatementSyntaxSyntax node.
 </param>
	<param name="elsePart">
 The new ElsePart to update this SingleLineIfStatementSyntaxSyntax node with. If
 not specified the current ElsePart will be used in the new
 SingleLineIfStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SingleLineIfStatementSyntax">
	<summary>
 Represents a line If-Then-Else statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SingleLineIfPartSyntax.Begin">
	<summary>
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SingleLineIfPartSyntax.WithBegin(Roslyn.Compilers.VisualBasic.IfStatementSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SingleLineIfPartSyntax.Statements">
	<summary>
 The statements controlled by this If or Else If. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SingleLineIfPartSyntax.WithStatements(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new node and sets the Statements property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SingleLineIfPartSyntax.Update(Roslyn.Compilers.VisualBasic.IfStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new SingleLineIfPartSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this SingleLineIfPartSyntaxSyntax node with. If not
 specified the current Begin will be used in the new
 SingleLineIfPartSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this SingleLineIfPartSyntaxSyntax node with. If
 not specified the current Statements will be used in the new
 SingleLineIfPartSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SingleLineIfPartSyntax">
	<summary>
 Represents part of a single line If statement, consisting of a beginning
 if-statement, followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an SingleLineIf.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SingleLineElsePartSyntax.Begin">
	<summary>
 The Else statement that introduces this part.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SingleLineElsePartSyntax.WithBegin(Roslyn.Compilers.VisualBasic.ElseStatementSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SingleLineElsePartSyntax.Statements">
	<summary>
 The statements controlled by the Else.This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SingleLineElsePartSyntax.WithStatements(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new node and sets the Statements property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SingleLineElsePartSyntax.Update(Roslyn.Compilers.VisualBasic.ElseStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new SingleLineElsePartSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this SingleLineElsePartSyntaxSyntax node with. If not
 specified the current Begin will be used in the new
 SingleLineElsePartSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this SingleLineElsePartSyntaxSyntax node with. If
 not specified the current Statements will be used in the new
 SingleLineElsePartSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SingleLineElsePartSyntax">
	<summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MultiLineIfBlockSyntax.IfPart">
	<summary>
 The If part of the statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MultiLineIfBlockSyntax.WithIfPart(Roslyn.Compilers.VisualBasic.IfPartSyntax)">
	<summary>
 Creates a new node and sets the IfPart property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MultiLineIfBlockSyntax.ElseIfParts">
	<summary>
 A list of the "ElseIf" parts of the statement. If there are no ElseIf parts,
 then an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MultiLineIfBlockSyntax.WithElseIfParts(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.IfPartSyntax})">
	<summary>
 Creates a new node and sets the ElseIfParts property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MultiLineIfBlockSyntax.ElsePart">
	<summary>
 The Else part of the statement. If there is no Else part, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MultiLineIfBlockSyntax.WithElsePart(Roslyn.Compilers.VisualBasic.ElsePartSyntax)">
	<summary>
 Creates a new node and sets the ElsePart property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MultiLineIfBlockSyntax.End">
	<summary>
 If this is a block if, returns the "End If" statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MultiLineIfBlockSyntax.WithEnd(Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new node and sets the [End] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MultiLineIfBlockSyntax.Update(Roslyn.Compilers.VisualBasic.IfPartSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.IfPartSyntax},Roslyn.Compilers.VisualBasic.ElsePartSyntax,Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new MultiLineIfBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="ifPart">
 The new IfPart to update this MultiLineIfBlockSyntaxSyntax node with. If not
 specified the current IfPart will be used in the new
 MultiLineIfBlockSyntaxSyntax node.
 </param>
	<param name="elseIfParts">
 The new ElseIfParts to update this MultiLineIfBlockSyntaxSyntax node with. If
 not specified the current ElseIfParts will be used in the new
 MultiLineIfBlockSyntaxSyntax node.
 </param>
	<param name="elsePart">
 The new ElsePart to update this MultiLineIfBlockSyntaxSyntax node with. If not
 specified the current ElsePart will be used in the new
 MultiLineIfBlockSyntaxSyntax node.
 </param>
	<param name="end">
 The new End to update this MultiLineIfBlockSyntaxSyntax node with. If not
 specified the current End will be used in the new MultiLineIfBlockSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.MultiLineIfBlockSyntax">
	<summary>
 Represents a block If...Then...Else...EndIf Statement. The Kind property can be
 used to determine if it is a block or line If.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.IfPartSyntax.Begin">
	<summary>
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.IfPartSyntax.WithBegin(Roslyn.Compilers.VisualBasic.IfStatementSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.IfPartSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.IfPartSyntax.WithBeginTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginTerminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.IfPartSyntax.Statements">
	<summary>
 The statements controlled by this If or Else If. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.IfPartSyntax.WithStatements(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new node and sets the Statements property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.IfPartSyntax.Update(Roslyn.Compilers.VisualBasic.IfStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new IfPartSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this IfPartSyntaxSyntax node with. If not specified the
 current Begin will be used in the new IfPartSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this IfPartSyntaxSyntax node with. If not
 specified the current BeginTerminator will be used in the new
 IfPartSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this IfPartSyntaxSyntax node with. If not
 specified the current Statements will be used in the new IfPartSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.IfPartSyntax">
	<summary>
 Represents part of an If statement, consisting of a beginning statement (If or
 ElseIf), followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an If or ElseIf.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ElsePartSyntax.Begin">
	<summary>
 The Else statement that introduces this part.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ElsePartSyntax.WithBegin(Roslyn.Compilers.VisualBasic.ElseStatementSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ElsePartSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ElsePartSyntax.WithBeginTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginTerminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ElsePartSyntax.Statements">
	<summary>
 The statements controlled by the Else. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ElsePartSyntax.WithStatements(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new node and sets the Statements property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ElsePartSyntax.Update(Roslyn.Compilers.VisualBasic.ElseStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new ElsePartSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this ElsePartSyntaxSyntax node with. If not specified
 the current Begin will be used in the new ElsePartSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this ElsePartSyntaxSyntax node with. If not
 specified the current BeginTerminator will be used in the new
 ElsePartSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this ElsePartSyntaxSyntax node with. If not
 specified the current Statements will be used in the new ElsePartSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ElsePartSyntax">
	<summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.IfStatementSyntax.ElseKeyword">
	<summary>
 If this ElseIf was written as "Else If", contains the "Else" keyword. Otherwise
 returns Nothing.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.IfStatementSyntax.WithElseKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ElseKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.IfStatementSyntax.IfOrElseIfKeyword">
	<summary>
 The "If" or "ElseIf" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.IfStatementSyntax.WithIfOrElseIfKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the IfOrElseIfKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.IfStatementSyntax.Condition">
	<summary>
 The boolean expression that is being tested.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.IfStatementSyntax.WithCondition(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Condition property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.IfStatementSyntax.ThenKeyword">
	<summary>
 The "Then" keyword.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.IfStatementSyntax.WithThenKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ThenKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.IfStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new IfStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="elseKeyword">
 The new ElseKeyword to update this IfStatementSyntaxSyntax node with. If not
 specified the current ElseKeyword will be used in the new
 IfStatementSyntaxSyntax node.
 </param>
	<param name="ifOrElseIfKeyword">
 The new IfOrElseIfKeyword to update this IfStatementSyntaxSyntax node with. If
 not specified the current IfOrElseIfKeyword will be used in the new
 IfStatementSyntaxSyntax node.
 </param>
	<param name="condition">
 The new Condition to update this IfStatementSyntaxSyntax node with. If not
 specified the current Condition will be used in the new IfStatementSyntaxSyntax
 node.
 </param>
	<param name="thenKeyword">
 The new ThenKeyword to update this IfStatementSyntaxSyntax node with. If not
 specified the current ThenKeyword will be used in the new
 IfStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.IfStatementSyntax">
	<summary>
 Represents the If part or ElseIf part of a If...End If block (or line If). This
 statement is always the Begin of a IfPart. The Kind can be examined to
 determine if this is an If or an ElseIf statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ElseStatementSyntax.ElseKeyword">
	<summary>
 The "Else" keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ElseStatementSyntax.WithElseKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ElseKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ElseStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new ElseStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="elseKeyword">
 The new ElseKeyword to update this ElseStatementSyntaxSyntax node with. If not
 specified the current ElseKeyword will be used in the new
 ElseStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ElseStatementSyntax">
	<summary>
 Represents the Else part of a If...End If block (or line If). This statement is
 always the Begin of a ElsePart.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TryBlockSyntax.TryPart">
	<summary>
 The Try part of the statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TryBlockSyntax.WithTryPart(Roslyn.Compilers.VisualBasic.TryPartSyntax)">
	<summary>
 Creates a new node and sets the TryPart property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TryBlockSyntax.CatchParts">
	<summary>
 A list of the Catch parts of the statement. If there are no Catch parts, then
 an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TryBlockSyntax.WithCatchParts(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.CatchPartSyntax})">
	<summary>
 Creates a new node and sets the CatchParts property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TryBlockSyntax.FinallyPart">
	<summary>
 The Finally part of the statement, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TryBlockSyntax.WithFinallyPart(Roslyn.Compilers.VisualBasic.FinallyPartSyntax)">
	<summary>
 Creates a new node and sets the FinallyPart property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TryBlockSyntax.End">
	<summary>
 The "End Try" statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TryBlockSyntax.WithEnd(Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new node and sets the [End] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TryBlockSyntax.Update(Roslyn.Compilers.VisualBasic.TryPartSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.CatchPartSyntax},Roslyn.Compilers.VisualBasic.FinallyPartSyntax,Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new TryBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="tryPart">
 The new TryPart to update this TryBlockSyntaxSyntax node with. If not specified
 the current TryPart will be used in the new TryBlockSyntaxSyntax node.
 </param>
	<param name="catchParts">
 The new CatchParts to update this TryBlockSyntaxSyntax node with. If not
 specified the current CatchParts will be used in the new TryBlockSyntaxSyntax
 node.
 </param>
	<param name="finallyPart">
 The new FinallyPart to update this TryBlockSyntaxSyntax node with. If not
 specified the current FinallyPart will be used in the new TryBlockSyntaxSyntax
 node.
 </param>
	<param name="end">
 The new End to update this TryBlockSyntaxSyntax node with. If not specified the
 current End will be used in the new TryBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.TryBlockSyntax">
	<summary>
 Represents an entire Try...Catch...Finally...End Try statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TryPartSyntax.Begin">
	<summary>
 The TryStatement that introduces this part of the Try...Catch...Finally...End
 Try.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TryPartSyntax.WithBegin(Roslyn.Compilers.VisualBasic.TryStatementSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TryPartSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TryPartSyntax.WithBeginTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginTerminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TryPartSyntax.Statements">
	<summary>
 The statements inside the Try part of the Try...Catch...Finally...End Try. This
 might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TryPartSyntax.WithStatements(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new node and sets the Statements property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TryPartSyntax.Update(Roslyn.Compilers.VisualBasic.TryStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new TryPartSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this TryPartSyntaxSyntax node with. If not specified
 the current Begin will be used in the new TryPartSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this TryPartSyntaxSyntax node with. If not
 specified the current BeginTerminator will be used in the new
 TryPartSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this TryPartSyntaxSyntax node with. If not
 specified the current Statements will be used in the new TryPartSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.TryPartSyntax">
	<summary>
 Represents part of an Try...Catch...Finally...End Try statement, consisting of
 a beginning statement (Try, Catch or Finally), followed by a body of statements
 controlled by that beginning statement. The Kind property returns which kind of
 part this is.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CatchPartSyntax.Begin">
	<summary>
 The CatchStatement that introduces this part.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CatchPartSyntax.WithBegin(Roslyn.Compilers.VisualBasic.CatchStatementSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CatchPartSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CatchPartSyntax.WithBeginTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginTerminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CatchPartSyntax.Statements">
	<summary>
 The statements controlled by the Catch statement. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CatchPartSyntax.WithStatements(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new node and sets the Statements property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CatchPartSyntax.Update(Roslyn.Compilers.VisualBasic.CatchStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new CatchPartSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this CatchPartSyntaxSyntax node with. If not specified
 the current Begin will be used in the new CatchPartSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this CatchPartSyntaxSyntax node with. If not
 specified the current BeginTerminator will be used in the new
 CatchPartSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this CatchPartSyntaxSyntax node with. If not
 specified the current Statements will be used in the new CatchPartSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CatchPartSyntax">
	<summary>
 Represents a Catch part of an Try...Catch...Finally...End Try statement,
 consisting of a Catch statement, followed by a body of statements controlled by
 that Catch statement. The Kind property returns which kind of part this is.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FinallyPartSyntax.Begin">
	<summary>
 The FinallyStatement that introduces the Finally part of a Try.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.FinallyPartSyntax.WithBegin(Roslyn.Compilers.VisualBasic.FinallyStatementSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.FinallyPartSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.FinallyPartSyntax.WithBeginTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginTerminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.FinallyPartSyntax.Statements">
	<summary>
 The statements inside the Finally part of the Try...Catch...Finally...End Try.
 This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.FinallyPartSyntax.WithStatements(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new node and sets the Statements property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.FinallyPartSyntax.Update(Roslyn.Compilers.VisualBasic.FinallyStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new FinallyPartSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this FinallyPartSyntaxSyntax node with. If not
 specified the current Begin will be used in the new FinallyPartSyntaxSyntax
 node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this FinallyPartSyntaxSyntax node with. If
 not specified the current BeginTerminator will be used in the new
 FinallyPartSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this FinallyPartSyntaxSyntax node with. If not
 specified the current Statements will be used in the new
 FinallyPartSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.FinallyPartSyntax">
	<summary>
 Represents the Finally part of an Try...Catch...Finally...End Try statement,
 consisting of a Finally statement, followed by a body of statements controlled
 by the Finally.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TryStatementSyntax.TryKeyword">
	<summary>
 The "Try" keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TryStatementSyntax.WithTryKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the TryKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TryStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new TryStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="tryKeyword">
 The new TryKeyword to update this TryStatementSyntaxSyntax node with. If not
 specified the current TryKeyword will be used in the new
 TryStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.TryStatementSyntax">
	<summary>
 Represents the Try part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a TryPart.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CatchStatementSyntax.CatchKeyword">
	<summary>
 The "Catch" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CatchStatementSyntax.WithCatchKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CatchKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CatchStatementSyntax.IdentifierName">
	<summary>
 The identifier representing the exception that was caught, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CatchStatementSyntax.WithIdentifierName(Roslyn.Compilers.VisualBasic.IdentifierNameSyntax)">
	<summary>
 Creates a new node and sets the IdentifierName property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CatchStatementSyntax.AsClause">
	<summary>
 The As clause that defines the type of exception being caught.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CatchStatementSyntax.WithAsClause(Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax)">
	<summary>
 Creates a new node and sets the AsClause property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CatchStatementSyntax.WhenClause">
	<summary>
 The "When" clause, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CatchStatementSyntax.WithWhenClause(Roslyn.Compilers.VisualBasic.CatchFilterClauseSyntax)">
	<summary>
 Creates a new node and sets the WhenClause property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CatchStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.IdentifierNameSyntax,Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.CatchFilterClauseSyntax)">
	<summary>
 Creates a new CatchStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="catchKeyword">
 The new CatchKeyword to update this CatchStatementSyntaxSyntax node with. If
 not specified the current CatchKeyword will be used in the new
 CatchStatementSyntaxSyntax node.
 </param>
	<param name="identifierName">
 The new IdentifierName to update this CatchStatementSyntaxSyntax node with. If
 not specified the current IdentifierName will be used in the new
 CatchStatementSyntaxSyntax node.
 </param>
	<param name="asClause">
 The new AsClause to update this CatchStatementSyntaxSyntax node with. If not
 specified the current AsClause will be used in the new
 CatchStatementSyntaxSyntax node.
 </param>
	<param name="whenClause">
 The new WhenClause to update this CatchStatementSyntaxSyntax node with. If not
 specified the current WhenClause will be used in the new
 CatchStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CatchStatementSyntax">
	<summary>
 Represents the Catch part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a CatchPart.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CatchFilterClauseSyntax.WhenKeyword">
	<summary>
 The "When" keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CatchFilterClauseSyntax.WithWhenKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the WhenKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CatchFilterClauseSyntax.Filter">
	<summary>
 The filter expression
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CatchFilterClauseSyntax.WithFilter(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Filter property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CatchFilterClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new CatchFilterClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="whenKeyword">
 The new WhenKeyword to update this CatchFilterClauseSyntaxSyntax node with. If
 not specified the current WhenKeyword will be used in the new
 CatchFilterClauseSyntaxSyntax node.
 </param>
	<param name="filter">
 The new Filter to update this CatchFilterClauseSyntaxSyntax node with. If not
 specified the current Filter will be used in the new
 CatchFilterClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CatchFilterClauseSyntax">
	<summary>
 Represents the When/Filter clause of a Catch statement
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FinallyStatementSyntax.FinallyKeyword">
	<summary>
 The "Finally" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.FinallyStatementSyntax.WithFinallyKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the FinallyKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.FinallyStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new FinallyStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="finallyKeyword">
 The new FinallyKeyword to update this FinallyStatementSyntaxSyntax node with.
 If not specified the current FinallyKeyword will be used in the new
 FinallyStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.FinallyStatementSyntax">
	<summary>
 Represents the Finally part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a FinallyPart.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ErrorStatementSyntax.ErrorKeyword">
	<summary>
 The "Error" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ErrorStatementSyntax.WithErrorKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ErrorKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ErrorStatementSyntax.ErrorNumber">
	<summary>
 The expression that represents the error number.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ErrorStatementSyntax.WithErrorNumber(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the ErrorNumber property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ErrorStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new ErrorStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="errorKeyword">
 The new ErrorKeyword to update this ErrorStatementSyntaxSyntax node with. If
 not specified the current ErrorKeyword will be used in the new
 ErrorStatementSyntaxSyntax node.
 </param>
	<param name="errorNumber">
 The new ErrorNumber to update this ErrorStatementSyntaxSyntax node with. If not
 specified the current ErrorNumber will be used in the new
 ErrorStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ErrorStatementSyntax">
	<summary>
 Represents the "Error" statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OnErrorGoToStatementSyntax.OnKeyword">
	<summary>
 The "On" keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OnErrorGoToStatementSyntax.WithOnKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OnKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.OnErrorGoToStatementSyntax.ErrorKeyword">
	<summary>
 The "Error" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OnErrorGoToStatementSyntax.WithErrorKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ErrorKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.OnErrorGoToStatementSyntax.GoToKeyword">
	<summary>
 The "GoTo" keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OnErrorGoToStatementSyntax.WithGoToKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the GoToKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.OnErrorGoToStatementSyntax.Minus">
	<summary>
 An optional minus for On Error Goto -1
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OnErrorGoToStatementSyntax.WithMinus(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Minus property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.OnErrorGoToStatementSyntax.Label">
	<summary>
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OnErrorGoToStatementSyntax.WithLabel(Roslyn.Compilers.VisualBasic.LabelSyntax)">
	<summary>
 Creates a new node and sets the Label property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OnErrorGoToStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LabelSyntax)">
	<summary>
 Creates a new OnErrorGoToStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="onKeyword">
 The new OnKeyword to update this OnErrorGoToStatementSyntaxSyntax node with. If
 not specified the current OnKeyword will be used in the new
 OnErrorGoToStatementSyntaxSyntax node.
 </param>
	<param name="errorKeyword">
 The new ErrorKeyword to update this OnErrorGoToStatementSyntaxSyntax node with.
 If not specified the current ErrorKeyword will be used in the new
 OnErrorGoToStatementSyntaxSyntax node.
 </param>
	<param name="goToKeyword">
 The new GoToKeyword to update this OnErrorGoToStatementSyntaxSyntax node with.
 If not specified the current GoToKeyword will be used in the new
 OnErrorGoToStatementSyntaxSyntax node.
 </param>
	<param name="minus">
 The new Minus to update this OnErrorGoToStatementSyntaxSyntax node with. If not
 specified the current Minus will be used in the new
 OnErrorGoToStatementSyntaxSyntax node.
 </param>
	<param name="label">
 The new Label to update this OnErrorGoToStatementSyntaxSyntax node with. If not
 specified the current Label will be used in the new
 OnErrorGoToStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.OnErrorGoToStatementSyntax">
	<summary>
 Represents an OnError Goto statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OnErrorResumeNextStatementSyntax.OnKeyword">
	<summary>
 The "On" keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OnErrorResumeNextStatementSyntax.WithOnKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OnKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.OnErrorResumeNextStatementSyntax.ErrorKeyword">
	<summary>
 The "Error" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OnErrorResumeNextStatementSyntax.WithErrorKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ErrorKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.OnErrorResumeNextStatementSyntax.ResumeKeyword">
	<summary>
 The "Resume" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OnErrorResumeNextStatementSyntax.WithResumeKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ResumeKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.OnErrorResumeNextStatementSyntax.NextKeyword">
	<summary>
 The "Next"
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OnErrorResumeNextStatementSyntax.WithNextKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the NextKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OnErrorResumeNextStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new OnErrorResumeNextStatementSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="onKeyword">
 The new OnKeyword to update this OnErrorResumeNextStatementSyntaxSyntax node
 with. If not specified the current OnKeyword will be used in the new
 OnErrorResumeNextStatementSyntaxSyntax node.
 </param>
	<param name="errorKeyword">
 The new ErrorKeyword to update this OnErrorResumeNextStatementSyntaxSyntax node
 with. If not specified the current ErrorKeyword will be used in the new
 OnErrorResumeNextStatementSyntaxSyntax node.
 </param>
	<param name="resumeKeyword">
 The new ResumeKeyword to update this OnErrorResumeNextStatementSyntaxSyntax
 node with. If not specified the current ResumeKeyword will be used in the new
 OnErrorResumeNextStatementSyntaxSyntax node.
 </param>
	<param name="nextKeyword">
 The new NextKeyword to update this OnErrorResumeNextStatementSyntaxSyntax node
 with. If not specified the current NextKeyword will be used in the new
 OnErrorResumeNextStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.OnErrorResumeNextStatementSyntax">
	<summary>
 Represents an OnError Resume Next statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ResumeStatementSyntax.ResumeKeyword">
	<summary>
 The "Resume" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ResumeStatementSyntax.WithResumeKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ResumeKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ResumeStatementSyntax.Label">
	<summary>
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ResumeStatementSyntax.WithLabel(Roslyn.Compilers.VisualBasic.LabelSyntax)">
	<summary>
 Creates a new node and sets the Label property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ResumeStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LabelSyntax)">
	<summary>
 Creates a new ResumeStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="resumeKeyword">
 The new ResumeKeyword to update this ResumeStatementSyntaxSyntax node with. If
 not specified the current ResumeKeyword will be used in the new
 ResumeStatementSyntaxSyntax node.
 </param>
	<param name="label">
 The new Label to update this ResumeStatementSyntaxSyntax node with. If not
 specified the current Label will be used in the new ResumeStatementSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ResumeStatementSyntax">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SelectBlockSyntax.Begin">
	<summary>
 The Select Case statement that begins the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SelectBlockSyntax.WithBegin(Roslyn.Compilers.VisualBasic.SelectStatementSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SelectBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SelectBlockSyntax.WithBeginTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginTerminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SelectBlockSyntax.CaseBlocks">
	<summary>
 A list of the contained Case blocks.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SelectBlockSyntax.WithCaseBlocks(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.CaseBlockSyntax})">
	<summary>
 Creates a new node and sets the CaseBlocks property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SelectBlockSyntax.End">
	<summary>
 The End Select statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SelectBlockSyntax.WithEnd(Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new node and sets the [End] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SelectBlockSyntax.Update(Roslyn.Compilers.VisualBasic.SelectStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.CaseBlockSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new SelectBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this SelectBlockSyntaxSyntax node with. If not
 specified the current Begin will be used in the new SelectBlockSyntaxSyntax
 node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this SelectBlockSyntaxSyntax node with. If
 not specified the current BeginTerminator will be used in the new
 SelectBlockSyntaxSyntax node.
 </param>
	<param name="caseBlocks">
 The new CaseBlocks to update this SelectBlockSyntaxSyntax node with. If not
 specified the current CaseBlocks will be used in the new
 SelectBlockSyntaxSyntax node.
 </param>
	<param name="end">
 The new End to update this SelectBlockSyntaxSyntax node with. If not specified
 the current End will be used in the new SelectBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SelectBlockSyntax">
	<summary>
 Represents a Select Case block, including the Select Case that begins it, the
 contains Case blocks and the End Select.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SelectStatementSyntax.SelectKeyword">
	<summary>
 The "Select" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SelectStatementSyntax.WithSelectKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the SelectKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SelectStatementSyntax.CaseKeyword">
	<summary>
 The "Case" keyword, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SelectStatementSyntax.WithCaseKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CaseKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SelectStatementSyntax.Expression">
	<summary>
 The value that branching is based on.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SelectStatementSyntax.WithExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Expression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SelectStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new SelectStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="selectKeyword">
 The new SelectKeyword to update this SelectStatementSyntaxSyntax node with. If
 not specified the current SelectKeyword will be used in the new
 SelectStatementSyntaxSyntax node.
 </param>
	<param name="caseKeyword">
 The new CaseKeyword to update this SelectStatementSyntaxSyntax node with. If
 not specified the current CaseKeyword will be used in the new
 SelectStatementSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this SelectStatementSyntaxSyntax node with. If not
 specified the current Expression will be used in the new
 SelectStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SelectStatementSyntax">
	<summary>
 Represents a Select Case statement. This statement always occurs as the Begin
 of a SelectBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseBlockSyntax.Begin">
	<summary>
 The statement that begins the case block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseBlockSyntax.WithBegin(Roslyn.Compilers.VisualBasic.CaseStatementSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseBlockSyntax.WithBeginTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginTerminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseBlockSyntax.Statements">
	<summary>
 The statements contained in the case block. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseBlockSyntax.WithStatements(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new node and sets the Statements property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseBlockSyntax.Update(Roslyn.Compilers.VisualBasic.CaseStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new CaseBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this CaseBlockSyntaxSyntax node with. If not specified
 the current Begin will be used in the new CaseBlockSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this CaseBlockSyntaxSyntax node with. If not
 specified the current BeginTerminator will be used in the new
 CaseBlockSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this CaseBlockSyntaxSyntax node with. If not
 specified the current Statements will be used in the new CaseBlockSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CaseBlockSyntax">
	<summary>
 Represents a case statement and its subsequent block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseStatementSyntax.CaseKeyword">
	<summary>
 The "Case" keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseStatementSyntax.WithCaseKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CaseKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseStatementSyntax.Cases">
	<summary>
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a CaseElseClause.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseStatementSyntax.WithCases(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CaseClauseSyntax})">
	<summary>
 Creates a new node and sets the Cases property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CaseClauseSyntax})">
	<summary>
 Creates a new CaseStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="caseKeyword">
 The new CaseKeyword to update this CaseStatementSyntaxSyntax node with. If not
 specified the current CaseKeyword will be used in the new
 CaseStatementSyntaxSyntax node.
 </param>
	<param name="cases">
 The new Cases to update this CaseStatementSyntaxSyntax node with. If not
 specified the current Cases will be used in the new CaseStatementSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CaseStatementSyntax">
	<summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.CaseClauseSyntax">
	<summary>
 Represents a single clause in a case statement. An abstract node that is the
 parent of different kinds of Case clauses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseElseClauseSyntax.ElseKeyword">
	<summary>
 The "Else" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseElseClauseSyntax.WithElseKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ElseKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseElseClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new CaseElseClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="elseKeyword">
 The new ElseKeyword to update this CaseElseClauseSyntaxSyntax node with. If not
 specified the current ElseKeyword will be used in the new
 CaseElseClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CaseElseClauseSyntax">
	<summary>
 The "Else" part in a Case Else statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseValueClauseSyntax.Value">
	<summary>
 The expression that denotes the value being tested against.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseValueClauseSyntax.WithValue(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Value property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseValueClauseSyntax.Update(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new CaseValueClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="value">
 The new Value to update this CaseValueClauseSyntaxSyntax node with. If not
 specified the current Value will be used in the new CaseValueClauseSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CaseValueClauseSyntax">
	<summary>
 Represents a single value in a Case.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseRangeClauseSyntax.LowerBound">
	<summary>
 The lower bound of the range.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseRangeClauseSyntax.WithLowerBound(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the LowerBound property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseRangeClauseSyntax.ToKeyword">
	<summary>
 The "To" keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseRangeClauseSyntax.WithToKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ToKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseRangeClauseSyntax.UpperBound">
	<summary>
 The upper bound of the range.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseRangeClauseSyntax.WithUpperBound(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the UpperBound property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseRangeClauseSyntax.Update(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new CaseRangeClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="lowerBound">
 The new LowerBound to update this CaseRangeClauseSyntaxSyntax node with. If not
 specified the current LowerBound will be used in the new
 CaseRangeClauseSyntaxSyntax node.
 </param>
	<param name="toKeyword">
 The new ToKeyword to update this CaseRangeClauseSyntaxSyntax node with. If not
 specified the current ToKeyword will be used in the new
 CaseRangeClauseSyntaxSyntax node.
 </param>
	<param name="upperBound">
 The new UpperBound to update this CaseRangeClauseSyntaxSyntax node with. If not
 specified the current UpperBound will be used in the new
 CaseRangeClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CaseRangeClauseSyntax">
	<summary>
 Represents a range "expression To expression" in a Case.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseRelationalClauseSyntax.IsKeyword">
	<summary>
 The "Is" keyword, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseRelationalClauseSyntax.WithIsKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the IsKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseRelationalClauseSyntax.OperatorToken">
	<summary>
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseRelationalClauseSyntax.WithOperatorToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OperatorToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CaseRelationalClauseSyntax.Value">
	<summary>
 The expression that denotes the value being tested against.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseRelationalClauseSyntax.WithValue(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Value property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CaseRelationalClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new CaseRelationalClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="isKeyword">
 The new IsKeyword to update this CaseRelationalClauseSyntaxSyntax node with. If
 not specified the current IsKeyword will be used in the new
 CaseRelationalClauseSyntaxSyntax node.
 </param>
	<param name="operatorToken">
 The new OperatorToken to update this CaseRelationalClauseSyntaxSyntax node
 with. If not specified the current OperatorToken will be used in the new
 CaseRelationalClauseSyntaxSyntax node.
 </param>
	<param name="value">
 The new Value to update this CaseRelationalClauseSyntaxSyntax node with. If not
 specified the current Value will be used in the new
 CaseRelationalClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CaseRelationalClauseSyntax">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyncLockStatementSyntax.SyncLockKeyword">
	<summary>
 The "SyncLock" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyncLockStatementSyntax.WithSyncLockKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the SyncLockKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyncLockStatementSyntax.Expression">
	<summary>
 The expression being synchronized on.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyncLockStatementSyntax.WithExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Expression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyncLockStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new SyncLockStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="syncLockKeyword">
 The new SyncLockKeyword to update this SyncLockStatementSyntaxSyntax node with.
 If not specified the current SyncLockKeyword will be used in the new
 SyncLockStatementSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this SyncLockStatementSyntaxSyntax node with. If
 not specified the current Expression will be used in the new
 SyncLockStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyncLockStatementSyntax">
	<summary>
 Represents the "SyncLock" statement. This statement always occurs as the Begin
 of a SyncLockBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DoLoopBlockSyntax.Begin">
	<summary>
 The Do statement that begins the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DoLoopBlockSyntax.WithBegin(Roslyn.Compilers.VisualBasic.DoStatementSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DoLoopBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DoLoopBlockSyntax.WithBeginTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginTerminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DoLoopBlockSyntax.Statements">
	<summary>
 The statements contained in the block statement. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DoLoopBlockSyntax.WithStatements(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new node and sets the Statements property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DoLoopBlockSyntax.End">
	<summary>
 The Loop statement that ends the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DoLoopBlockSyntax.WithEnd(Roslyn.Compilers.VisualBasic.LoopStatementSyntax)">
	<summary>
 Creates a new node and sets the [End] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DoLoopBlockSyntax.Update(Roslyn.Compilers.VisualBasic.DoStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.LoopStatementSyntax)">
	<summary>
 Creates a new DoLoopBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this DoLoopBlockSyntaxSyntax node with. If not
 specified the current Begin will be used in the new DoLoopBlockSyntaxSyntax
 node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this DoLoopBlockSyntaxSyntax node with. If
 not specified the current BeginTerminator will be used in the new
 DoLoopBlockSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this DoLoopBlockSyntaxSyntax node with. If not
 specified the current Statements will be used in the new
 DoLoopBlockSyntaxSyntax node.
 </param>
	<param name="end">
 The new End to update this DoLoopBlockSyntaxSyntax node with. If not specified
 the current End will be used in the new DoLoopBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.DoLoopBlockSyntax">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DoStatementSyntax.DoKeyword">
	<summary>
 The "Do" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DoStatementSyntax.WithDoKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the DoKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DoStatementSyntax.WhileUntilClause">
	<summary>
 The "While expression" or "Until expression" part of the Do statement, if
 present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DoStatementSyntax.WithWhileUntilClause(Roslyn.Compilers.VisualBasic.WhileUntilClauseSyntax)">
	<summary>
 Creates a new node and sets the WhileUntilClause property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DoStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.WhileUntilClauseSyntax)">
	<summary>
 Creates a new DoStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="doKeyword">
 The new DoKeyword to update this DoStatementSyntaxSyntax node with. If not
 specified the current DoKeyword will be used in the new DoStatementSyntaxSyntax
 node.
 </param>
	<param name="whileUntilClause">
 The new WhileUntilClause to update this DoStatementSyntaxSyntax node with. If
 not specified the current WhileUntilClause will be used in the new
 DoStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.DoStatementSyntax">
	<summary>
 The Do statement that begins a Do-Loop block. This statement always occurs as
 the Begin of a DoLoopBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LoopStatementSyntax.LoopKeyword">
	<summary>
 The "Loop" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LoopStatementSyntax.WithLoopKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the LoopKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.LoopStatementSyntax.WhileUntilClause">
	<summary>
 The "While expression" or "Until expression" part of the Loop statement, if
 present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LoopStatementSyntax.WithWhileUntilClause(Roslyn.Compilers.VisualBasic.WhileUntilClauseSyntax)">
	<summary>
 Creates a new node and sets the WhileUntilClause property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LoopStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.WhileUntilClauseSyntax)">
	<summary>
 Creates a new LoopStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="loopKeyword">
 The new LoopKeyword to update this LoopStatementSyntaxSyntax node with. If not
 specified the current LoopKeyword will be used in the new
 LoopStatementSyntaxSyntax node.
 </param>
	<param name="whileUntilClause">
 The new WhileUntilClause to update this LoopStatementSyntaxSyntax node with. If
 not specified the current WhileUntilClause will be used in the new
 LoopStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.LoopStatementSyntax">
	<summary>
 The Loop statement that ends a Do-Loop block. This statement always occurs as
 the End of a DoLoopBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WhileUntilClauseSyntax.WhileOrUntilKeyword">
	<summary>
 The "While" or "Until" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.WhileUntilClauseSyntax.WithWhileOrUntilKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the WhileOrUntilKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.WhileUntilClauseSyntax.Condition">
	<summary>
 The boolean expression after the While or Until.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.WhileUntilClauseSyntax.WithCondition(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Condition property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.WhileUntilClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new WhileUntilClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="whileOrUntilKeyword">
 The new WhileOrUntilKeyword to update this WhileUntilClauseSyntaxSyntax node
 with. If not specified the current WhileOrUntilKeyword will be used in the new
 WhileUntilClauseSyntaxSyntax node.
 </param>
	<param name="condition">
 The new Condition to update this WhileUntilClauseSyntaxSyntax node with. If not
 specified the current Condition will be used in the new
 WhileUntilClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.WhileUntilClauseSyntax">
	<summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WhileStatementSyntax.WhileKeyword">
	<summary>
 The "While" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.WhileStatementSyntax.WithWhileKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the WhileKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.WhileStatementSyntax.Condition">
	<summary>
 The boolean expression that controls the While loop.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.WhileStatementSyntax.WithCondition(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Condition property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.WhileStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new WhileStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="whileKeyword">
 The new WhileKeyword to update this WhileStatementSyntaxSyntax node with. If
 not specified the current WhileKeyword will be used in the new
 WhileStatementSyntaxSyntax node.
 </param>
	<param name="condition">
 The new Condition to update this WhileStatementSyntaxSyntax node with. If not
 specified the current Condition will be used in the new
 WhileStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.WhileStatementSyntax">
	<summary>
 The While statement that begins a While...End While block. This statement
 always occurs as the Begin of a WhileBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForBlockSyntax.Begin">
	<summary>
 The For or For Each statement that begins the block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForBlockSyntax.WithBegin(Roslyn.Compilers.VisualBasic.StatementSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForBlockSyntax.WithBeginTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginTerminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForBlockSyntax.Statements">
	<summary>
 The statements contained in the For or For Each loop. This might be an empty
 list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForBlockSyntax.WithStatements(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new node and sets the Statements property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForBlockSyntax.End">
	<summary>
 The Next statement that ends the block. If two For statements are ended by a
 single Next statement, the inner For will not have an EndStatment.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForBlockSyntax.WithEnd(Roslyn.Compilers.VisualBasic.NextStatementSyntax)">
	<summary>
 Creates a new node and sets the [End] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForBlockSyntax.Update(Roslyn.Compilers.VisualBasic.StatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.NextStatementSyntax)">
	<summary>
 Creates a new ForBlockSyntaxSyntax node with the specified changes.
 </summary>
	<param name="begin">
 The new Begin to update this ForBlockSyntaxSyntax node with. If not specified
 the current Begin will be used in the new ForBlockSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this ForBlockSyntaxSyntax node with. If not
 specified the current BeginTerminator will be used in the new
 ForBlockSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this ForBlockSyntaxSyntax node with. If not
 specified the current Statements will be used in the new ForBlockSyntaxSyntax
 node.
 </param>
	<param name="end">
 The new End to update this ForBlockSyntaxSyntax node with. If not specified the
 current End will be used in the new ForBlockSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ForBlockSyntax">
	<summary>
 Represents a For or For Each block, including the introducting statement, the
 body and the "Next" (which can be omitted if a containing For has a Next with
 multiple variables).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForStatementSyntax.ForKeyword">
	<summary>
 The "For" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForStatementSyntax.WithForKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ForKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForStatementSyntax.ControlVariable">
	<summary>
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForStatementSyntax.WithControlVariable(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Creates a new node and sets the ControlVariable property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForStatementSyntax.EqualsToken">
	<summary>
 The "=" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForStatementSyntax.WithEqualsToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the EqualsToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForStatementSyntax.FromValue">
	<summary>
 The expression denoting the initial value of the iteration.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForStatementSyntax.WithFromValue(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the FromValue property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForStatementSyntax.ToKeyword">
	<summary>
 The "To" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForStatementSyntax.WithToKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ToKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForStatementSyntax.ToValue">
	<summary>
 The expression denoting the final value of the iteration.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForStatementSyntax.WithToValue(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the ToValue property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForStatementSyntax.StepClause">
	<summary>
 The optional Step clause.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForStatementSyntax.WithStepClause(Roslyn.Compilers.VisualBasic.ForStepClauseSyntax)">
	<summary>
 Creates a new node and sets the StepClause property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ForStepClauseSyntax)">
	<summary>
 Creates a new ForStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="forKeyword">
 The new ForKeyword to update this ForStatementSyntaxSyntax node with. If not
 specified the current ForKeyword will be used in the new
 ForStatementSyntaxSyntax node.
 </param>
	<param name="controlVariable">
 The new ControlVariable to update this ForStatementSyntaxSyntax node with. If
 not specified the current ControlVariable will be used in the new
 ForStatementSyntaxSyntax node.
 </param>
	<param name="equalsToken">
 The new EqualsToken to update this ForStatementSyntaxSyntax node with. If not
 specified the current EqualsToken will be used in the new
 ForStatementSyntaxSyntax node.
 </param>
	<param name="fromValue">
 The new FromValue to update this ForStatementSyntaxSyntax node with. If not
 specified the current FromValue will be used in the new
 ForStatementSyntaxSyntax node.
 </param>
	<param name="toKeyword">
 The new ToKeyword to update this ForStatementSyntaxSyntax node with. If not
 specified the current ToKeyword will be used in the new
 ForStatementSyntaxSyntax node.
 </param>
	<param name="toValue">
 The new ToValue to update this ForStatementSyntaxSyntax node with. If not
 specified the current ToValue will be used in the new ForStatementSyntaxSyntax
 node.
 </param>
	<param name="stepClause">
 The new StepClause to update this ForStatementSyntaxSyntax node with. If not
 specified the current StepClause will be used in the new
 ForStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ForStatementSyntax">
	<summary>
 The For statement that begins a For-Next block. This statement always occurs as
 the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForStepClauseSyntax.StepKeyword">
	<summary>
 The "Step" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForStepClauseSyntax.WithStepKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the StepKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForStepClauseSyntax.StepValue">
	<summary>
 The expression denoting the step increment.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForStepClauseSyntax.WithStepValue(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the StepValue property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForStepClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new ForStepClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="stepKeyword">
 The new StepKeyword to update this ForStepClauseSyntaxSyntax node with. If not
 specified the current StepKeyword will be used in the new
 ForStepClauseSyntaxSyntax node.
 </param>
	<param name="stepValue">
 The new StepValue to update this ForStepClauseSyntaxSyntax node with. If not
 specified the current StepValue will be used in the new
 ForStepClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ForStepClauseSyntax">
	<summary>
 The Step clause in a For Statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForEachStatementSyntax.ForKeyword">
	<summary>
 The "For" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForEachStatementSyntax.WithForKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ForKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForEachStatementSyntax.EachKeyword">
	<summary>
 The "Each" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForEachStatementSyntax.WithEachKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the EachKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForEachStatementSyntax.ControlVariable">
	<summary>
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForEachStatementSyntax.WithControlVariable(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Creates a new node and sets the ControlVariable property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForEachStatementSyntax.InKeyword">
	<summary>
 The "In" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForEachStatementSyntax.WithInKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the InKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForEachStatementSyntax.Expression">
	<summary>
 The expression denoting the collection to iterate over.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForEachStatementSyntax.WithExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Expression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForEachStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new ForEachStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="forKeyword">
 The new ForKeyword to update this ForEachStatementSyntaxSyntax node with. If
 not specified the current ForKeyword will be used in the new
 ForEachStatementSyntaxSyntax node.
 </param>
	<param name="eachKeyword">
 The new EachKeyword to update this ForEachStatementSyntaxSyntax node with. If
 not specified the current EachKeyword will be used in the new
 ForEachStatementSyntaxSyntax node.
 </param>
	<param name="controlVariable">
 The new ControlVariable to update this ForEachStatementSyntaxSyntax node with.
 If not specified the current ControlVariable will be used in the new
 ForEachStatementSyntaxSyntax node.
 </param>
	<param name="inKeyword">
 The new InKeyword to update this ForEachStatementSyntaxSyntax node with. If not
 specified the current InKeyword will be used in the new
 ForEachStatementSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this ForEachStatementSyntaxSyntax node with. If
 not specified the current Expression will be used in the new
 ForEachStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ForEachStatementSyntax">
	<summary>
 The For Each statement that begins a For Each-Next block. This statement always
 occurs as the Begin of a ForBlock, and the body of the For Each-Next is the
 Body of that ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NextStatementSyntax.NextKeyword">
	<summary>
 The "Next" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NextStatementSyntax.WithNextKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the NextKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.NextStatementSyntax.ControlVariables">
	<summary>
 The variables in the Next statement, if present
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.NextStatementSyntax.WithControlVariables(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionSyntax})">
	<summary>
 Creates a new node and sets the ControlVariables property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.NextStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionSyntax})">
	<summary>
 Creates a new NextStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="nextKeyword">
 The new NextKeyword to update this NextStatementSyntaxSyntax node with. If not
 specified the current NextKeyword will be used in the new
 NextStatementSyntaxSyntax node.
 </param>
	<param name="controlVariables">
 The new ControlVariables to update this NextStatementSyntaxSyntax node with. If
 not specified the current ControlVariables will be used in the new
 NextStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.NextStatementSyntax">
	<summary>
 The Next statement that ends a For-Next or For Each-Next block. This statement
 always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
 and the body of the For-Next is the Body of that ForBlock. The Begin of that
 ForBlock has the corresponding For or For Each statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.UsingStatementSyntax.UsingKeyword">
	<summary>
 The "Using" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.UsingStatementSyntax.WithUsingKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the UsingKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.UsingStatementSyntax.Expression">
	<summary>
 If the Using statement is of a form that does not declare a new variable, this
 is the expression used in the using. Otherwise, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.UsingStatementSyntax.WithExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Expression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.UsingStatementSyntax.Variables">
	<summary>
 If the Using statement is of a form that declares one or more new variables,
 this is the list of variable declarations. Otherwise, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.UsingStatementSyntax.WithVariables(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax})">
	<summary>
 Creates a new node and sets the Variables property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.UsingStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax})">
	<summary>
 Creates a new UsingStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="usingKeyword">
 The new UsingKeyword to update this UsingStatementSyntaxSyntax node with. If
 not specified the current UsingKeyword will be used in the new
 UsingStatementSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this UsingStatementSyntaxSyntax node with. If not
 specified the current Expression will be used in the new
 UsingStatementSyntaxSyntax node.
 </param>
	<param name="variables">
 The new Variables to update this UsingStatementSyntaxSyntax node with. If not
 specified the current Variables will be used in the new
 UsingStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.UsingStatementSyntax">
	<summary>
 The Using statement that begins a Using block. This statement always occurs as
 the Begin of a UsingBlock, and the body of the Using is the Body of that
 UsingBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ThrowStatementSyntax.ThrowKeyword">
	<summary>
 The "Throw" keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ThrowStatementSyntax.WithThrowKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ThrowKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ThrowStatementSyntax.Expression">
	<summary>
 The expression denoting the value being thrown.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ThrowStatementSyntax.WithExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Expression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ThrowStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new ThrowStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="throwKeyword">
 The new ThrowKeyword to update this ThrowStatementSyntaxSyntax node with. If
 not specified the current ThrowKeyword will be used in the new
 ThrowStatementSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this ThrowStatementSyntaxSyntax node with. If not
 specified the current Expression will be used in the new
 ThrowStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ThrowStatementSyntax">
	<summary>
 Represents a Throw statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssignmentStatementSyntax.Left">
	<summary>
 The target (left hand side) of the assignment.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssignmentStatementSyntax.WithLeft(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Left property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssignmentStatementSyntax.OperatorToken">
	<summary>
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssignmentStatementSyntax.WithOperatorToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OperatorToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssignmentStatementSyntax.Right">
	<summary>
 The source (right hand side) of the assignment.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssignmentStatementSyntax.WithRight(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Right property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssignmentStatementSyntax.Update(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new AssignmentStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="left">
 The new Left to update this AssignmentStatementSyntaxSyntax node with. If not
 specified the current Left will be used in the new
 AssignmentStatementSyntaxSyntax node.
 </param>
	<param name="operatorToken">
 The new OperatorToken to update this AssignmentStatementSyntaxSyntax node with.
 If not specified the current OperatorToken will be used in the new
 AssignmentStatementSyntaxSyntax node.
 </param>
	<param name="right">
 The new Right to update this AssignmentStatementSyntaxSyntax node with. If not
 specified the current Right will be used in the new
 AssignmentStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AssignmentStatementSyntax">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CallStatementSyntax.CallKeyword">
	<summary>
 The "Call" keyword, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CallStatementSyntax.WithCallKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CallKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CallStatementSyntax.Invocation">
	<summary>
 The expression denoting the call. This could be an Invocation or a MemberAccess
 (in the case where no parentheses were supplied.)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CallStatementSyntax.WithInvocation(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Invocation property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CallStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new CallStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="callKeyword">
 The new CallKeyword to update this CallStatementSyntaxSyntax node with. If not
 specified the current CallKeyword will be used in the new
 CallStatementSyntaxSyntax node.
 </param>
	<param name="invocation">
 The new Invocation to update this CallStatementSyntaxSyntax node with. If not
 specified the current Invocation will be used in the new
 CallStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CallStatementSyntax">
	<summary>
 Represent an call statement (also known as a invocation statement).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AddRemoveHandlerStatementSyntax.AddHandlerOrRemoveHandlerKeyword">
	<summary>
 The "AddHandler" or "RemoveHandler" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AddRemoveHandlerStatementSyntax.WithAddHandlerOrRemoveHandlerKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the AddHandlerOrRemoveHandlerKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AddRemoveHandlerStatementSyntax.EventExpression">
	<summary>
 The event being accessed.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AddRemoveHandlerStatementSyntax.WithEventExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the EventExpression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AddRemoveHandlerStatementSyntax.CommaToken">
	<summary>
 The "," token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AddRemoveHandlerStatementSyntax.WithCommaToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CommaToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AddRemoveHandlerStatementSyntax.DelegateExpression">
	<summary>
 The delegate being added or removed.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AddRemoveHandlerStatementSyntax.WithDelegateExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the DelegateExpression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AddRemoveHandlerStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new AddRemoveHandlerStatementSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="addHandlerOrRemoveHandlerKeyword">
 The new AddHandlerOrRemoveHandlerKeyword to update this
 AddRemoveHandlerStatementSyntaxSyntax node with. If not specified the current
 AddHandlerOrRemoveHandlerKeyword will be used in the new
 AddRemoveHandlerStatementSyntaxSyntax node.
 </param>
	<param name="eventExpression">
 The new EventExpression to update this AddRemoveHandlerStatementSyntaxSyntax
 node with. If not specified the current EventExpression will be used in the new
 AddRemoveHandlerStatementSyntaxSyntax node.
 </param>
	<param name="commaToken">
 The new CommaToken to update this AddRemoveHandlerStatementSyntaxSyntax node
 with. If not specified the current CommaToken will be used in the new
 AddRemoveHandlerStatementSyntaxSyntax node.
 </param>
	<param name="delegateExpression">
 The new DelegateExpression to update this AddRemoveHandlerStatementSyntaxSyntax
 node with. If not specified the current DelegateExpression will be used in the
 new AddRemoveHandlerStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AddRemoveHandlerStatementSyntax">
	<summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RaiseEventStatementSyntax.RaiseEventKeyword">
	<summary>
 The "RaiseEvent" keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.RaiseEventStatementSyntax.WithRaiseEventKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the RaiseEventKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.RaiseEventStatementSyntax.Name">
	<summary>
 The name of the event being raised.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.RaiseEventStatementSyntax.WithName(Roslyn.Compilers.VisualBasic.IdentifierNameSyntax)">
	<summary>
 Creates a new node and sets the Name property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.RaiseEventStatementSyntax.ArgumentList">
	<summary>
 The argument list, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.RaiseEventStatementSyntax.WithArgumentList(Roslyn.Compilers.VisualBasic.ArgumentListSyntax)">
	<summary>
 Creates a new node and sets the ArgumentList property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.RaiseEventStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.IdentifierNameSyntax,Roslyn.Compilers.VisualBasic.ArgumentListSyntax)">
	<summary>
 Creates a new RaiseEventStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="raiseEventKeyword">
 The new RaiseEventKeyword to update this RaiseEventStatementSyntaxSyntax node
 with. If not specified the current RaiseEventKeyword will be used in the new
 RaiseEventStatementSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this RaiseEventStatementSyntaxSyntax node with. If not
 specified the current Name will be used in the new
 RaiseEventStatementSyntaxSyntax node.
 </param>
	<param name="argumentList">
 The new ArgumentList to update this RaiseEventStatementSyntaxSyntax node with.
 If not specified the current ArgumentList will be used in the new
 RaiseEventStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.RaiseEventStatementSyntax">
	<summary>
 Represent a RaiseEvent statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WithStatementSyntax.WithKeyword">
	<summary>
 The "With" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.WithStatementSyntax.WithWithKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the WithKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.WithStatementSyntax.Expression">
	<summary>
 The expression that is the operand of the With statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.WithStatementSyntax.WithExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Expression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.WithStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new WithStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="withKeyword">
 The new WithKeyword to update this WithStatementSyntaxSyntax node with. If not
 specified the current WithKeyword will be used in the new
 WithStatementSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this WithStatementSyntaxSyntax node with. If not
 specified the current Expression will be used in the new
 WithStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.WithStatementSyntax">
	<summary>
 Represents a "With" statement. This statement always occurs as the
 BeginStatement of a WithBlock, and the body of the With is the Body of that
 WithBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ReDimStatementSyntax.ReDimKeyword">
	<summary>
 The "ReDim" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ReDimStatementSyntax.WithReDimKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ReDimKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ReDimStatementSyntax.PreserveKeyword">
	<summary>
 Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
 Kind=RedimPreserve.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ReDimStatementSyntax.WithPreserveKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the PreserveKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ReDimStatementSyntax.Clauses">
	<summary>
 The list of ReDim clauses. Each clause is a Invocation node with an argument
 list denoting the new bounds for the array.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ReDimStatementSyntax.WithClauses(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax})">
	<summary>
 Creates a new node and sets the Clauses property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ReDimStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax})">
	<summary>
 Creates a new ReDimStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="reDimKeyword">
 The new ReDimKeyword to update this ReDimStatementSyntaxSyntax node with. If
 not specified the current ReDimKeyword will be used in the new
 ReDimStatementSyntaxSyntax node.
 </param>
	<param name="preserveKeyword">
 The new PreserveKeyword to update this ReDimStatementSyntaxSyntax node with. If
 not specified the current PreserveKeyword will be used in the new
 ReDimStatementSyntaxSyntax node.
 </param>
	<param name="clauses">
 The new Clauses to update this ReDimStatementSyntaxSyntax node with. If not
 specified the current Clauses will be used in the new
 ReDimStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ReDimStatementSyntax">
	<summary>
 Represents a ReDim statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EraseStatementSyntax.EraseKeyword">
	<summary>
 The "Erase" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EraseStatementSyntax.WithEraseKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the EraseKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EraseStatementSyntax.Expressions">
	<summary>
 A list of expressions denoting the arrays to erase.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EraseStatementSyntax.WithExpressions(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionSyntax})">
	<summary>
 Creates a new node and sets the Expressions property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EraseStatementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionSyntax})">
	<summary>
 Creates a new EraseStatementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="eraseKeyword">
 The new EraseKeyword to update this EraseStatementSyntaxSyntax node with. If
 not specified the current EraseKeyword will be used in the new
 EraseStatementSyntaxSyntax node.
 </param>
	<param name="expressions">
 The new Expressions to update this EraseStatementSyntaxSyntax node with. If not
 specified the current Expressions will be used in the new
 EraseStatementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.EraseStatementSyntax">
	<summary>
 Represents an "Erase" statement.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ExpressionSyntax">
	<summary>
 An abstract base class for all node classes that define expressions.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax.Token">
	<summary>
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax.WithToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Token property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new LiteralExpressionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="token">
 The new Token to update this LiteralExpressionSyntaxSyntax node with. If not
 specified the current Token will be used in the new
 LiteralExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParenthesizedExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ParenthesizedExpressionSyntax.WithOpenParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OpenParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParenthesizedExpressionSyntax.Expression">
	<summary>
 The expression inside the parentheses.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ParenthesizedExpressionSyntax.WithExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Expression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParenthesizedExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ParenthesizedExpressionSyntax.WithCloseParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CloseParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ParenthesizedExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new ParenthesizedExpressionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="openParenToken">
 The new OpenParenToken to update this ParenthesizedExpressionSyntaxSyntax node
 with. If not specified the current OpenParenToken will be used in the new
 ParenthesizedExpressionSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this ParenthesizedExpressionSyntaxSyntax node
 with. If not specified the current Expression will be used in the new
 ParenthesizedExpressionSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this ParenthesizedExpressionSyntaxSyntax node
 with. If not specified the current CloseParenToken will be used in the new
 ParenthesizedExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ParenthesizedExpressionSyntax">
	<summary>
 Represents a parenthesized expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InstanceExpressionSyntax.Keyword">
	<summary>
 The "Me", "MyClass" or "MyBase" keyword.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InstanceExpressionSyntax">
	<summary>
 Identifies one of the special instances "Me", "MyClass" or "MyBase". The Kind
 property identifies which.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MeExpressionSyntax.Keyword">
	<summary>
 The "Me", "MyClass" or "MyBase" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MeExpressionSyntax.WithKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Keyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MeExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new MeExpressionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="keyword">
 The new Keyword to update this MeExpressionSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new MeExpressionSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.MeExpressionSyntax">
	<summary>
 Identifies the special instance "Me"
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MyBaseExpressionSyntax.Keyword">
	<summary>
 The "Me", "MyClass" or "MyBase" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MyBaseExpressionSyntax.WithKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Keyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MyBaseExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new MyBaseExpressionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="keyword">
 The new Keyword to update this MyBaseExpressionSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 MyBaseExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.MyBaseExpressionSyntax">
	<summary>
 Identifies the special instance "MyBase"
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MyClassExpressionSyntax.Keyword">
	<summary>
 The "Me", "MyClass" or "MyBase" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MyClassExpressionSyntax.WithKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Keyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MyClassExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new MyClassExpressionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="keyword">
 The new Keyword to update this MyClassExpressionSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 MyClassExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.MyClassExpressionSyntax">
	<summary>
 Identifies the special instance "MyClass"
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GetTypeExpressionSyntax.GetTypeKeyword">
	<summary>
 The "GetType" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GetTypeExpressionSyntax.WithGetTypeKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the GetTypeKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.GetTypeExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GetTypeExpressionSyntax.WithOpenParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OpenParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.GetTypeExpressionSyntax.Type">
	<summary>
 The type to get the Type object for. This can be an open generic type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GetTypeExpressionSyntax.WithType(Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Creates a new node and sets the Type property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.GetTypeExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GetTypeExpressionSyntax.WithCloseParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CloseParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.GetTypeExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new GetTypeExpressionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="getTypeKeyword">
 The new GetTypeKeyword to update this GetTypeExpressionSyntaxSyntax node with.
 If not specified the current GetTypeKeyword will be used in the new
 GetTypeExpressionSyntaxSyntax node.
 </param>
	<param name="openParenToken">
 The new OpenParenToken to update this GetTypeExpressionSyntaxSyntax node with.
 If not specified the current OpenParenToken will be used in the new
 GetTypeExpressionSyntaxSyntax node.
 </param>
	<param name="type">
 The new Type to update this GetTypeExpressionSyntaxSyntax node with. If not
 specified the current Type will be used in the new
 GetTypeExpressionSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this GetTypeExpressionSyntaxSyntax node with.
 If not specified the current CloseParenToken will be used in the new
 GetTypeExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.GetTypeExpressionSyntax">
	<summary>
 Represents a GetType expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeOfExpressionSyntax.TypeOfKeyword">
	<summary>
 The "TypeOf" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeOfExpressionSyntax.WithTypeOfKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the TypeOfKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeOfExpressionSyntax.Expression">
	<summary>
 The expression being tested.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeOfExpressionSyntax.WithExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Expression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeOfExpressionSyntax.OperatorToken">
	<summary>
 The "Is" or "IsNot" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeOfExpressionSyntax.WithOperatorToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OperatorToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeOfExpressionSyntax.Type">
	<summary>
 The name of the type being tested against.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeOfExpressionSyntax.WithType(Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Creates a new node and sets the Type property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeOfExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Creates a new TypeOfExpressionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="typeOfKeyword">
 The new TypeOfKeyword to update this TypeOfExpressionSyntaxSyntax node with. If
 not specified the current TypeOfKeyword will be used in the new
 TypeOfExpressionSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this TypeOfExpressionSyntaxSyntax node with. If
 not specified the current Expression will be used in the new
 TypeOfExpressionSyntaxSyntax node.
 </param>
	<param name="operatorToken">
 The new OperatorToken to update this TypeOfExpressionSyntaxSyntax node with. If
 not specified the current OperatorToken will be used in the new
 TypeOfExpressionSyntaxSyntax node.
 </param>
	<param name="type">
 The new Type to update this TypeOfExpressionSyntaxSyntax node with. If not
 specified the current Type will be used in the new TypeOfExpressionSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeOfExpressionSyntax">
	<summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GetXmlNamespaceExpressionSyntax.GetXmlNamespaceKeyword">
	<summary>
 The "GetXmlNamespace" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GetXmlNamespaceExpressionSyntax.WithGetXmlNamespaceKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the GetXmlNamespaceKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.GetXmlNamespaceExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GetXmlNamespaceExpressionSyntax.WithOpenParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OpenParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.GetXmlNamespaceExpressionSyntax.Name">
	<summary>
 The Xml namespace name being referenced.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.GetXmlNamespaceExpressionSyntax.WithName(Roslyn.Compilers.VisualBasic.XmlPrefixNameSyntax)">
	<summary>
 Creates a new node and sets the Name property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.GetXmlNamespaceExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GetXmlNamespaceExpressionSyntax.WithCloseParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CloseParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.GetXmlNamespaceExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlPrefixNameSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new GetXmlNamespaceExpressionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="getXmlNamespaceKeyword">
 The new GetXmlNamespaceKeyword to update this
 GetXmlNamespaceExpressionSyntaxSyntax node with. If not specified the current
 GetXmlNamespaceKeyword will be used in the new
 GetXmlNamespaceExpressionSyntaxSyntax node.
 </param>
	<param name="openParenToken">
 The new OpenParenToken to update this GetXmlNamespaceExpressionSyntaxSyntax
 node with. If not specified the current OpenParenToken will be used in the new
 GetXmlNamespaceExpressionSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this GetXmlNamespaceExpressionSyntaxSyntax node with. If
 not specified the current Name will be used in the new
 GetXmlNamespaceExpressionSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this GetXmlNamespaceExpressionSyntaxSyntax
 node with. If not specified the current CloseParenToken will be used in the new
 GetXmlNamespaceExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.GetXmlNamespaceExpressionSyntax">
	<summary>
 Represents a GetXmlNamespace expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MemberAccessExpressionSyntax.Expression">
	<summary>
 The expression on the left-hand-side of the "." or "!" token.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberAccessExpressionSyntax.WithExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Expression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MemberAccessExpressionSyntax.OperatorToken">
	<summary>
 The "." or "!" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberAccessExpressionSyntax.WithOperatorToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OperatorToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MemberAccessExpressionSyntax.Name">
	<summary>
 The identifier after the "." or "!" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberAccessExpressionSyntax.WithName(Roslyn.Compilers.VisualBasic.SimpleNameSyntax)">
	<summary>
 Creates a new node and sets the Name property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberAccessExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SimpleNameSyntax)">
	<summary>
 Creates a new MemberAccessExpressionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="expression">
 The new Expression to update this MemberAccessExpressionSyntaxSyntax node with.
 If not specified the current Expression will be used in the new
 MemberAccessExpressionSyntaxSyntax node.
 </param>
	<param name="operatorToken">
 The new OperatorToken to update this MemberAccessExpressionSyntaxSyntax node
 with. If not specified the current OperatorToken will be used in the new
 MemberAccessExpressionSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this MemberAccessExpressionSyntaxSyntax node with. If
 not specified the current Name will be used in the new
 MemberAccessExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.MemberAccessExpressionSyntax">
	<summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlMemberAccessExpressionSyntax.Base">
	<summary>
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlMemberAccessExpressionSyntax.WithBase(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Base property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlMemberAccessExpressionSyntax.Token1">
	<summary>
 The initial dot "." part of the separator.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlMemberAccessExpressionSyntax.WithToken1(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Token1 property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlMemberAccessExpressionSyntax.Token2">
	<summary>
 The "@" part of .@ or the second "." of "...".
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlMemberAccessExpressionSyntax.WithToken2(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Token2 property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlMemberAccessExpressionSyntax.Token3">
	<summary>
 The third "." in a "..." separator.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlMemberAccessExpressionSyntax.WithToken3(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Token3 property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlMemberAccessExpressionSyntax.Name">
	<summary>
 The identifier after the ".", ".@" or "..."
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlMemberAccessExpressionSyntax.WithName(Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Creates a new node and sets the Name property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlMemberAccessExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Creates a new XmlMemberAccessExpressionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="base">
 The new Base to update this XmlMemberAccessExpressionSyntaxSyntax node with. If
 not specified the current Base will be used in the new
 XmlMemberAccessExpressionSyntaxSyntax node.
 </param>
	<param name="token1">
 The new Token1 to update this XmlMemberAccessExpressionSyntaxSyntax node with.
 If not specified the current Token1 will be used in the new
 XmlMemberAccessExpressionSyntaxSyntax node.
 </param>
	<param name="token2">
 The new Token2 to update this XmlMemberAccessExpressionSyntaxSyntax node with.
 If not specified the current Token2 will be used in the new
 XmlMemberAccessExpressionSyntaxSyntax node.
 </param>
	<param name="token3">
 The new Token3 to update this XmlMemberAccessExpressionSyntaxSyntax node with.
 If not specified the current Token3 will be used in the new
 XmlMemberAccessExpressionSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this XmlMemberAccessExpressionSyntaxSyntax node with. If
 not specified the current Name will be used in the new
 XmlMemberAccessExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlMemberAccessExpressionSyntax">
	<summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax.Expression">
	<summary>
 The target of the call or index expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax.WithExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Expression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax.ArgumentList">
	<summary>
 The argument list.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax.WithArgumentList(Roslyn.Compilers.VisualBasic.ArgumentListSyntax)">
	<summary>
 Creates a new node and sets the ArgumentList property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ArgumentListSyntax)">
	<summary>
 Creates a new InvocationExpressionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="expression">
 The new Expression to update this InvocationExpressionSyntaxSyntax node with.
 If not specified the current Expression will be used in the new
 InvocationExpressionSyntaxSyntax node.
 </param>
	<param name="argumentList">
 The new ArgumentList to update this InvocationExpressionSyntaxSyntax node with.
 If not specified the current ArgumentList will be used in the new
 InvocationExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax">
	<summary>
 Represents an invocation expression consisting of an invocation target and an
 optional argument list or an array, parameterized property or object default
 property index.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NewExpressionSyntax.NewKeyword">
	<summary>
 The "New" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NewExpressionSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.NewExpressionSyntax">
	<summary>
 Base class for object, array and anonymous object creation expressions
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ObjectCreationExpressionSyntax.NewKeyword">
	<summary>
 The "New" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ObjectCreationExpressionSyntax.WithNewKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the NewKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ObjectCreationExpressionSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ObjectCreationExpressionSyntax.WithAttributeLists(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Creates a new node and sets the AttributeLists property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ObjectCreationExpressionSyntax.Type">
	<summary>
 The type of the object being initialized.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ObjectCreationExpressionSyntax.WithType(Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Creates a new node and sets the Type property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ObjectCreationExpressionSyntax.ArgumentList">
	<summary>
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ObjectCreationExpressionSyntax.WithArgumentList(Roslyn.Compilers.VisualBasic.ArgumentListSyntax)">
	<summary>
 Creates a new node and sets the ArgumentList property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ObjectCreationExpressionSyntax.Initializer">
	<summary>
 An optional From or With clause to initialize the new object.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ObjectCreationExpressionSyntax.WithInitializer(Roslyn.Compilers.VisualBasic.ObjectCreationInitializerSyntax)">
	<summary>
 Creates a new node and sets the Initializer property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ObjectCreationExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.ArgumentListSyntax,Roslyn.Compilers.VisualBasic.ObjectCreationInitializerSyntax)">
	<summary>
 Creates a new ObjectCreationExpressionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="newKeyword">
 The new NewKeyword to update this ObjectCreationExpressionSyntaxSyntax node
 with. If not specified the current NewKeyword will be used in the new
 ObjectCreationExpressionSyntaxSyntax node.
 </param>
	<param name="attributeLists">
 The new AttributeLists to update this ObjectCreationExpressionSyntaxSyntax node
 with. If not specified the current AttributeLists will be used in the new
 ObjectCreationExpressionSyntaxSyntax node.
 </param>
	<param name="type">
 The new Type to update this ObjectCreationExpressionSyntaxSyntax node with. If
 not specified the current Type will be used in the new
 ObjectCreationExpressionSyntaxSyntax node.
 </param>
	<param name="argumentList">
 The new ArgumentList to update this ObjectCreationExpressionSyntaxSyntax node
 with. If not specified the current ArgumentList will be used in the new
 ObjectCreationExpressionSyntaxSyntax node.
 </param>
	<param name="initializer">
 The new Initializer to update this ObjectCreationExpressionSyntaxSyntax node
 with. If not specified the current Initializer will be used in the new
 ObjectCreationExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ObjectCreationExpressionSyntax">
	<summary>
 Represents a New expression that creates a new non-array object, possibly with
 a "With" or "From" clause.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AnonymousObjectCreationExpressionSyntax.NewKeyword">
	<summary>
 The "New" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AnonymousObjectCreationExpressionSyntax.WithNewKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the NewKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AnonymousObjectCreationExpressionSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AnonymousObjectCreationExpressionSyntax.WithAttributeLists(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Creates a new node and sets the AttributeLists property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AnonymousObjectCreationExpressionSyntax.Initializer">
	<summary>
 The With clause to initialize the new object.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AnonymousObjectCreationExpressionSyntax.WithInitializer(Roslyn.Compilers.VisualBasic.ObjectMemberInitializerSyntax)">
	<summary>
 Creates a new node and sets the Initializer property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AnonymousObjectCreationExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.ObjectMemberInitializerSyntax)">
	<summary>
 Creates a new AnonymousObjectCreationExpressionSyntaxSyntax node with the
 specified changes.
 </summary>
	<param name="newKeyword">
 The new NewKeyword to update this AnonymousObjectCreationExpressionSyntaxSyntax
 node with. If not specified the current NewKeyword will be used in the new
 AnonymousObjectCreationExpressionSyntaxSyntax node.
 </param>
	<param name="attributeLists">
 The new AttributeLists to update this
 AnonymousObjectCreationExpressionSyntaxSyntax node with. If not specified the
 current AttributeLists will be used in the new
 AnonymousObjectCreationExpressionSyntaxSyntax node.
 </param>
	<param name="initializer">
 The new Initializer to update this
 AnonymousObjectCreationExpressionSyntaxSyntax node with. If not specified the
 current Initializer will be used in the new
 AnonymousObjectCreationExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AnonymousObjectCreationExpressionSyntax">
	<summary>
 Represents a New expression that create an object of anonymous type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax.NewKeyword">
	<summary>
 The "New" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax.WithNewKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the NewKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax.WithAttributeLists(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Creates a new node and sets the AttributeLists property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax.Type">
	<summary>
 The element type of the array being created.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax.WithType(Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Creates a new node and sets the Type property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax.ArrayBounds">
	<summary>
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax.WithArrayBounds(Roslyn.Compilers.VisualBasic.ArgumentListSyntax)">
	<summary>
 Creates a new node and sets the ArrayBounds property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax.RankSpecifiers">
	<summary>
 A list of array modifiers such as "()" or "(,)". If no array modifiers were
 present, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax.WithRankSpecifiers(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax})">
	<summary>
 Creates a new node and sets the RankSpecifiers property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax.Initializer">
	<summary>
 The initializer including the braces.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax.WithInitializer(Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax)">
	<summary>
 Creates a new node and sets the Initializer property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.ArgumentListSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax},Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax)">
	<summary>
 Creates a new ArrayCreationExpressionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="newKeyword">
 The new NewKeyword to update this ArrayCreationExpressionSyntaxSyntax node
 with. If not specified the current NewKeyword will be used in the new
 ArrayCreationExpressionSyntaxSyntax node.
 </param>
	<param name="attributeLists">
 The new AttributeLists to update this ArrayCreationExpressionSyntaxSyntax node
 with. If not specified the current AttributeLists will be used in the new
 ArrayCreationExpressionSyntaxSyntax node.
 </param>
	<param name="type">
 The new Type to update this ArrayCreationExpressionSyntaxSyntax node with. If
 not specified the current Type will be used in the new
 ArrayCreationExpressionSyntaxSyntax node.
 </param>
	<param name="arrayBounds">
 The new ArrayBounds to update this ArrayCreationExpressionSyntaxSyntax node
 with. If not specified the current ArrayBounds will be used in the new
 ArrayCreationExpressionSyntaxSyntax node.
 </param>
	<param name="rankSpecifiers">
 The new RankSpecifiers to update this ArrayCreationExpressionSyntaxSyntax node
 with. If not specified the current RankSpecifiers will be used in the new
 ArrayCreationExpressionSyntaxSyntax node.
 </param>
	<param name="initializer">
 The new Initializer to update this ArrayCreationExpressionSyntaxSyntax node
 with. If not specified the current Initializer will be used in the new
 ArrayCreationExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax">
	<summary>
 Represents an expression that creates a new array.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax.OpenBraceToken">
	<summary>
 The "{" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax.WithOpenBraceToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OpenBraceToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax.Initializers">
	<summary>
 The list of initializers between the braces.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax.WithInitializers(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionSyntax})">
	<summary>
 Creates a new node and sets the Initializers property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax.CloseBraceToken">
	<summary>
 The "}" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax.WithCloseBraceToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CloseBraceToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new CollectionInitializerSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="openBraceToken">
 The new OpenBraceToken to update this CollectionInitializerSyntaxSyntax node
 with. If not specified the current OpenBraceToken will be used in the new
 CollectionInitializerSyntaxSyntax node.
 </param>
	<param name="initializers">
 The new Initializers to update this CollectionInitializerSyntaxSyntax node
 with. If not specified the current Initializers will be used in the new
 CollectionInitializerSyntaxSyntax node.
 </param>
	<param name="closeBraceToken">
 The new CloseBraceToken to update this CollectionInitializerSyntaxSyntax node
 with. If not specified the current CloseBraceToken will be used in the new
 CollectionInitializerSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax">
	<summary>
 Represents an expression that creates a new array without naming the element
 type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CastExpressionSyntax.Keyword">
	<summary>
 The "CType", "DirectCast" or "TryCast" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CastExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CastExpressionSyntax.Expression">
	<summary>
 The expression being cast.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CastExpressionSyntax.CommaToken">
	<summary>
 The "," token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CastExpressionSyntax.Type">
	<summary>
 The type the expression is being cast to.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CastExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.CastExpressionSyntax">
	<summary>
 Represents a CType, DirectCast or TryCast conversion expression. The Kind
 property determines which kind of cast it is.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CTypeExpressionSyntax.Keyword">
	<summary>
 The "CType", "DirectCast" or "TryCast" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CTypeExpressionSyntax.WithKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Keyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CTypeExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CTypeExpressionSyntax.WithOpenParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OpenParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CTypeExpressionSyntax.Expression">
	<summary>
 The expression being cast.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CTypeExpressionSyntax.WithExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Expression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CTypeExpressionSyntax.CommaToken">
	<summary>
 The "," token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CTypeExpressionSyntax.WithCommaToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CommaToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CTypeExpressionSyntax.Type">
	<summary>
 The type the expression is being cast to.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CTypeExpressionSyntax.WithType(Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Creates a new node and sets the Type property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CTypeExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CTypeExpressionSyntax.WithCloseParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CloseParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CTypeExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new CTypeExpressionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="keyword">
 The new Keyword to update this CTypeExpressionSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 CTypeExpressionSyntaxSyntax node.
 </param>
	<param name="openParenToken">
 The new OpenParenToken to update this CTypeExpressionSyntaxSyntax node with. If
 not specified the current OpenParenToken will be used in the new
 CTypeExpressionSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this CTypeExpressionSyntaxSyntax node with. If not
 specified the current Expression will be used in the new
 CTypeExpressionSyntaxSyntax node.
 </param>
	<param name="commaToken">
 The new CommaToken to update this CTypeExpressionSyntaxSyntax node with. If not
 specified the current CommaToken will be used in the new
 CTypeExpressionSyntaxSyntax node.
 </param>
	<param name="type">
 The new Type to update this CTypeExpressionSyntaxSyntax node with. If not
 specified the current Type will be used in the new CTypeExpressionSyntaxSyntax
 node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this CTypeExpressionSyntaxSyntax node with.
 If not specified the current CloseParenToken will be used in the new
 CTypeExpressionSyntaxSyntax node.
 </param>
</member><member name="P:Roslyn.Compilers.VisualBasic.DirectCastExpressionSyntax.Keyword">
	<summary>
 The "CType", "DirectCast" or "TryCast" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DirectCastExpressionSyntax.WithKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Keyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DirectCastExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DirectCastExpressionSyntax.WithOpenParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OpenParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DirectCastExpressionSyntax.Expression">
	<summary>
 The expression being cast.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DirectCastExpressionSyntax.WithExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Expression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DirectCastExpressionSyntax.CommaToken">
	<summary>
 The "," token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DirectCastExpressionSyntax.WithCommaToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CommaToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DirectCastExpressionSyntax.Type">
	<summary>
 The type the expression is being cast to.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DirectCastExpressionSyntax.WithType(Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Creates a new node and sets the Type property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DirectCastExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DirectCastExpressionSyntax.WithCloseParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CloseParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DirectCastExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new DirectCastExpressionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="keyword">
 The new Keyword to update this DirectCastExpressionSyntaxSyntax node with. If
 not specified the current Keyword will be used in the new
 DirectCastExpressionSyntaxSyntax node.
 </param>
	<param name="openParenToken">
 The new OpenParenToken to update this DirectCastExpressionSyntaxSyntax node
 with. If not specified the current OpenParenToken will be used in the new
 DirectCastExpressionSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this DirectCastExpressionSyntaxSyntax node with.
 If not specified the current Expression will be used in the new
 DirectCastExpressionSyntaxSyntax node.
 </param>
	<param name="commaToken">
 The new CommaToken to update this DirectCastExpressionSyntaxSyntax node with.
 If not specified the current CommaToken will be used in the new
 DirectCastExpressionSyntaxSyntax node.
 </param>
	<param name="type">
 The new Type to update this DirectCastExpressionSyntaxSyntax node with. If not
 specified the current Type will be used in the new
 DirectCastExpressionSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this DirectCastExpressionSyntaxSyntax node
 with. If not specified the current CloseParenToken will be used in the new
 DirectCastExpressionSyntaxSyntax node.
 </param>
</member><member name="P:Roslyn.Compilers.VisualBasic.TryCastExpressionSyntax.Keyword">
	<summary>
 The "CType", "DirectCast" or "TryCast" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TryCastExpressionSyntax.WithKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Keyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TryCastExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TryCastExpressionSyntax.WithOpenParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OpenParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TryCastExpressionSyntax.Expression">
	<summary>
 The expression being cast.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TryCastExpressionSyntax.WithExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Expression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TryCastExpressionSyntax.CommaToken">
	<summary>
 The "," token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TryCastExpressionSyntax.WithCommaToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CommaToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TryCastExpressionSyntax.Type">
	<summary>
 The type the expression is being cast to.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TryCastExpressionSyntax.WithType(Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Creates a new node and sets the Type property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TryCastExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TryCastExpressionSyntax.WithCloseParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CloseParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TryCastExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new TryCastExpressionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="keyword">
 The new Keyword to update this TryCastExpressionSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 TryCastExpressionSyntaxSyntax node.
 </param>
	<param name="openParenToken">
 The new OpenParenToken to update this TryCastExpressionSyntaxSyntax node with.
 If not specified the current OpenParenToken will be used in the new
 TryCastExpressionSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this TryCastExpressionSyntaxSyntax node with. If
 not specified the current Expression will be used in the new
 TryCastExpressionSyntaxSyntax node.
 </param>
	<param name="commaToken">
 The new CommaToken to update this TryCastExpressionSyntaxSyntax node with. If
 not specified the current CommaToken will be used in the new
 TryCastExpressionSyntaxSyntax node.
 </param>
	<param name="type">
 The new Type to update this TryCastExpressionSyntaxSyntax node with. If not
 specified the current Type will be used in the new
 TryCastExpressionSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this TryCastExpressionSyntaxSyntax node with.
 If not specified the current CloseParenToken will be used in the new
 TryCastExpressionSyntaxSyntax node.
 </param>
</member><member name="P:Roslyn.Compilers.VisualBasic.PredefinedCastExpressionSyntax.Keyword">
	<summary>
 The keyword that was used in the cast operation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PredefinedCastExpressionSyntax.WithKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Keyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.PredefinedCastExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PredefinedCastExpressionSyntax.WithOpenParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OpenParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.PredefinedCastExpressionSyntax.Expression">
	<summary>
 The expression being cast.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PredefinedCastExpressionSyntax.WithExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Expression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.PredefinedCastExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PredefinedCastExpressionSyntax.WithCloseParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CloseParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.PredefinedCastExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new PredefinedCastExpressionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="keyword">
 The new Keyword to update this PredefinedCastExpressionSyntaxSyntax node with.
 If not specified the current Keyword will be used in the new
 PredefinedCastExpressionSyntaxSyntax node.
 </param>
	<param name="openParenToken">
 The new OpenParenToken to update this PredefinedCastExpressionSyntaxSyntax node
 with. If not specified the current OpenParenToken will be used in the new
 PredefinedCastExpressionSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this PredefinedCastExpressionSyntaxSyntax node
 with. If not specified the current Expression will be used in the new
 PredefinedCastExpressionSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this PredefinedCastExpressionSyntaxSyntax
 node with. If not specified the current CloseParenToken will be used in the new
 PredefinedCastExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.PredefinedCastExpressionSyntax">
	<summary>
 Represents a cast to a pre-defined type using a pre-defined cast expression,
 such as CInt or CLng.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BinaryExpressionSyntax.Left">
	<summary>
 The left operand.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinaryExpressionSyntax.WithLeft(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Left property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinaryExpressionSyntax.WithOperatorToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OperatorToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.BinaryExpressionSyntax.Right">
	<summary>
 The right operand.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinaryExpressionSyntax.WithRight(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Right property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinaryExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new BinaryExpressionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="left">
 The new Left to update this BinaryExpressionSyntaxSyntax node with. If not
 specified the current Left will be used in the new BinaryExpressionSyntaxSyntax
 node.
 </param>
	<param name="operatorToken">
 The new OperatorToken to update this BinaryExpressionSyntaxSyntax node with. If
 not specified the current OperatorToken will be used in the new
 BinaryExpressionSyntaxSyntax node.
 </param>
	<param name="right">
 The new Right to update this BinaryExpressionSyntaxSyntax node with. If not
 specified the current Right will be used in the new
 BinaryExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.BinaryExpressionSyntax">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.UnaryExpressionSyntax.OperatorToken">
	<summary>
 The token that is the operator.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.UnaryExpressionSyntax.WithOperatorToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OperatorToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.UnaryExpressionSyntax.Operand">
	<summary>
 The expression being operated on.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.UnaryExpressionSyntax.WithOperand(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Operand property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.UnaryExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new UnaryExpressionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="operatorToken">
 The new OperatorToken to update this UnaryExpressionSyntaxSyntax node with. If
 not specified the current OperatorToken will be used in the new
 UnaryExpressionSyntaxSyntax node.
 </param>
	<param name="operand">
 The new Operand to update this UnaryExpressionSyntaxSyntax node with. If not
 specified the current Operand will be used in the new
 UnaryExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.UnaryExpressionSyntax">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BinaryConditionalExpressionSyntax.IfKeyword">
	<summary>
 The "If" keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinaryConditionalExpressionSyntax.WithIfKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the IfKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.BinaryConditionalExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinaryConditionalExpressionSyntax.WithOpenParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OpenParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.BinaryConditionalExpressionSyntax.FirstExpression">
	<summary>
 The first expression inside the parentheses.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinaryConditionalExpressionSyntax.WithFirstExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the FirstExpression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.BinaryConditionalExpressionSyntax.CommaToken">
	<summary>
 The "," token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinaryConditionalExpressionSyntax.WithCommaToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CommaToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.BinaryConditionalExpressionSyntax.SecondExpression">
	<summary>
 The second expression inside the parentheses.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinaryConditionalExpressionSyntax.WithSecondExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the SecondExpression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.BinaryConditionalExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinaryConditionalExpressionSyntax.WithCloseParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CloseParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinaryConditionalExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new BinaryConditionalExpressionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="ifKeyword">
 The new IfKeyword to update this BinaryConditionalExpressionSyntaxSyntax node
 with. If not specified the current IfKeyword will be used in the new
 BinaryConditionalExpressionSyntaxSyntax node.
 </param>
	<param name="openParenToken">
 The new OpenParenToken to update this BinaryConditionalExpressionSyntaxSyntax
 node with. If not specified the current OpenParenToken will be used in the new
 BinaryConditionalExpressionSyntaxSyntax node.
 </param>
	<param name="firstExpression">
 The new FirstExpression to update this BinaryConditionalExpressionSyntaxSyntax
 node with. If not specified the current FirstExpression will be used in the new
 BinaryConditionalExpressionSyntaxSyntax node.
 </param>
	<param name="commaToken">
 The new CommaToken to update this BinaryConditionalExpressionSyntaxSyntax node
 with. If not specified the current CommaToken will be used in the new
 BinaryConditionalExpressionSyntaxSyntax node.
 </param>
	<param name="secondExpression">
 The new SecondExpression to update this BinaryConditionalExpressionSyntaxSyntax
 node with. If not specified the current SecondExpression will be used in the
 new BinaryConditionalExpressionSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this BinaryConditionalExpressionSyntaxSyntax
 node with. If not specified the current CloseParenToken will be used in the new
 BinaryConditionalExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.BinaryConditionalExpressionSyntax">
	<summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.IfKeyword">
	<summary>
 The "If" keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.WithIfKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the IfKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.WithOpenParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OpenParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.Condition">
	<summary>
 The first expression inside the parentheses.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.WithCondition(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Condition property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.FirstCommaToken">
	<summary>
 The "," token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.WithFirstCommaToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the FirstCommaToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.WhenTrue">
	<summary>
 The second expression inside the parentheses.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.WithWhenTrue(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the WhenTrue property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.SecondCommaToken">
	<summary>
 The "," token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.WithSecondCommaToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the SecondCommaToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.WhenFalse">
	<summary>
 The second expression inside the parentheses.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.WithWhenFalse(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the WhenFalse property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.WithCloseParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CloseParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new TernaryConditionalExpressionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="ifKeyword">
 The new IfKeyword to update this TernaryConditionalExpressionSyntaxSyntax node
 with. If not specified the current IfKeyword will be used in the new
 TernaryConditionalExpressionSyntaxSyntax node.
 </param>
	<param name="openParenToken">
 The new OpenParenToken to update this TernaryConditionalExpressionSyntaxSyntax
 node with. If not specified the current OpenParenToken will be used in the new
 TernaryConditionalExpressionSyntaxSyntax node.
 </param>
	<param name="condition">
 The new Condition to update this TernaryConditionalExpressionSyntaxSyntax node
 with. If not specified the current Condition will be used in the new
 TernaryConditionalExpressionSyntaxSyntax node.
 </param>
	<param name="firstCommaToken">
 The new FirstCommaToken to update this TernaryConditionalExpressionSyntaxSyntax
 node with. If not specified the current FirstCommaToken will be used in the new
 TernaryConditionalExpressionSyntaxSyntax node.
 </param>
	<param name="whenTrue">
 The new WhenTrue to update this TernaryConditionalExpressionSyntaxSyntax node
 with. If not specified the current WhenTrue will be used in the new
 TernaryConditionalExpressionSyntaxSyntax node.
 </param>
	<param name="secondCommaToken">
 The new SecondCommaToken to update this
 TernaryConditionalExpressionSyntaxSyntax node with. If not specified the
 current SecondCommaToken will be used in the new
 TernaryConditionalExpressionSyntaxSyntax node.
 </param>
	<param name="whenFalse">
 The new WhenFalse to update this TernaryConditionalExpressionSyntaxSyntax node
 with. If not specified the current WhenFalse will be used in the new
 TernaryConditionalExpressionSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this TernaryConditionalExpressionSyntaxSyntax
 node with. If not specified the current CloseParenToken will be used in the new
 TernaryConditionalExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax">
	<summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LambdaExpressionSyntax.Begin">
	<summary>
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LambdaExpressionSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaExpressionSyntax">
	<summary>
 Represents a lambda expression, either single line or multi-line.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SingleLineLambdaExpressionSyntax.Begin">
	<summary>
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SingleLineLambdaExpressionSyntax.WithBegin(Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SingleLineLambdaExpressionSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SingleLineLambdaExpressionSyntax.WithBeginTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginTerminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SingleLineLambdaExpressionSyntax.Body">
	<summary>
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SingleLineLambdaExpressionSyntax.WithBody(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Creates a new node and sets the Body property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SingleLineLambdaExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Creates a new SingleLineLambdaExpressionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="begin">
 The new Begin to update this SingleLineLambdaExpressionSyntaxSyntax node with.
 If not specified the current Begin will be used in the new
 SingleLineLambdaExpressionSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this SingleLineLambdaExpressionSyntaxSyntax
 node with. If not specified the current BeginTerminator will be used in the new
 SingleLineLambdaExpressionSyntaxSyntax node.
 </param>
	<param name="body">
 The new Body to update this SingleLineLambdaExpressionSyntaxSyntax node with.
 If not specified the current Body will be used in the new
 SingleLineLambdaExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SingleLineLambdaExpressionSyntax">
	<summary>
 Represents a single line lambda expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MultiLineLambdaExpressionSyntax.Begin">
	<summary>
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MultiLineLambdaExpressionSyntax.WithBegin(Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax)">
	<summary>
 Creates a new node and sets the Begin property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MultiLineLambdaExpressionSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MultiLineLambdaExpressionSyntax.WithBeginTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginTerminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MultiLineLambdaExpressionSyntax.Statements">
	<summary>
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MultiLineLambdaExpressionSyntax.WithStatements(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Creates a new node and sets the Statements property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MultiLineLambdaExpressionSyntax.End">
	<summary>
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MultiLineLambdaExpressionSyntax.WithEnd(Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new node and sets the [End] property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MultiLineLambdaExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Creates a new MultiLineLambdaExpressionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="begin">
 The new Begin to update this MultiLineLambdaExpressionSyntaxSyntax node with.
 If not specified the current Begin will be used in the new
 MultiLineLambdaExpressionSyntaxSyntax node.
 </param>
	<param name="beginTerminator">
 The new BeginTerminator to update this MultiLineLambdaExpressionSyntaxSyntax
 node with. If not specified the current BeginTerminator will be used in the new
 MultiLineLambdaExpressionSyntaxSyntax node.
 </param>
	<param name="statements">
 The new Statements to update this MultiLineLambdaExpressionSyntaxSyntax node
 with. If not specified the current Statements will be used in the new
 MultiLineLambdaExpressionSyntaxSyntax node.
 </param>
	<param name="end">
 The new End to update this MultiLineLambdaExpressionSyntaxSyntax node with. If
 not specified the current End will be used in the new
 MultiLineLambdaExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.MultiLineLambdaExpressionSyntax">
	<summary>
 Represents a multi-line lambda expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax.WithAttributeLists(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Creates a new node and sets the AttributeLists property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax.WithModifiers(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the Modifiers property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax.Keyword">
	<summary>
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax.WithKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Keyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax.ParameterList">
	<summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax.WithParameterList(Roslyn.Compilers.VisualBasic.ParameterListSyntax)">
	<summary>
 Creates a new node and sets the ParameterList property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax.AsClause">
	<summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax.WithAsClause(Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new node and sets the AsClause property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Creates a new LambdaHeaderSyntaxSyntax node with the specified changes.
 </summary>
	<param name="attributeLists">
 The new AttributeLists to update this LambdaHeaderSyntaxSyntax node with. If
 not specified the current AttributeLists will be used in the new
 LambdaHeaderSyntaxSyntax node.
 </param>
	<param name="modifiers">
 The new Modifiers to update this LambdaHeaderSyntaxSyntax node with. If not
 specified the current Modifiers will be used in the new
 LambdaHeaderSyntaxSyntax node.
 </param>
	<param name="keyword">
 The new Keyword to update this LambdaHeaderSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new LambdaHeaderSyntaxSyntax
 node.
 </param>
	<param name="parameterList">
 The new ParameterList to update this LambdaHeaderSyntaxSyntax node with. If not
 specified the current ParameterList will be used in the new
 LambdaHeaderSyntaxSyntax node.
 </param>
	<param name="asClause">
 The new AsClause to update this LambdaHeaderSyntaxSyntax node with. If not
 specified the current AsClause will be used in the new LambdaHeaderSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax">
	<summary>
 Represents the header part of a lambda expression
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArgumentListSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArgumentListSyntax.WithOpenParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OpenParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArgumentListSyntax.Arguments">
	<summary>
 The list of arguments. This may be empty. Ommitted argument are represented by
 an OmittedArgumentSyntax node.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArgumentListSyntax.WithArguments(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ArgumentSyntax})">
	<summary>
 Creates a new node and sets the Arguments property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArgumentListSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArgumentListSyntax.WithCloseParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CloseParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArgumentListSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ArgumentSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new ArgumentListSyntaxSyntax node with the specified changes.
 </summary>
	<param name="openParenToken">
 The new OpenParenToken to update this ArgumentListSyntaxSyntax node with. If
 not specified the current OpenParenToken will be used in the new
 ArgumentListSyntaxSyntax node.
 </param>
	<param name="arguments">
 The new Arguments to update this ArgumentListSyntaxSyntax node with. If not
 specified the current Arguments will be used in the new
 ArgumentListSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this ArgumentListSyntaxSyntax node with. If
 not specified the current CloseParenToken will be used in the new
 ArgumentListSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ArgumentListSyntax">
	<summary>
 Represents a parenthesized argument list.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ArgumentSyntax">
	<summary>
 Base class for the possible kinds of arguments that can appear in an argument
 list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OmittedArgumentSyntax.Empty">
	<summary>
 An empty token because all non terminals must have a token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OmittedArgumentSyntax.WithEmpty(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Empty property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OmittedArgumentSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new OmittedArgumentSyntaxSyntax node with the specified changes.
 </summary>
	<param name="empty">
 The new Empty to update this OmittedArgumentSyntaxSyntax node with. If not
 specified the current Empty will be used in the new OmittedArgumentSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.OmittedArgumentSyntax">
	<summary>
 Represents an omitted argument in an argument list. An omitted argument is not
 considered a syntax error but a valid case when no argument is required.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SimpleArgumentSyntax.Expression">
	<summary>
 The expression that is the argument.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SimpleArgumentSyntax.WithExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Expression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SimpleArgumentSyntax.Update(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new SimpleArgumentSyntaxSyntax node with the specified changes.
 </summary>
	<param name="expression">
 The new Expression to update this SimpleArgumentSyntaxSyntax node with. If not
 specified the current Expression will be used in the new
 SimpleArgumentSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SimpleArgumentSyntax">
	<summary>
 Represents a simple argument that is just an expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedArgumentSyntax.IdentifierName">
	<summary>
 The name used to identify the named argument.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedArgumentSyntax.WithIdentifierName(Roslyn.Compilers.VisualBasic.IdentifierNameSyntax)">
	<summary>
 Creates a new node and sets the IdentifierName property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedArgumentSyntax.ColonEqualsToken">
	<summary>
 The ":=" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedArgumentSyntax.WithColonEqualsToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ColonEqualsToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedArgumentSyntax.Expression">
	<summary>
 The expression that is the named argument.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedArgumentSyntax.WithExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Expression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedArgumentSyntax.Update(Roslyn.Compilers.VisualBasic.IdentifierNameSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new NamedArgumentSyntaxSyntax node with the specified changes.
 </summary>
	<param name="identifierName">
 The new IdentifierName to update this NamedArgumentSyntaxSyntax node with. If
 not specified the current IdentifierName will be used in the new
 NamedArgumentSyntaxSyntax node.
 </param>
	<param name="colonEqualsToken">
 The new ColonEqualsToken to update this NamedArgumentSyntaxSyntax node with. If
 not specified the current ColonEqualsToken will be used in the new
 NamedArgumentSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this NamedArgumentSyntaxSyntax node with. If not
 specified the current Expression will be used in the new
 NamedArgumentSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.NamedArgumentSyntax">
	<summary>
 Represents a named argument, such as "Value:=7".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RangeArgumentSyntax.LowerBound">
	<summary>
 The lower bound of the range. This is typically the integer constant zero.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.RangeArgumentSyntax.WithLowerBound(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the LowerBound property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.RangeArgumentSyntax.ToKeyword">
	<summary>
 The "To" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.RangeArgumentSyntax.WithToKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ToKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.RangeArgumentSyntax.UpperBound">
	<summary>
 The upper bound of the range.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.RangeArgumentSyntax.WithUpperBound(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the UpperBound property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.RangeArgumentSyntax.Update(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new RangeArgumentSyntaxSyntax node with the specified changes.
 </summary>
	<param name="lowerBound">
 The new LowerBound to update this RangeArgumentSyntaxSyntax node with. If not
 specified the current LowerBound will be used in the new
 RangeArgumentSyntaxSyntax node.
 </param>
	<param name="toKeyword">
 The new ToKeyword to update this RangeArgumentSyntaxSyntax node with. If not
 specified the current ToKeyword will be used in the new
 RangeArgumentSyntaxSyntax node.
 </param>
	<param name="upperBound">
 The new UpperBound to update this RangeArgumentSyntaxSyntax node with. If not
 specified the current UpperBound will be used in the new
 RangeArgumentSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.RangeArgumentSyntax">
	<summary>
 Represents a range argument, such as "0 to 5", used in array bounds. The
 "Value" property represents the upper bound of the range.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.QueryExpressionSyntax.Clauses">
	<summary>
 A list of all the query operators in this query expression. This list always
 contains at least one operator.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.QueryExpressionSyntax.WithClauses(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryClauseSyntax})">
	<summary>
 Creates a new node and sets the Clauses property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.QueryExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryClauseSyntax})">
	<summary>
 Creates a new QueryExpressionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="clauses">
 The new Clauses to update this QueryExpressionSyntaxSyntax node with. If not
 specified the current Clauses will be used in the new
 QueryExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.QueryExpressionSyntax">
	<summary>
 This class represents a query expression. A query expression is composed of one
 or more query operators in a row. The first query operator must be a From or
 Aggregate.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.QueryClauseSyntax">
	<summary>
 This is a base class for all query operators.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax.Identifier">
	<summary>
 The name of the range variable being defined.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax.WithIdentifier(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax)">
	<summary>
 Creates a new node and sets the Identifier property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax.AsClause">
	<summary>
 Describes the type of the variable being defined.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax.WithAsClause(Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax)">
	<summary>
 Creates a new node and sets the AsClause property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax.InKeyword">
	<summary>
 The "In" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax.WithInKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the InKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax.Expression">
	<summary>
 The expression that serves as the source of items for the range variable.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax.WithExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Expression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax.Update(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new CollectionRangeVariableSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="identifier">
 The new Identifier to update this CollectionRangeVariableSyntaxSyntax node
 with. If not specified the current Identifier will be used in the new
 CollectionRangeVariableSyntaxSyntax node.
 </param>
	<param name="asClause">
 The new AsClause to update this CollectionRangeVariableSyntaxSyntax node with.
 If not specified the current AsClause will be used in the new
 CollectionRangeVariableSyntaxSyntax node.
 </param>
	<param name="inKeyword">
 The new InKeyword to update this CollectionRangeVariableSyntaxSyntax node with.
 If not specified the current InKeyword will be used in the new
 CollectionRangeVariableSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this CollectionRangeVariableSyntaxSyntax node
 with. If not specified the current Expression will be used in the new
 CollectionRangeVariableSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax">
	<summary>
 Describes a single variable of the form "x [As Type] In expression" for use in
 query expressions.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax.NameEquals">
	<summary>
 The optional name and type of the expression range variable. If ommitted, the
 name of the expression range variable is inferred from the expression.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax.WithNameEquals(Roslyn.Compilers.VisualBasic.VariableNameEqualsSyntax)">
	<summary>
 Creates a new node and sets the NameEquals property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax.Expression">
	<summary>
 The expression used to initialize the expression variable.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax.WithExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Expression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax.Update(Roslyn.Compilers.VisualBasic.VariableNameEqualsSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new ExpressionRangeVariableSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="nameEquals">
 The new NameEquals to update this ExpressionRangeVariableSyntaxSyntax node
 with. If not specified the current NameEquals will be used in the new
 ExpressionRangeVariableSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this ExpressionRangeVariableSyntaxSyntax node
 with. If not specified the current Expression will be used in the new
 ExpressionRangeVariableSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax">
	<summary>
 Describes a single variable of the form "[x [As Type] =] expression" for use in
 query expressions.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax.NameEquals">
	<summary>
 The optional name and type of the expression range variable. If ommitted, the
 name of the expression range variable is inferred from the aggregation
 expression.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax.WithNameEquals(Roslyn.Compilers.VisualBasic.VariableNameEqualsSyntax)">
	<summary>
 Creates a new node and sets the NameEquals property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax.Aggregation">
	<summary>
 The name of the aggregation function. The "Group" aggregation function is
 represented by the identifier "Group".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax.WithAggregation(Roslyn.Compilers.VisualBasic.AggregationSyntax)">
	<summary>
 Creates a new node and sets the Aggregation property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax.Update(Roslyn.Compilers.VisualBasic.VariableNameEqualsSyntax,Roslyn.Compilers.VisualBasic.AggregationSyntax)">
	<summary>
 Creates a new AggregationRangeVariableSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="nameEquals">
 The new NameEquals to update this AggregationRangeVariableSyntaxSyntax node
 with. If not specified the current NameEquals will be used in the new
 AggregationRangeVariableSyntaxSyntax node.
 </param>
	<param name="aggregation">
 The new Aggregation to update this AggregationRangeVariableSyntaxSyntax node
 with. If not specified the current Aggregation will be used in the new
 AggregationRangeVariableSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax">
	<summary>
 Describes a single variable of the form "[x [As Type] =] aggregation-function"
 for use in the Into clause of Aggregate or Group By or Group Join query
 operators.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.VariableNameEqualsSyntax.Identifier">
	<summary>
 The name of the variable being defined.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.VariableNameEqualsSyntax.WithIdentifier(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax)">
	<summary>
 Creates a new node and sets the Identifier property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.VariableNameEqualsSyntax.AsClause">
	<summary>
 Describes the type of the variable being defined.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.VariableNameEqualsSyntax.WithAsClause(Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax)">
	<summary>
 Creates a new node and sets the AsClause property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.VariableNameEqualsSyntax.EqualsToken">
	<summary>
 The "=" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.VariableNameEqualsSyntax.WithEqualsToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the EqualsToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.VariableNameEqualsSyntax.Update(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new VariableNameEqualsSyntaxSyntax node with the specified changes.
 </summary>
	<param name="identifier">
 The new Identifier to update this VariableNameEqualsSyntaxSyntax node with. If
 not specified the current Identifier will be used in the new
 VariableNameEqualsSyntaxSyntax node.
 </param>
	<param name="asClause">
 The new AsClause to update this VariableNameEqualsSyntaxSyntax node with. If
 not specified the current AsClause will be used in the new
 VariableNameEqualsSyntaxSyntax node.
 </param>
	<param name="equalsToken">
 The new EqualsToken to update this VariableNameEqualsSyntaxSyntax node with. If
 not specified the current EqualsToken will be used in the new
 VariableNameEqualsSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.VariableNameEqualsSyntax">
	<summary>
 Represents the name and optional type of an expression range variable.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AggregationSyntax">
	<summary>
 Represents aggregation in aggregation range variable declaration of a Group By,
 Group Join or Aggregate query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FunctionAggregationSyntax.FunctionName">
	<summary>
 The name of the aggregation function.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.FunctionAggregationSyntax.WithFunctionName(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the FunctionName property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.FunctionAggregationSyntax.OpenParenToken">
	<summary>
 The "(" token if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.FunctionAggregationSyntax.WithOpenParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OpenParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.FunctionAggregationSyntax.Argument">
	<summary>
 The argument to the aggregation function.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.FunctionAggregationSyntax.WithArgument(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Argument property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.FunctionAggregationSyntax.CloseParenToken">
	<summary>
 The ")" token, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.FunctionAggregationSyntax.WithCloseParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CloseParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.FunctionAggregationSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new FunctionAggregationSyntaxSyntax node with the specified changes.
 </summary>
	<param name="functionName">
 The new FunctionName to update this FunctionAggregationSyntaxSyntax node with.
 If not specified the current FunctionName will be used in the new
 FunctionAggregationSyntaxSyntax node.
 </param>
	<param name="openParenToken">
 The new OpenParenToken to update this FunctionAggregationSyntaxSyntax node
 with. If not specified the current OpenParenToken will be used in the new
 FunctionAggregationSyntaxSyntax node.
 </param>
	<param name="argument">
 The new Argument to update this FunctionAggregationSyntaxSyntax node with. If
 not specified the current Argument will be used in the new
 FunctionAggregationSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this FunctionAggregationSyntaxSyntax node
 with. If not specified the current CloseParenToken will be used in the new
 FunctionAggregationSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.FunctionAggregationSyntax">
	<summary>
 Represents an invocation of an Aggregation function in the aggregation range
 variable declaration of a Group By, Group Join or Aggregate query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupAggregationSyntax.GroupKeyword">
	<summary>
 The "Group" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GroupAggregationSyntax.WithGroupKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the GroupKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.GroupAggregationSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new GroupAggregationSyntaxSyntax node with the specified changes.
 </summary>
	<param name="groupKeyword">
 The new GroupKeyword to update this GroupAggregationSyntaxSyntax node with. If
 not specified the current GroupKeyword will be used in the new
 GroupAggregationSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.GroupAggregationSyntax">
	<summary>
 Represents the use of "Group" as the aggregation function in the in the
 aggregation range variable declaration of a Group By or Group Join query
 operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FromClauseSyntax.FromKeyword">
	<summary>
 The "From" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.FromClauseSyntax.WithFromKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the FromKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.FromClauseSyntax.Variables">
	<summary>
 The list of collection variables declared by this From operator.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.FromClauseSyntax.WithVariables(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax})">
	<summary>
 Creates a new node and sets the Variables property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.FromClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax})">
	<summary>
 Creates a new FromClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="fromKeyword">
 The new FromKeyword to update this FromClauseSyntaxSyntax node with. If not
 specified the current FromKeyword will be used in the new
 FromClauseSyntaxSyntax node.
 </param>
	<param name="variables">
 The new Variables to update this FromClauseSyntaxSyntax node with. If not
 specified the current Variables will be used in the new FromClauseSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.FromClauseSyntax">
	<summary>
 Represents a "From" query operator. If this is the beginning of a query, the
 Source will be Nothing. Otherwise, the Source will be the part of the query to
 the left of the From.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LetClauseSyntax.LetKeyword">
	<summary>
 The "Let" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LetClauseSyntax.WithLetKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the LetKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.LetClauseSyntax.Variables">
	<summary>
 The list of expression range variable being defined by the Let operator.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LetClauseSyntax.WithVariables(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax})">
	<summary>
 Creates a new node and sets the Variables property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LetClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax})">
	<summary>
 Creates a new LetClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="letKeyword">
 The new LetKeyword to update this LetClauseSyntaxSyntax node with. If not
 specified the current LetKeyword will be used in the new LetClauseSyntaxSyntax
 node.
 </param>
	<param name="variables">
 The new Variables to update this LetClauseSyntaxSyntax node with. If not
 specified the current Variables will be used in the new LetClauseSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.LetClauseSyntax">
	<summary>
 Represents a "Let" query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AggregateClauseSyntax.AggregateKeyword">
	<summary>
 The "Aggregate" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AggregateClauseSyntax.WithAggregateKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the AggregateKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AggregateClauseSyntax.Variables">
	<summary>
 The list of collection range variables declared by this Aggregate operator.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AggregateClauseSyntax.WithVariables(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax})">
	<summary>
 Creates a new node and sets the Variables property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AggregateClauseSyntax.AdditionalQueryOperators">
	<summary>
 A list of additional query operators. It may be empty.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AggregateClauseSyntax.WithAdditionalQueryOperators(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryClauseSyntax})">
	<summary>
 Creates a new node and sets the AdditionalQueryOperators property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AggregateClauseSyntax.IntoKeyword">
	<summary>
 The "Into" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AggregateClauseSyntax.WithIntoKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the IntoKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AggregateClauseSyntax.AggregationVariables">
	<summary>
 The list of new variables being defined by the aggregation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AggregateClauseSyntax.WithAggregationVariables(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax})">
	<summary>
 Creates a new node and sets the AggregationVariables property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AggregateClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryClauseSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax})">
	<summary>
 Creates a new AggregateClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="aggregateKeyword">
 The new AggregateKeyword to update this AggregateClauseSyntaxSyntax node with.
 If not specified the current AggregateKeyword will be used in the new
 AggregateClauseSyntaxSyntax node.
 </param>
	<param name="variables">
 The new Variables to update this AggregateClauseSyntaxSyntax node with. If not
 specified the current Variables will be used in the new
 AggregateClauseSyntaxSyntax node.
 </param>
	<param name="additionalQueryOperators">
 The new AdditionalQueryOperators to update this AggregateClauseSyntaxSyntax
 node with. If not specified the current AdditionalQueryOperators will be used
 in the new AggregateClauseSyntaxSyntax node.
 </param>
	<param name="intoKeyword">
 The new IntoKeyword to update this AggregateClauseSyntaxSyntax node with. If
 not specified the current IntoKeyword will be used in the new
 AggregateClauseSyntaxSyntax node.
 </param>
	<param name="aggregationVariables">
 The new AggregationVariables to update this AggregateClauseSyntaxSyntax node
 with. If not specified the current AggregationVariables will be used in the new
 AggregateClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.AggregateClauseSyntax">
	<summary>
 Represents an Aggregate query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DistinctClauseSyntax.DistinctKeyword">
	<summary>
 The "Distinct" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DistinctClauseSyntax.WithDistinctKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the DistinctKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DistinctClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new DistinctClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="distinctKeyword">
 The new DistinctKeyword to update this DistinctClauseSyntaxSyntax node with. If
 not specified the current DistinctKeyword will be used in the new
 DistinctClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.DistinctClauseSyntax">
	<summary>
 Represents the "Distinct" query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WhereClauseSyntax.WhereKeyword">
	<summary>
 The "Where" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.WhereClauseSyntax.WithWhereKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the WhereKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.WhereClauseSyntax.Condition">
	<summary>
 The boolean expression used for filtering.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.WhereClauseSyntax.WithCondition(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Condition property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.WhereClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new WhereClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="whereKeyword">
 The new WhereKeyword to update this WhereClauseSyntaxSyntax node with. If not
 specified the current WhereKeyword will be used in the new
 WhereClauseSyntaxSyntax node.
 </param>
	<param name="condition">
 The new Condition to update this WhereClauseSyntaxSyntax node with. If not
 specified the current Condition will be used in the new WhereClauseSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.WhereClauseSyntax">
	<summary>
 Represents a "Where" query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PartitionWhileClauseSyntax.SkipOrTakeKeyword">
	<summary>
 The "Skip" or "Take" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PartitionWhileClauseSyntax.WithSkipOrTakeKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the SkipOrTakeKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.PartitionWhileClauseSyntax.WhileKeyword">
	<summary>
 The "While" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PartitionWhileClauseSyntax.WithWhileKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the WhileKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.PartitionWhileClauseSyntax.Condition">
	<summary>
 The boolean expression used for partitioning.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PartitionWhileClauseSyntax.WithCondition(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Condition property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.PartitionWhileClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new PartitionWhileClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="skipOrTakeKeyword">
 The new SkipOrTakeKeyword to update this PartitionWhileClauseSyntaxSyntax node
 with. If not specified the current SkipOrTakeKeyword will be used in the new
 PartitionWhileClauseSyntaxSyntax node.
 </param>
	<param name="whileKeyword">
 The new WhileKeyword to update this PartitionWhileClauseSyntaxSyntax node with.
 If not specified the current WhileKeyword will be used in the new
 PartitionWhileClauseSyntaxSyntax node.
 </param>
	<param name="condition">
 The new Condition to update this PartitionWhileClauseSyntaxSyntax node with. If
 not specified the current Condition will be used in the new
 PartitionWhileClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.PartitionWhileClauseSyntax">
	<summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PartitionClauseSyntax.SkipOrTakeKeyword">
	<summary>
 The "Skip" or "Take" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PartitionClauseSyntax.WithSkipOrTakeKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the SkipOrTakeKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.PartitionClauseSyntax.Count">
	<summary>
 Represents the expression with the number of items to take or skip.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PartitionClauseSyntax.WithCount(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Count property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.PartitionClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new PartitionClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="skipOrTakeKeyword">
 The new SkipOrTakeKeyword to update this PartitionClauseSyntaxSyntax node with.
 If not specified the current SkipOrTakeKeyword will be used in the new
 PartitionClauseSyntaxSyntax node.
 </param>
	<param name="count">
 The new Count to update this PartitionClauseSyntaxSyntax node with. If not
 specified the current Count will be used in the new PartitionClauseSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.PartitionClauseSyntax">
	<summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupByClauseSyntax.GroupKeyword">
	<summary>
 The "Group" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GroupByClauseSyntax.WithGroupKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the GroupKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupByClauseSyntax.Items">
	<summary>
 The optional list of variables being grouped; the contents of the Group clause.
 If none were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.GroupByClauseSyntax.WithItems(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax})">
	<summary>
 Creates a new node and sets the Items property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupByClauseSyntax.ByKeyword">
	<summary>
 The "By" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GroupByClauseSyntax.WithByKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ByKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupByClauseSyntax.Keys">
	<summary>
 The key values being used for grouping.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GroupByClauseSyntax.WithKeys(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax})">
	<summary>
 Creates a new node and sets the Keys property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.GroupByClauseSyntax.WithIntoKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the IntoKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupByClauseSyntax.AggregationVariables">
	<summary>
 The list of new variables that calculate aggregations.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GroupByClauseSyntax.WithAggregationVariables(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax})">
	<summary>
 Creates a new node and sets the AggregationVariables property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.GroupByClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax})">
	<summary>
 Creates a new GroupByClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="groupKeyword">
 The new GroupKeyword to update this GroupByClauseSyntaxSyntax node with. If not
 specified the current GroupKeyword will be used in the new
 GroupByClauseSyntaxSyntax node.
 </param>
	<param name="items">
 The new Items to update this GroupByClauseSyntaxSyntax node with. If not
 specified the current Items will be used in the new GroupByClauseSyntaxSyntax
 node.
 </param>
	<param name="byKeyword">
 The new ByKeyword to update this GroupByClauseSyntaxSyntax node with. If not
 specified the current ByKeyword will be used in the new
 GroupByClauseSyntaxSyntax node.
 </param>
	<param name="keys">
 The new Keys to update this GroupByClauseSyntaxSyntax node with. If not
 specified the current Keys will be used in the new GroupByClauseSyntaxSyntax
 node.
 </param>
	<param name="intoKeyword">
 The new IntoKeyword to update this GroupByClauseSyntaxSyntax node with. If not
 specified the current IntoKeyword will be used in the new
 GroupByClauseSyntaxSyntax node.
 </param>
	<param name="aggregationVariables">
 The new AggregationVariables to update this GroupByClauseSyntaxSyntax node
 with. If not specified the current AggregationVariables will be used in the new
 GroupByClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.GroupByClauseSyntax">
	<summary>
 Represents the "Group By" query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.JoinClauseSyntax.JoinKeyword">
	<summary>
 The "Join" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.JoinClauseSyntax.WithJoinKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the JoinKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.JoinClauseSyntax.JoinedVariables">
	<summary>
 Defines the collection range variables being joined to.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.JoinClauseSyntax.WithJoinedVariables(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax})">
	<summary>
 Creates a new node and sets the JoinedVariables property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.JoinClauseSyntax.AdditionalJoins">
	<summary>
 An additional Join or Group Join query operator.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.JoinClauseSyntax.WithAdditionalJoins(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.JoinClauseSyntax})">
	<summary>
 Creates a new node and sets the AdditionalJoins property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.JoinClauseSyntax.OnKeyword">
	<summary>
 The "On" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.JoinClauseSyntax.WithOnKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OnKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.JoinClauseSyntax.JoinConditions">
	<summary>
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.JoinClauseSyntax.WithJoinConditions(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.JoinConditionSyntax})">
	<summary>
 Creates a new node and sets the JoinConditions property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.JoinClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.JoinClauseSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.JoinConditionSyntax})">
	<summary>
 Creates a new JoinClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="joinKeyword">
 The new JoinKeyword to update this JoinClauseSyntaxSyntax node with. If not
 specified the current JoinKeyword will be used in the new
 JoinClauseSyntaxSyntax node.
 </param>
	<param name="joinedVariables">
 The new JoinedVariables to update this JoinClauseSyntaxSyntax node with. If not
 specified the current JoinedVariables will be used in the new
 JoinClauseSyntaxSyntax node.
 </param>
	<param name="additionalJoins">
 The new AdditionalJoins to update this JoinClauseSyntaxSyntax node with. If not
 specified the current AdditionalJoins will be used in the new
 JoinClauseSyntaxSyntax node.
 </param>
	<param name="onKeyword">
 The new OnKeyword to update this JoinClauseSyntaxSyntax node with. If not
 specified the current OnKeyword will be used in the new JoinClauseSyntaxSyntax
 node.
 </param>
	<param name="joinConditions">
 The new JoinConditions to update this JoinClauseSyntaxSyntax node with. If not
 specified the current JoinConditions will be used in the new
 JoinClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.JoinClauseSyntax">
	<summary>
 Represents a Join query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.JoinConditionSyntax.Left">
	<summary>
 The left expression in the Join condition.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.JoinConditionSyntax.WithLeft(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Left property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.JoinConditionSyntax.EqualsKeyword">
	<summary>
 The "Equals" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.JoinConditionSyntax.WithEqualsKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the EqualsKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.JoinConditionSyntax.Right">
	<summary>
 The right expression in the Join condition.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.JoinConditionSyntax.WithRight(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Right property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.JoinConditionSyntax.Update(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new JoinConditionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="left">
 The new Left to update this JoinConditionSyntaxSyntax node with. If not
 specified the current Left will be used in the new JoinConditionSyntaxSyntax
 node.
 </param>
	<param name="equalsKeyword">
 The new EqualsKeyword to update this JoinConditionSyntaxSyntax node with. If
 not specified the current EqualsKeyword will be used in the new
 JoinConditionSyntaxSyntax node.
 </param>
	<param name="right">
 The new Right to update this JoinConditionSyntaxSyntax node with. If not
 specified the current Right will be used in the new JoinConditionSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.JoinConditionSyntax">
	<summary>
 Represents the "expression Equals expression" condition in a Join.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupJoinClauseSyntax.GroupKeyword">
	<summary>
 The "Group" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GroupJoinClauseSyntax.WithGroupKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the GroupKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupJoinClauseSyntax.JoinKeyword">
	<summary>
 The "Join" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GroupJoinClauseSyntax.WithJoinKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the JoinKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupJoinClauseSyntax.JoinedVariables">
	<summary>
 Defines the collection range variables being joined to.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GroupJoinClauseSyntax.WithJoinedVariables(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax})">
	<summary>
 Creates a new node and sets the JoinedVariables property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupJoinClauseSyntax.AdditionalJoins">
	<summary>
 An additional Join or Group Join query operator.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.GroupJoinClauseSyntax.WithAdditionalJoins(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.JoinClauseSyntax})">
	<summary>
 Creates a new node and sets the AdditionalJoins property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupJoinClauseSyntax.OnKeyword">
	<summary>
 The "On" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GroupJoinClauseSyntax.WithOnKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OnKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupJoinClauseSyntax.JoinConditions">
	<summary>
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GroupJoinClauseSyntax.WithJoinConditions(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.JoinConditionSyntax})">
	<summary>
 Creates a new node and sets the JoinConditions property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupJoinClauseSyntax.IntoKeyword">
	<summary>
 The "Into" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GroupJoinClauseSyntax.WithIntoKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the IntoKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.GroupJoinClauseSyntax.AggregationVariables">
	<summary>
 The list of new variables that calculate aggregations.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GroupJoinClauseSyntax.WithAggregationVariables(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax})">
	<summary>
 Creates a new node and sets the AggregationVariables property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.GroupJoinClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.JoinClauseSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.JoinConditionSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax})">
	<summary>
 Creates a new GroupJoinClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="groupKeyword">
 The new GroupKeyword to update this GroupJoinClauseSyntaxSyntax node with. If
 not specified the current GroupKeyword will be used in the new
 GroupJoinClauseSyntaxSyntax node.
 </param>
	<param name="joinKeyword">
 The new JoinKeyword to update this GroupJoinClauseSyntaxSyntax node with. If
 not specified the current JoinKeyword will be used in the new
 GroupJoinClauseSyntaxSyntax node.
 </param>
	<param name="joinedVariables">
 The new JoinedVariables to update this GroupJoinClauseSyntaxSyntax node with.
 If not specified the current JoinedVariables will be used in the new
 GroupJoinClauseSyntaxSyntax node.
 </param>
	<param name="additionalJoins">
 The new AdditionalJoins to update this GroupJoinClauseSyntaxSyntax node with.
 If not specified the current AdditionalJoins will be used in the new
 GroupJoinClauseSyntaxSyntax node.
 </param>
	<param name="onKeyword">
 The new OnKeyword to update this GroupJoinClauseSyntaxSyntax node with. If not
 specified the current OnKeyword will be used in the new
 GroupJoinClauseSyntaxSyntax node.
 </param>
	<param name="joinConditions">
 The new JoinConditions to update this GroupJoinClauseSyntaxSyntax node with. If
 not specified the current JoinConditions will be used in the new
 GroupJoinClauseSyntaxSyntax node.
 </param>
	<param name="intoKeyword">
 The new IntoKeyword to update this GroupJoinClauseSyntaxSyntax node with. If
 not specified the current IntoKeyword will be used in the new
 GroupJoinClauseSyntaxSyntax node.
 </param>
	<param name="aggregationVariables">
 The new AggregationVariables to update this GroupJoinClauseSyntaxSyntax node
 with. If not specified the current AggregationVariables will be used in the new
 GroupJoinClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.GroupJoinClauseSyntax">
	<summary>
 Represents the "Group Join" query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OrderByClauseSyntax.OrderKeyword">
	<summary>
 The "Order" keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OrderByClauseSyntax.WithOrderKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OrderKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.OrderByClauseSyntax.ByKeyword">
	<summary>
 The "By" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OrderByClauseSyntax.WithByKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ByKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.OrderByClauseSyntax.Orderings">
	<summary>
 The list of OrderExpression's to sort by.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OrderByClauseSyntax.WithOrderings(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.OrderingSyntax})">
	<summary>
 Creates a new node and sets the Orderings property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OrderByClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.OrderingSyntax})">
	<summary>
 Creates a new OrderByClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="orderKeyword">
 The new OrderKeyword to update this OrderByClauseSyntaxSyntax node with. If not
 specified the current OrderKeyword will be used in the new
 OrderByClauseSyntaxSyntax node.
 </param>
	<param name="byKeyword">
 The new ByKeyword to update this OrderByClauseSyntaxSyntax node with. If not
 specified the current ByKeyword will be used in the new
 OrderByClauseSyntaxSyntax node.
 </param>
	<param name="orderings">
 The new Orderings to update this OrderByClauseSyntaxSyntax node with. If not
 specified the current Orderings will be used in the new
 OrderByClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.OrderByClauseSyntax">
	<summary>
 Represents the "Order By" query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OrderingSyntax.Expression">
	<summary>
 The expression to sort by.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OrderingSyntax.WithExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Expression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.OrderingSyntax.AscendingOrDescendingKeyword">
	<summary>
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OrderingSyntax.WithAscendingOrDescendingKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the AscendingOrDescendingKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OrderingSyntax.Update(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new OrderingSyntaxSyntax node with the specified changes.
 </summary>
	<param name="expression">
 The new Expression to update this OrderingSyntaxSyntax node with. If not
 specified the current Expression will be used in the new OrderingSyntaxSyntax
 node.
 </param>
	<param name="ascendingOrDescendingKeyword">
 The new AscendingOrDescendingKeyword to update this OrderingSyntaxSyntax node
 with. If not specified the current AscendingOrDescendingKeyword will be used in
 the new OrderingSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.OrderingSyntax">
	<summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SelectClauseSyntax.SelectKeyword">
	<summary>
 The "Select" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SelectClauseSyntax.WithSelectKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the SelectKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SelectClauseSyntax.Variables">
	<summary>
 The list of expression range variables being defined by the Select query
 operator.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SelectClauseSyntax.WithVariables(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax})">
	<summary>
 Creates a new node and sets the Variables property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SelectClauseSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax})">
	<summary>
 Creates a new SelectClauseSyntaxSyntax node with the specified changes.
 </summary>
	<param name="selectKeyword">
 The new SelectKeyword to update this SelectClauseSyntaxSyntax node with. If not
 specified the current SelectKeyword will be used in the new
 SelectClauseSyntaxSyntax node.
 </param>
	<param name="variables">
 The new Variables to update this SelectClauseSyntaxSyntax node with. If not
 specified the current Variables will be used in the new
 SelectClauseSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SelectClauseSyntax">
	<summary>
 Represents the "Select" query operator.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlNodeSyntax">
	<summary>
 This is the base class for all XML expression syntax nodes (XmlDocument and
 XmlElement).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlDocumentSyntax.WithDeclaration(Roslyn.Compilers.VisualBasic.XmlDeclarationSyntax)">
	<summary>
 Creates a new node and sets the Declaration property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlDocumentSyntax.PrecedingMisc">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlDocumentSyntax.WithPrecedingMisc(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax})">
	<summary>
 Creates a new node and sets the PrecedingMisc property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlDocumentSyntax.WithRoot(Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Creates a new node and sets the Root property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlDocumentSyntax.FollowingMisc">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlDocumentSyntax.WithFollowingMisc(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax})">
	<summary>
 Creates a new node and sets the FollowingMisc property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlDocumentSyntax.Update(Roslyn.Compilers.VisualBasic.XmlDeclarationSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax},Roslyn.Compilers.VisualBasic.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax})">
	<summary>
 Creates a new XmlDocumentSyntaxSyntax node with the specified changes.
 </summary>
	<param name="declaration">
 The new Declaration to update this XmlDocumentSyntaxSyntax node with. If not
 specified the current Declaration will be used in the new
 XmlDocumentSyntaxSyntax node.
 </param>
	<param name="precedingMisc">
 The new PrecedingMisc to update this XmlDocumentSyntaxSyntax node with. If not
 specified the current PrecedingMisc will be used in the new
 XmlDocumentSyntaxSyntax node.
 </param>
	<param name="root">
 The new Root to update this XmlDocumentSyntaxSyntax node with. If not specified
 the current Root will be used in the new XmlDocumentSyntaxSyntax node.
 </param>
	<param name="followingMisc">
 The new FollowingMisc to update this XmlDocumentSyntaxSyntax node with. If not
 specified the current FollowingMisc will be used in the new
 XmlDocumentSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlDocumentSyntax">
	<summary>
 Represents and XML Document literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlDeclarationSyntax.WithLessThanQuestionToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the LessThanQuestionToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlDeclarationSyntax.WithXmlKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the XmlKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlDeclarationSyntax.WithVersion(Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax)">
	<summary>
 Creates a new node and sets the Version property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlDeclarationSyntax.Encoding">
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlDeclarationSyntax.WithEncoding(Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax)">
	<summary>
 Creates a new node and sets the Encoding property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlDeclarationSyntax.Standalone">
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlDeclarationSyntax.WithStandalone(Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax)">
	<summary>
 Creates a new node and sets the Standalone property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlDeclarationSyntax.WithQuestionGreaterThanToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the QuestionGreaterThanToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlDeclarationSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax,Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax,Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlDeclarationSyntaxSyntax node with the specified changes.
 </summary>
	<param name="lessThanQuestionToken">
 The new LessThanQuestionToken to update this XmlDeclarationSyntaxSyntax node
 with. If not specified the current LessThanQuestionToken will be used in the
 new XmlDeclarationSyntaxSyntax node.
 </param>
	<param name="xmlKeyword">
 The new XmlKeyword to update this XmlDeclarationSyntaxSyntax node with. If not
 specified the current XmlKeyword will be used in the new
 XmlDeclarationSyntaxSyntax node.
 </param>
	<param name="version">
 The new Version to update this XmlDeclarationSyntaxSyntax node with. If not
 specified the current Version will be used in the new
 XmlDeclarationSyntaxSyntax node.
 </param>
	<param name="encoding">
 The new Encoding to update this XmlDeclarationSyntaxSyntax node with. If not
 specified the current Encoding will be used in the new
 XmlDeclarationSyntaxSyntax node.
 </param>
	<param name="standalone">
 The new Standalone to update this XmlDeclarationSyntaxSyntax node with. If not
 specified the current Standalone will be used in the new
 XmlDeclarationSyntaxSyntax node.
 </param>
	<param name="questionGreaterThanToken">
 The new QuestionGreaterThanToken to update this XmlDeclarationSyntaxSyntax node
 with. If not specified the current QuestionGreaterThanToken will be used in the
 new XmlDeclarationSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlDeclarationSyntax">
	<summary>
 Represents the XML declaration prologue in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax.WithName(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Name property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax.WithEquals(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Equals property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax.WithValue(Roslyn.Compilers.VisualBasic.XmlStringSyntax)">
	<summary>
 Creates a new node and sets the Value property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlStringSyntax)">
	<summary>
 Creates a new XmlDeclarationOptionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="name">
 The new Name to update this XmlDeclarationOptionSyntaxSyntax node with. If not
 specified the current Name will be used in the new
 XmlDeclarationOptionSyntaxSyntax node.
 </param>
	<param name="equals">
 The new Equals to update this XmlDeclarationOptionSyntaxSyntax node with. If
 not specified the current Equals will be used in the new
 XmlDeclarationOptionSyntaxSyntax node.
 </param>
	<param name="value">
 The new Value to update this XmlDeclarationOptionSyntaxSyntax node with. If not
 specified the current Value will be used in the new
 XmlDeclarationOptionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax">
	<summary>
 Represents an XML document prologue option - version, encoding, standalone or
 whitespace in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlElementSyntax.WithStartTag(Roslyn.Compilers.VisualBasic.XmlElementStartTagSyntax)">
	<summary>
 Creates a new node and sets the StartTag property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlElementSyntax.Content">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlElementSyntax.WithContent(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax})">
	<summary>
 Creates a new node and sets the Content property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlElementSyntax.WithEndTag(Roslyn.Compilers.VisualBasic.XmlElementEndTagSyntax)">
	<summary>
 Creates a new node and sets the EndTag property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlElementSyntax.Update(Roslyn.Compilers.VisualBasic.XmlElementStartTagSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax},Roslyn.Compilers.VisualBasic.XmlElementEndTagSyntax)">
	<summary>
 Creates a new XmlElementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="startTag">
 The new StartTag to update this XmlElementSyntaxSyntax node with. If not
 specified the current StartTag will be used in the new XmlElementSyntaxSyntax
 node.
 </param>
	<param name="content">
 The new Content to update this XmlElementSyntaxSyntax node with. If not
 specified the current Content will be used in the new XmlElementSyntaxSyntax
 node.
 </param>
	<param name="endTag">
 The new EndTag to update this XmlElementSyntaxSyntax node with. If not
 specified the current EndTag will be used in the new XmlElementSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlElementSyntax">
	<summary>
 Represents an XML element with content in an XML literal expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlTextSyntax.TextTokens">
	<summary>
 A list of all the text tokens in the Xml text. This list always contains at
 least one token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlTextSyntax.WithTextTokens(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the TextTokens property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlTextSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new XmlTextSyntaxSyntax node with the specified changes.
 </summary>
	<param name="textTokens">
 The new TextTokens to update this XmlTextSyntaxSyntax node with. If not
 specified the current TextTokens will be used in the new XmlTextSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlTextSyntax">
	<summary>
 Represents Xml text.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlElementStartTagSyntax.WithLessThanToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the LessThanToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlElementStartTagSyntax.WithName(Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Creates a new node and sets the Name property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlElementStartTagSyntax.Attributes">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlElementStartTagSyntax.WithAttributes(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax})">
	<summary>
 Creates a new node and sets the Attributes property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlElementStartTagSyntax.WithGreaterThanToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the GreaterThanToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlElementStartTagSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlElementStartTagSyntaxSyntax node with the specified changes.
 </summary>
	<param name="lessThanToken">
 The new LessThanToken to update this XmlElementStartTagSyntaxSyntax node with.
 If not specified the current LessThanToken will be used in the new
 XmlElementStartTagSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this XmlElementStartTagSyntaxSyntax node with. If not
 specified the current Name will be used in the new
 XmlElementStartTagSyntaxSyntax node.
 </param>
	<param name="attributes">
 The new Attributes to update this XmlElementStartTagSyntaxSyntax node with. If
 not specified the current Attributes will be used in the new
 XmlElementStartTagSyntaxSyntax node.
 </param>
	<param name="greaterThanToken">
 The new GreaterThanToken to update this XmlElementStartTagSyntaxSyntax node
 with. If not specified the current GreaterThanToken will be used in the new
 XmlElementStartTagSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlElementStartTagSyntax">
	<summary>
 Represents the start tag of an XML element of the form &lt;element&gt;.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlElementEndTagSyntax.WithLessThanSlashToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the LessThanSlashToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlElementEndTagSyntax.Name">
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlElementEndTagSyntax.WithName(Roslyn.Compilers.VisualBasic.XmlNameSyntax)">
	<summary>
 Creates a new node and sets the Name property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlElementEndTagSyntax.WithGreaterThanToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the GreaterThanToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlElementEndTagSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNameSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlElementEndTagSyntaxSyntax node with the specified changes.
 </summary>
	<param name="lessThanSlashToken">
 The new LessThanSlashToken to update this XmlElementEndTagSyntaxSyntax node
 with. If not specified the current LessThanSlashToken will be used in the new
 XmlElementEndTagSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this XmlElementEndTagSyntaxSyntax node with. If not
 specified the current Name will be used in the new XmlElementEndTagSyntaxSyntax
 node.
 </param>
	<param name="greaterThanToken">
 The new GreaterThanToken to update this XmlElementEndTagSyntaxSyntax node with.
 If not specified the current GreaterThanToken will be used in the new
 XmlElementEndTagSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlElementEndTagSyntax">
	<summary>
 Represents the end tag of an XML element of the form &lt;/element&gt;.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlEmptyElementSyntax.WithLessThanToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the LessThanToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlEmptyElementSyntax.WithName(Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Creates a new node and sets the Name property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlEmptyElementSyntax.Attributes">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlEmptyElementSyntax.WithAttributes(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax})">
	<summary>
 Creates a new node and sets the Attributes property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlEmptyElementSyntax.WithSlashGreaterThanToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the SlashGreaterThanToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlEmptyElementSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlEmptyElementSyntaxSyntax node with the specified changes.
 </summary>
	<param name="lessThanToken">
 The new LessThanToken to update this XmlEmptyElementSyntaxSyntax node with. If
 not specified the current LessThanToken will be used in the new
 XmlEmptyElementSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this XmlEmptyElementSyntaxSyntax node with. If not
 specified the current Name will be used in the new XmlEmptyElementSyntaxSyntax
 node.
 </param>
	<param name="attributes">
 The new Attributes to update this XmlEmptyElementSyntaxSyntax node with. If not
 specified the current Attributes will be used in the new
 XmlEmptyElementSyntaxSyntax node.
 </param>
	<param name="slashGreaterThanToken">
 The new SlashGreaterThanToken to update this XmlEmptyElementSyntaxSyntax node
 with. If not specified the current SlashGreaterThanToken will be used in the
 new XmlEmptyElementSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlEmptyElementSyntax">
	<summary>
 Represents an empty XML element of the form &lt;element /&gt;
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlAttributeSyntax.WithName(Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Creates a new node and sets the Name property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlAttributeSyntax.WithEqualsToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the EqualsToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlAttributeSyntax.WithValue(Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Creates a new node and sets the Value property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlAttributeSyntax.Update(Roslyn.Compilers.VisualBasic.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Creates a new XmlAttributeSyntaxSyntax node with the specified changes.
 </summary>
	<param name="name">
 The new Name to update this XmlAttributeSyntaxSyntax node with. If not
 specified the current Name will be used in the new XmlAttributeSyntaxSyntax
 node.
 </param>
	<param name="equalsToken">
 The new EqualsToken to update this XmlAttributeSyntaxSyntax node with. If not
 specified the current EqualsToken will be used in the new
 XmlAttributeSyntaxSyntax node.
 </param>
	<param name="value">
 The new Value to update this XmlAttributeSyntaxSyntax node with. If not
 specified the current Value will be used in the new XmlAttributeSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlAttributeSyntax">
	<summary>
 Represents an XML attribute in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlStringSyntax.WithStartQuoteToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the StartQuoteToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlStringSyntax.TextTokens">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlStringSyntax.WithTextTokens(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the TextTokens property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlStringSyntax.WithEndQuoteToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the EndQuoteToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlStringSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlStringSyntaxSyntax node with the specified changes.
 </summary>
	<param name="startQuoteToken">
 The new StartQuoteToken to update this XmlStringSyntaxSyntax node with. If not
 specified the current StartQuoteToken will be used in the new
 XmlStringSyntaxSyntax node.
 </param>
	<param name="textTokens">
 The new TextTokens to update this XmlStringSyntaxSyntax node with. If not
 specified the current TextTokens will be used in the new XmlStringSyntaxSyntax
 node.
 </param>
	<param name="endQuoteToken">
 The new EndQuoteToken to update this XmlStringSyntaxSyntax node with. If not
 specified the current EndQuoteToken will be used in the new
 XmlStringSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlStringSyntax">
	<summary>
 Represents a string of XML characters embedded as the content of an XML
 element.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlPrefixNameSyntax.WithName(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Name property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlPrefixNameSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlPrefixNameSyntaxSyntax node with the specified changes.
 </summary>
	<param name="name">
 The new Name to update this XmlPrefixNameSyntaxSyntax node with. If not
 specified the current Name will be used in the new XmlPrefixNameSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlPrefixNameSyntax">
	<summary>
 Represents an XML name of the form 'name' appearing in GetXmlNamespace().
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.XmlNameSyntax.Prefix">
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlNameSyntax.WithPrefix(Roslyn.Compilers.VisualBasic.XmlPrefixSyntax)">
	<summary>
 Creates a new node and sets the Prefix property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlNameSyntax.WithLocalName(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the LocalName property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlNameSyntax.Update(Roslyn.Compilers.VisualBasic.XmlPrefixSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlNameSyntaxSyntax node with the specified changes.
 </summary>
	<param name="prefix">
 The new Prefix to update this XmlNameSyntaxSyntax node with. If not specified
 the current Prefix will be used in the new XmlNameSyntaxSyntax node.
 </param>
	<param name="localName">
 The new LocalName to update this XmlNameSyntaxSyntax node with. If not
 specified the current LocalName will be used in the new XmlNameSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlNameSyntax">
	<summary>
 Represents an XML name of the form 'name' or 'namespace:name' appearing in
 source as part of an XML literal or member access expression or an XML
 namespace import clause.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlBracketedNameSyntax.WithLessThanToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the LessThanToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlBracketedNameSyntax.WithName(Roslyn.Compilers.VisualBasic.XmlNameSyntax)">
	<summary>
 Creates a new node and sets the Name property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlBracketedNameSyntax.WithGreaterThanToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the GreaterThanToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlBracketedNameSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNameSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlBracketedNameSyntaxSyntax node with the specified changes.
 </summary>
	<param name="lessThanToken">
 The new LessThanToken to update this XmlBracketedNameSyntaxSyntax node with. If
 not specified the current LessThanToken will be used in the new
 XmlBracketedNameSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this XmlBracketedNameSyntaxSyntax node with. If not
 specified the current Name will be used in the new XmlBracketedNameSyntaxSyntax
 node.
 </param>
	<param name="greaterThanToken">
 The new GreaterThanToken to update this XmlBracketedNameSyntaxSyntax node with.
 If not specified the current GreaterThanToken will be used in the new
 XmlBracketedNameSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlBracketedNameSyntax">
	<summary>
 Represents an XML name of the form &lt;xml-name&gt; appearing in source as part
 of an XML literal or member access expression or an XML namespace import
 clause.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlPrefixSyntax.WithName(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Name property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlPrefixSyntax.WithColonToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ColonToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlPrefixSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlPrefixSyntaxSyntax node with the specified changes.
 </summary>
	<param name="name">
 The new Name to update this XmlPrefixSyntaxSyntax node with. If not specified
 the current Name will be used in the new XmlPrefixSyntaxSyntax node.
 </param>
	<param name="colonToken">
 The new ColonToken to update this XmlPrefixSyntaxSyntax node with. If not
 specified the current ColonToken will be used in the new XmlPrefixSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlPrefixSyntax">
	<summary>
 Represents and XML namespace prefix of the form 'prefix:' as in xml:ns="".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlCommentSyntax.WithLessThanMinusMinusToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the LessThanMinusMinusToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlCommentSyntax.WithTextTokens(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the TextTokens property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlCommentSyntax.WithMinusMinusGreaterThanToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the MinusMinusGreaterThanToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlCommentSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlCommentSyntaxSyntax node with the specified changes.
 </summary>
	<param name="lessThanMinusMinusToken">
 The new LessThanMinusMinusToken to update this XmlCommentSyntaxSyntax node
 with. If not specified the current LessThanMinusMinusToken will be used in the
 new XmlCommentSyntaxSyntax node.
 </param>
	<param name="textTokens">
 The new TextTokens to update this XmlCommentSyntaxSyntax node with. If not
 specified the current TextTokens will be used in the new XmlCommentSyntaxSyntax
 node.
 </param>
	<param name="minusMinusGreaterThanToken">
 The new MinusMinusGreaterThanToken to update this XmlCommentSyntaxSyntax node
 with. If not specified the current MinusMinusGreaterThanToken will be used in
 the new XmlCommentSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlCommentSyntax">
	<summary>
 Represents an XML comment of the form &lt;-- Comment --&gt; appearing in an XML
 literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlProcessingInstructionSyntax.WithLessThanQuestionToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the LessThanQuestionToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlProcessingInstructionSyntax.WithName(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Name property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlProcessingInstructionSyntax.WithTextTokens(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the TextTokens property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlProcessingInstructionSyntax.WithQuestionGreaterThanToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the QuestionGreaterThanToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlProcessingInstructionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlProcessingInstructionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="lessThanQuestionToken">
 The new LessThanQuestionToken to update this
 XmlProcessingInstructionSyntaxSyntax node with. If not specified the current
 LessThanQuestionToken will be used in the new
 XmlProcessingInstructionSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this XmlProcessingInstructionSyntaxSyntax node with. If
 not specified the current Name will be used in the new
 XmlProcessingInstructionSyntaxSyntax node.
 </param>
	<param name="textTokens">
 The new TextTokens to update this XmlProcessingInstructionSyntaxSyntax node
 with. If not specified the current TextTokens will be used in the new
 XmlProcessingInstructionSyntaxSyntax node.
 </param>
	<param name="questionGreaterThanToken">
 The new QuestionGreaterThanToken to update this
 XmlProcessingInstructionSyntaxSyntax node with. If not specified the current
 QuestionGreaterThanToken will be used in the new
 XmlProcessingInstructionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlProcessingInstructionSyntax">
	<summary>
 Represents an XML processing instruction of the form '&lt;? XMLProcessingTarget
 XMLProcessingValue ?&gt;'.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlCDataSectionSyntax.WithBeginCDataToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the BeginCDataToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlCDataSectionSyntax.WithTextTokens(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the TextTokens property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlCDataSectionSyntax.WithEndCDataToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the EndCDataToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlCDataSectionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlCDataSectionSyntaxSyntax node with the specified changes.
 </summary>
	<param name="beginCDataToken">
 The new BeginCDataToken to update this XmlCDataSectionSyntaxSyntax node with.
 If not specified the current BeginCDataToken will be used in the new
 XmlCDataSectionSyntaxSyntax node.
 </param>
	<param name="textTokens">
 The new TextTokens to update this XmlCDataSectionSyntaxSyntax node with. If not
 specified the current TextTokens will be used in the new
 XmlCDataSectionSyntaxSyntax node.
 </param>
	<param name="endCDataToken">
 The new EndCDataToken to update this XmlCDataSectionSyntaxSyntax node with. If
 not specified the current EndCDataToken will be used in the new
 XmlCDataSectionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlCDataSectionSyntax">
	<summary>
 Represents an XML CDATA section in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlEmbeddedExpressionSyntax.WithLessThanPercentEqualsToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the LessThanPercentEqualsToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlEmbeddedExpressionSyntax.WithExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Expression property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlEmbeddedExpressionSyntax.WithPercentGreaterThanToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the PercentGreaterThanToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.XmlEmbeddedExpressionSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new XmlEmbeddedExpressionSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="lessThanPercentEqualsToken">
 The new LessThanPercentEqualsToken to update this
 XmlEmbeddedExpressionSyntaxSyntax node with. If not specified the current
 LessThanPercentEqualsToken will be used in the new
 XmlEmbeddedExpressionSyntaxSyntax node.
 </param>
	<param name="expression">
 The new Expression to update this XmlEmbeddedExpressionSyntaxSyntax node with.
 If not specified the current Expression will be used in the new
 XmlEmbeddedExpressionSyntaxSyntax node.
 </param>
	<param name="percentGreaterThanToken">
 The new PercentGreaterThanToken to update this
 XmlEmbeddedExpressionSyntaxSyntax node with. If not specified the current
 PercentGreaterThanToken will be used in the new
 XmlEmbeddedExpressionSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlEmbeddedExpressionSyntax">
	<summary>
 Represents an embedded expression in an XML literal e.g. '&lt;name&gt;&lt;%=
 obj.Name =%&gt;&lt;/name&gt;'.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeSyntax">
	<summary>
 Abstract node class that represents the textual description of a type, possibly
 include generic type arguments, qualified names, array specifiers, nullable
 specifier and the like.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayTypeSyntax.ElementType">
	<summary>
 The type of the elements of the array.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayTypeSyntax.WithElementType(Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Creates a new node and sets the ElementType property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayTypeSyntax.RankSpecifiers">
	<summary>
 Represents the list of "()" or "(,,)" modifiers on the array type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayTypeSyntax.WithRankSpecifiers(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax})">
	<summary>
 Creates a new node and sets the RankSpecifiers property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayTypeSyntax.Update(Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax})">
	<summary>
 Creates a new ArrayTypeSyntaxSyntax node with the specified changes.
 </summary>
	<param name="elementType">
 The new ElementType to update this ArrayTypeSyntaxSyntax node with. If not
 specified the current ElementType will be used in the new ArrayTypeSyntaxSyntax
 node.
 </param>
	<param name="rankSpecifiers">
 The new RankSpecifiers to update this ArrayTypeSyntaxSyntax node with. If not
 specified the current RankSpecifiers will be used in the new
 ArrayTypeSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ArrayTypeSyntax">
	<summary>
 Represents an array type, such as "A() or "A(,)", without bounds specified for
 the array.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NullableTypeSyntax.ElementType">
	<summary>
 The kind of type that is this type is a nullable of. Cannot be an array type or
 a nullable type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NullableTypeSyntax.WithElementType(Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Creates a new node and sets the ElementType property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.NullableTypeSyntax.QuestionMarkToken">
	<summary>
 The "?" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NullableTypeSyntax.WithQuestionMarkToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the QuestionMarkToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.NullableTypeSyntax.Update(Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new NullableTypeSyntaxSyntax node with the specified changes.
 </summary>
	<param name="elementType">
 The new ElementType to update this NullableTypeSyntaxSyntax node with. If not
 specified the current ElementType will be used in the new
 NullableTypeSyntaxSyntax node.
 </param>
	<param name="questionMarkToken">
 The new QuestionMarkToken to update this NullableTypeSyntaxSyntax node with. If
 not specified the current QuestionMarkToken will be used in the new
 NullableTypeSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.NullableTypeSyntax">
	<summary>
 A type name that represents a nullable type, such as "Integer?".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PredefinedTypeSyntax.Keyword">
	<summary>
 The keyword that was used to describe the built-in type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PredefinedTypeSyntax.WithKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Keyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.PredefinedTypeSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new PredefinedTypeSyntaxSyntax node with the specified changes.
 </summary>
	<param name="keyword">
 The new Keyword to update this PredefinedTypeSyntaxSyntax node with. If not
 specified the current Keyword will be used in the new
 PredefinedTypeSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.PredefinedTypeSyntax">
	<summary>
 Represents an occurrence of a Visual Basic built-in type such as Integer or
 String in source code.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.NameSyntax">
	<summary>
 Abstract node class that represents a name, possibly include generic arguments
 and qualified names.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SimpleNameSyntax.Identifier">
	<summary>
 The identifier in the name.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SimpleNameSyntax">
	<summary>
 Abstract node class that represents a name, possibly include generic arguments.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.IdentifierNameSyntax.Identifier">
	<summary>
 The identifier in the name.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.IdentifierNameSyntax.WithIdentifier(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Identifier property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.IdentifierNameSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new IdentifierNameSyntaxSyntax node with the specified changes.
 </summary>
	<param name="identifier">
 The new Identifier to update this IdentifierNameSyntaxSyntax node with. If not
 specified the current Identifier will be used in the new
 IdentifierNameSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.IdentifierNameSyntax">
	<summary>
 Represents a type name consisting of a single identifier (which might include
 brackets or a type character).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GenericNameSyntax.Identifier">
	<summary>
 The identifier in the name.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GenericNameSyntax.WithIdentifier(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Identifier property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.GenericNameSyntax.TypeArgumentList">
	<summary>
 The generic argument list.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GenericNameSyntax.WithTypeArgumentList(Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax)">
	<summary>
 Creates a new node and sets the TypeArgumentList property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.GenericNameSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax)">
	<summary>
 Creates a new GenericNameSyntaxSyntax node with the specified changes.
 </summary>
	<param name="identifier">
 The new Identifier to update this GenericNameSyntaxSyntax node with. If not
 specified the current Identifier will be used in the new
 GenericNameSyntaxSyntax node.
 </param>
	<param name="typeArgumentList">
 The new TypeArgumentList to update this GenericNameSyntaxSyntax node with. If
 not specified the current TypeArgumentList will be used in the new
 GenericNameSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.GenericNameSyntax">
	<summary>
 Represents a simple type name with one or more generic arguments, such as "X(Of
 Y, Z).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.QualifiedNameSyntax.Left">
	<summary>
 The part of the name that appears to the left of the dot. This can itself be
 any name.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.QualifiedNameSyntax.WithLeft(Roslyn.Compilers.VisualBasic.NameSyntax)">
	<summary>
 Creates a new node and sets the Left property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.QualifiedNameSyntax.DotToken">
	<summary>
 The "." token that separates the names.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.QualifiedNameSyntax.WithDotToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the DotToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.QualifiedNameSyntax.Right">
	<summary>
 The part of the name that appears to the right of the dot. This must be a
 simple identifier.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.QualifiedNameSyntax.WithRight(Roslyn.Compilers.VisualBasic.SimpleNameSyntax)">
	<summary>
 Creates a new node and sets the Right property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.QualifiedNameSyntax.Update(Roslyn.Compilers.VisualBasic.NameSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SimpleNameSyntax)">
	<summary>
 Creates a new QualifiedNameSyntaxSyntax node with the specified changes.
 </summary>
	<param name="left">
 The new Left to update this QualifiedNameSyntaxSyntax node with. If not
 specified the current Left will be used in the new QualifiedNameSyntaxSyntax
 node.
 </param>
	<param name="dotToken">
 The new DotToken to update this QualifiedNameSyntaxSyntax node with. If not
 specified the current DotToken will be used in the new
 QualifiedNameSyntaxSyntax node.
 </param>
	<param name="right">
 The new Right to update this QualifiedNameSyntaxSyntax node with. If not
 specified the current Right will be used in the new QualifiedNameSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.QualifiedNameSyntax">
	<summary>
 Represents a qualified type name, for example X.Y or X(Of Z).Y.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GlobalNameSyntax.GlobalKeyword">
	<summary>
 The "Global" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GlobalNameSyntax.WithGlobalKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the GlobalKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.GlobalNameSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new GlobalNameSyntaxSyntax node with the specified changes.
 </summary>
	<param name="globalKeyword">
 The new GlobalKeyword to update this GlobalNameSyntaxSyntax node with. If not
 specified the current GlobalKeyword will be used in the new
 GlobalNameSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.GlobalNameSyntax">
	<summary>
 Represents a name in the global namespace.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax.WithOpenParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OpenParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax.OfKeyword">
	<summary>
 The "Of" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax.WithOfKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OfKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax.Arguments">
	<summary>
 A list of all the type arguments.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax.WithArguments(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeSyntax})">
	<summary>
 Creates a new node and sets the Arguments property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax.WithCloseParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CloseParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new TypeArgumentListSyntaxSyntax node with the specified changes.
 </summary>
	<param name="openParenToken">
 The new OpenParenToken to update this TypeArgumentListSyntaxSyntax node with.
 If not specified the current OpenParenToken will be used in the new
 TypeArgumentListSyntaxSyntax node.
 </param>
	<param name="ofKeyword">
 The new OfKeyword to update this TypeArgumentListSyntaxSyntax node with. If not
 specified the current OfKeyword will be used in the new
 TypeArgumentListSyntaxSyntax node.
 </param>
	<param name="arguments">
 The new Arguments to update this TypeArgumentListSyntaxSyntax node with. If not
 specified the current Arguments will be used in the new
 TypeArgumentListSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this TypeArgumentListSyntaxSyntax node with.
 If not specified the current CloseParenToken will be used in the new
 TypeArgumentListSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax">
	<summary>
 Represents a parenthesized list of generic type arguments.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.StructuredTriviaSyntax">
	<summary>
 Abstract class that represent structured trivia.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SkippedTokensTriviaSyntax.Tokens">
	<summary>
 The list of tokens that were skipped by the parser.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SkippedTokensTriviaSyntax.WithTokens(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new node and sets the Tokens property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SkippedTokensTriviaSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Creates a new SkippedTokensTriviaSyntaxSyntax node with the specified changes.
 </summary>
	<param name="tokens">
 The new Tokens to update this SkippedTokensTriviaSyntaxSyntax node with. If not
 specified the current Tokens will be used in the new
 SkippedTokensTriviaSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SkippedTokensTriviaSyntax">
	<summary>
 Represents tokens that were skipped by the parser as part of error recovery,
 and thus are not part of any syntactic structure.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DocumentationCommentTriviaSyntax.Content">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DocumentationCommentTriviaSyntax.WithContent(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax})">
	<summary>
 Creates a new node and sets the Content property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DocumentationCommentTriviaSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax})">
	<summary>
 Creates a new DocumentationCommentTriviaSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="content">
 The new Content to update this DocumentationCommentTriviaSyntaxSyntax node
 with. If not specified the current Content will be used in the new
 DocumentationCommentTriviaSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.DocumentationCommentTriviaSyntax">
	<summary>
 Represents a documentation comment e.g. ''' &lt;Summary&gt; apearing in source.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DirectiveTriviaSyntax.WithDirective(Roslyn.Compilers.VisualBasic.DirectiveStatementSyntax)">
	<summary>
 Creates a new node and sets the Directive property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.DirectiveTriviaSyntax.Terminator">
	<summary>
 The statement terminator token that ended the Directive.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DirectiveTriviaSyntax.WithTerminator(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Terminator property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DirectiveTriviaSyntax.Update(Roslyn.Compilers.VisualBasic.DirectiveStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new DirectiveTriviaSyntaxSyntax node with the specified changes.
 </summary>
	<param name="directive">
 The new Directive to update this DirectiveTriviaSyntaxSyntax node with. If not
 specified the current Directive will be used in the new
 DirectiveTriviaSyntaxSyntax node.
 </param>
	<param name="terminator">
 The new Terminator to update this DirectiveTriviaSyntaxSyntax node with. If not
 specified the current Terminator will be used in the new
 DirectiveTriviaSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.DirectiveTriviaSyntax">
	<summary>
 Represents a preprocessor directive
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DirectiveStatementSyntax.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.DirectiveStatementSyntax">
	<summary>
 Represents a pre-processing directive (such as #If, #Const or #Region)
 appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ConstDirectiveSyntax.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ConstDirectiveSyntax.WithHashToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the HashToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ConstDirectiveSyntax.ConstKeyword">
	<summary>
 The "Const" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ConstDirectiveSyntax.WithConstKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ConstKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ConstDirectiveSyntax.Name">
	<summary>
 The name of the pre-processing constant being defined.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ConstDirectiveSyntax.WithName(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Name property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ConstDirectiveSyntax.EqualsToken">
	<summary>
 The "=" token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ConstDirectiveSyntax.WithEqualsToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the EqualsToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ConstDirectiveSyntax.Value">
	<summary>
 An expression representing the value of the pre-processing constant being
 defined.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ConstDirectiveSyntax.WithValue(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Value property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ConstDirectiveSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new ConstDirectiveSyntaxSyntax node with the specified changes.
 </summary>
	<param name="hashToken">
 The new HashToken to update this ConstDirectiveSyntaxSyntax node with. If not
 specified the current HashToken will be used in the new
 ConstDirectiveSyntaxSyntax node.
 </param>
	<param name="constKeyword">
 The new ConstKeyword to update this ConstDirectiveSyntaxSyntax node with. If
 not specified the current ConstKeyword will be used in the new
 ConstDirectiveSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this ConstDirectiveSyntaxSyntax node with. If not
 specified the current Name will be used in the new ConstDirectiveSyntaxSyntax
 node.
 </param>
	<param name="equalsToken">
 The new EqualsToken to update this ConstDirectiveSyntaxSyntax node with. If not
 specified the current EqualsToken will be used in the new
 ConstDirectiveSyntaxSyntax node.
 </param>
	<param name="value">
 The new Value to update this ConstDirectiveSyntaxSyntax node with. If not
 specified the current Value will be used in the new ConstDirectiveSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ConstDirectiveSyntax">
	<summary>
 Represents a #Const pre-processing constant declaration appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.IfDirectiveSyntax.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.IfDirectiveSyntax.WithHashToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the HashToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.IfDirectiveSyntax.ElseKeyword">
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.IfDirectiveSyntax.WithElseKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ElseKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.IfDirectiveSyntax.WithIfOrElseIfKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the IfOrElseIfKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.IfDirectiveSyntax.WithCondition(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Creates a new node and sets the Condition property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.IfDirectiveSyntax.ThenKeyword">
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.IfDirectiveSyntax.WithThenKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ThenKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.IfDirectiveSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new IfDirectiveSyntaxSyntax node with the specified changes.
 </summary>
	<param name="hashToken">
 The new HashToken to update this IfDirectiveSyntaxSyntax node with. If not
 specified the current HashToken will be used in the new IfDirectiveSyntaxSyntax
 node.
 </param>
	<param name="elseKeyword">
 The new ElseKeyword to update this IfDirectiveSyntaxSyntax node with. If not
 specified the current ElseKeyword will be used in the new
 IfDirectiveSyntaxSyntax node.
 </param>
	<param name="ifOrElseIfKeyword">
 The new IfOrElseIfKeyword to update this IfDirectiveSyntaxSyntax node with. If
 not specified the current IfOrElseIfKeyword will be used in the new
 IfDirectiveSyntaxSyntax node.
 </param>
	<param name="condition">
 The new Condition to update this IfDirectiveSyntaxSyntax node with. If not
 specified the current Condition will be used in the new IfDirectiveSyntaxSyntax
 node.
 </param>
	<param name="thenKeyword">
 The new ThenKeyword to update this IfDirectiveSyntaxSyntax node with. If not
 specified the current ThenKeyword will be used in the new
 IfDirectiveSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.IfDirectiveSyntax">
	<summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ElseDirectiveSyntax.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ElseDirectiveSyntax.WithHashToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the HashToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ElseDirectiveSyntax.WithElseKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ElseKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ElseDirectiveSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new ElseDirectiveSyntaxSyntax node with the specified changes.
 </summary>
	<param name="hashToken">
 The new HashToken to update this ElseDirectiveSyntaxSyntax node with. If not
 specified the current HashToken will be used in the new
 ElseDirectiveSyntaxSyntax node.
 </param>
	<param name="elseKeyword">
 The new ElseKeyword to update this ElseDirectiveSyntaxSyntax node with. If not
 specified the current ElseKeyword will be used in the new
 ElseDirectiveSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ElseDirectiveSyntax">
	<summary>
 Represents an #Else pre-processing directive appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EndIfDirectiveSyntax.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EndIfDirectiveSyntax.WithHashToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the HashToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EndIfDirectiveSyntax.WithEndKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the EndKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EndIfDirectiveSyntax.WithIfKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the IfKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EndIfDirectiveSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new EndIfDirectiveSyntaxSyntax node with the specified changes.
 </summary>
	<param name="hashToken">
 The new HashToken to update this EndIfDirectiveSyntaxSyntax node with. If not
 specified the current HashToken will be used in the new
 EndIfDirectiveSyntaxSyntax node.
 </param>
	<param name="endKeyword">
 The new EndKeyword to update this EndIfDirectiveSyntaxSyntax node with. If not
 specified the current EndKeyword will be used in the new
 EndIfDirectiveSyntaxSyntax node.
 </param>
	<param name="ifKeyword">
 The new IfKeyword to update this EndIfDirectiveSyntaxSyntax node with. If not
 specified the current IfKeyword will be used in the new
 EndIfDirectiveSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.EndIfDirectiveSyntax">
	<summary>
 Represents an #End If pre-processing directive appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.RegionDirectiveSyntax.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.RegionDirectiveSyntax.WithHashToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the HashToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.RegionDirectiveSyntax.RegionKeyword">
	<summary>
 The "Region" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.RegionDirectiveSyntax.WithRegionKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the RegionKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.RegionDirectiveSyntax.Name">
	<summary>
 The label of the code region being defined.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.RegionDirectiveSyntax.WithName(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Name property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.RegionDirectiveSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new RegionDirectiveSyntaxSyntax node with the specified changes.
 </summary>
	<param name="hashToken">
 The new HashToken to update this RegionDirectiveSyntaxSyntax node with. If not
 specified the current HashToken will be used in the new
 RegionDirectiveSyntaxSyntax node.
 </param>
	<param name="regionKeyword">
 The new RegionKeyword to update this RegionDirectiveSyntaxSyntax node with. If
 not specified the current RegionKeyword will be used in the new
 RegionDirectiveSyntaxSyntax node.
 </param>
	<param name="name">
 The new Name to update this RegionDirectiveSyntaxSyntax node with. If not
 specified the current Name will be used in the new RegionDirectiveSyntaxSyntax
 node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.RegionDirectiveSyntax">
	<summary>
 Represents the beginning of a #Region directive appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EndRegionDirectiveSyntax.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EndRegionDirectiveSyntax.WithHashToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the HashToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EndRegionDirectiveSyntax.EndKeyword">
	<summary>
 The "End" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EndRegionDirectiveSyntax.WithEndKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the EndKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EndRegionDirectiveSyntax.RegionKeyword">
	<summary>
 The "Region" keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EndRegionDirectiveSyntax.WithRegionKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the RegionKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EndRegionDirectiveSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new EndRegionDirectiveSyntaxSyntax node with the specified changes.
 </summary>
	<param name="hashToken">
 The new HashToken to update this EndRegionDirectiveSyntaxSyntax node with. If
 not specified the current HashToken will be used in the new
 EndRegionDirectiveSyntaxSyntax node.
 </param>
	<param name="endKeyword">
 The new EndKeyword to update this EndRegionDirectiveSyntaxSyntax node with. If
 not specified the current EndKeyword will be used in the new
 EndRegionDirectiveSyntaxSyntax node.
 </param>
	<param name="regionKeyword">
 The new RegionKeyword to update this EndRegionDirectiveSyntaxSyntax node with.
 If not specified the current RegionKeyword will be used in the new
 EndRegionDirectiveSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.EndRegionDirectiveSyntax">
	<summary>
 Represents an #End Region directive appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ExternalSourceDirectiveSyntax.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExternalSourceDirectiveSyntax.WithHashToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the HashToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExternalSourceDirectiveSyntax.WithExternalSourceKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ExternalSourceKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExternalSourceDirectiveSyntax.WithOpenParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OpenParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExternalSourceDirectiveSyntax.WithExternalSource(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ExternalSource property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExternalSourceDirectiveSyntax.WithCommaToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CommaToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExternalSourceDirectiveSyntax.WithLineStart(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the LineStart property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExternalSourceDirectiveSyntax.WithCloseParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CloseParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExternalSourceDirectiveSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new ExternalSourceDirectiveSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="hashToken">
 The new HashToken to update this ExternalSourceDirectiveSyntaxSyntax node with.
 If not specified the current HashToken will be used in the new
 ExternalSourceDirectiveSyntaxSyntax node.
 </param>
	<param name="externalSourceKeyword">
 The new ExternalSourceKeyword to update this
 ExternalSourceDirectiveSyntaxSyntax node with. If not specified the current
 ExternalSourceKeyword will be used in the new
 ExternalSourceDirectiveSyntaxSyntax node.
 </param>
	<param name="openParenToken">
 The new OpenParenToken to update this ExternalSourceDirectiveSyntaxSyntax node
 with. If not specified the current OpenParenToken will be used in the new
 ExternalSourceDirectiveSyntaxSyntax node.
 </param>
	<param name="externalSource">
 The new ExternalSource to update this ExternalSourceDirectiveSyntaxSyntax node
 with. If not specified the current ExternalSource will be used in the new
 ExternalSourceDirectiveSyntaxSyntax node.
 </param>
	<param name="commaToken">
 The new CommaToken to update this ExternalSourceDirectiveSyntaxSyntax node
 with. If not specified the current CommaToken will be used in the new
 ExternalSourceDirectiveSyntaxSyntax node.
 </param>
	<param name="lineStart">
 The new LineStart to update this ExternalSourceDirectiveSyntaxSyntax node with.
 If not specified the current LineStart will be used in the new
 ExternalSourceDirectiveSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this ExternalSourceDirectiveSyntaxSyntax node
 with. If not specified the current CloseParenToken will be used in the new
 ExternalSourceDirectiveSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ExternalSourceDirectiveSyntax">
	<summary>
 Represents the beginning of a #ExternalSource pre-processing directive
 appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EndExternalSourceDirective.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EndExternalSourceDirective.WithHashToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the HashToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EndExternalSourceDirective.WithEndKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the EndKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EndExternalSourceDirective.WithExternalSourceKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ExternalSourceKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.EndExternalSourceDirective.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new EndExternalSourceDirectiveSyntax node with the specified changes.
 </summary>
	<param name="hashToken">
 The new HashToken to update this EndExternalSourceDirectiveSyntax node with. If
 not specified the current HashToken will be used in the new
 EndExternalSourceDirectiveSyntax node.
 </param>
	<param name="endKeyword">
 The new EndKeyword to update this EndExternalSourceDirectiveSyntax node with.
 If not specified the current EndKeyword will be used in the new
 EndExternalSourceDirectiveSyntax node.
 </param>
	<param name="externalSourceKeyword">
 The new ExternalSourceKeyword to update this EndExternalSourceDirectiveSyntax
 node with. If not specified the current ExternalSourceKeyword will be used in
 the new EndExternalSourceDirectiveSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.EndExternalSourceDirective">
	<summary>
 Represents an #End ExternalSource pre-processing directive appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ExternalChecksumDirectiveSyntax.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExternalChecksumDirectiveSyntax.WithHashToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the HashToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExternalChecksumDirectiveSyntax.WithExternalChecksumKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ExternalChecksumKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExternalChecksumDirectiveSyntax.WithOpenParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the OpenParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExternalChecksumDirectiveSyntax.WithExternalSource(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ExternalSource property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExternalChecksumDirectiveSyntax.WithFirstCommaToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the FirstCommaToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExternalChecksumDirectiveSyntax.WithGuid(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Guid property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExternalChecksumDirectiveSyntax.WithSecondCommaToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the SecondCommaToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExternalChecksumDirectiveSyntax.WithChecksum(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the Checksum property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExternalChecksumDirectiveSyntax.WithCloseParenToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the CloseParenToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExternalChecksumDirectiveSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new ExternalChecksumDirectiveSyntaxSyntax node with the specified
 changes.
 </summary>
	<param name="hashToken">
 The new HashToken to update this ExternalChecksumDirectiveSyntaxSyntax node
 with. If not specified the current HashToken will be used in the new
 ExternalChecksumDirectiveSyntaxSyntax node.
 </param>
	<param name="externalChecksumKeyword">
 The new ExternalChecksumKeyword to update this
 ExternalChecksumDirectiveSyntaxSyntax node with. If not specified the current
 ExternalChecksumKeyword will be used in the new
 ExternalChecksumDirectiveSyntaxSyntax node.
 </param>
	<param name="openParenToken">
 The new OpenParenToken to update this ExternalChecksumDirectiveSyntaxSyntax
 node with. If not specified the current OpenParenToken will be used in the new
 ExternalChecksumDirectiveSyntaxSyntax node.
 </param>
	<param name="externalSource">
 The new ExternalSource to update this ExternalChecksumDirectiveSyntaxSyntax
 node with. If not specified the current ExternalSource will be used in the new
 ExternalChecksumDirectiveSyntaxSyntax node.
 </param>
	<param name="firstCommaToken">
 The new FirstCommaToken to update this ExternalChecksumDirectiveSyntaxSyntax
 node with. If not specified the current FirstCommaToken will be used in the new
 ExternalChecksumDirectiveSyntaxSyntax node.
 </param>
	<param name="guid">
 The new Guid to update this ExternalChecksumDirectiveSyntaxSyntax node with. If
 not specified the current Guid will be used in the new
 ExternalChecksumDirectiveSyntaxSyntax node.
 </param>
	<param name="secondCommaToken">
 The new SecondCommaToken to update this ExternalChecksumDirectiveSyntaxSyntax
 node with. If not specified the current SecondCommaToken will be used in the
 new ExternalChecksumDirectiveSyntaxSyntax node.
 </param>
	<param name="checksum">
 The new Checksum to update this ExternalChecksumDirectiveSyntaxSyntax node
 with. If not specified the current Checksum will be used in the new
 ExternalChecksumDirectiveSyntaxSyntax node.
 </param>
	<param name="closeParenToken">
 The new CloseParenToken to update this ExternalChecksumDirectiveSyntaxSyntax
 node with. If not specified the current CloseParenToken will be used in the new
 ExternalChecksumDirectiveSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ExternalChecksumDirectiveSyntax">
	<summary>
 Represents an #ExternalChecksum pre-processing directive appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ReferenceDirectiveSyntax.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ReferenceDirectiveSyntax.WithHashToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the HashToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ReferenceDirectiveSyntax.WithReferenceKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the ReferenceKeyword property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ReferenceDirectiveSyntax.WithFile(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the File property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ReferenceDirectiveSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new ReferenceDirectiveSyntaxSyntax node with the specified changes.
 </summary>
	<param name="hashToken">
 The new HashToken to update this ReferenceDirectiveSyntaxSyntax node with. If
 not specified the current HashToken will be used in the new
 ReferenceDirectiveSyntaxSyntax node.
 </param>
	<param name="referenceKeyword">
 The new ReferenceKeyword to update this ReferenceDirectiveSyntaxSyntax node
 with. If not specified the current ReferenceKeyword will be used in the new
 ReferenceDirectiveSyntaxSyntax node.
 </param>
	<param name="file">
 The new File to update this ReferenceDirectiveSyntaxSyntax node with. If not
 specified the current File will be used in the new
 ReferenceDirectiveSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ReferenceDirectiveSyntax">
	<summary>
 Represents an #r directive appearing in scripts.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BadDirectiveSyntax.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BadDirectiveSyntax.WithHashToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new node and sets the HashToken property
 </summary>
	<remarks>
 Returns a new node with the property set
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.BadDirectiveSyntax.Update(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Creates a new BadDirectiveSyntaxSyntax node with the specified changes.
 </summary>
	<param name="hashToken">
 The new HashToken to update this BadDirectiveSyntaxSyntax node with. If not
 specified the current HashToken will be used in the new
 BadDirectiveSyntaxSyntax node.
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.BadDirectiveSyntax">
	<summary>
 Represents an unrecognized pre-processing directive. This occurs when the
 parser encounters a hash '#' token at the beginning of a physical line but does
 recognize the text that follows as a valid Visual Basic pre-processing
 directive.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode">
	<summary>
 The base class for all nodes in the VB syntax tree.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax">
	<summary>
 The base class for all nodes that represent statements. This includes both
 declaration statements, such as class declarations as well as executable
 statements.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ExecutableStatementSyntax">
	<summary>
 The base class for all nodes that represent executable statements.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.DeclarationStatementSyntax">
	<summary>
 The base class for all nodes that represent statements that declare options,
 imports, members, etc.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EmptyStatementSyntax.Empty">
	<summary>
 An empty token because all non terminals must have a token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EmptyStatementSyntax">
	<summary>
 A class to represent an empty statement. This can occur when a colon is on a
 line without anything else.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax.EndKeyword">
	<summary>
 The "End" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax.BlockKeyword">
	<summary>
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CompilationUnitSyntax.Options">
	<summary>
 Represents the list of Option statements at the beginning of a source file.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CompilationUnitSyntax.Imports">
	<summary>
 Represents the list of Imports statements at the beginning of a source file.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CompilationUnitSyntax.Attributes">
	<summary>
 Represents the list of AttributeStatements at the beginning of a source file
 that contain the Assembly and Module attributes.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CompilationUnitSyntax.Members">
	<summary>
 Represents the members of the default namespace for this source file: all the
 top-level type and namespace declarations in the file. May also contain
 Statements that are not valid
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CompilationUnitSyntax.EndOfFileToken">
	<summary>
 Represents the end of the source file. This token may have trivia (whitespace,
 comments, ...) attached to it.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CompilationUnitSyntax">
	<summary>
 Represents an entire source file of VB code.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OptionStatementSyntax.OptionKeyword">
	<summary>
 The "Option" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OptionStatementSyntax.NameKeyword">
	<summary>
 The keyword that identifies the option being set: Explicit, Strict, Compare or
 Infer.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OptionStatementSyntax.ValueKeyword">
	<summary>
 The keyword that identifiers the value being set for the opition: On, Off, Text
 or Binary.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.OptionStatementSyntax">
	<summary>
 Represents an Option statement, such as "Option Strict On".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ImportsStatementSyntax.ImportsKeyword">
	<summary>
 The "Imports" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ImportsStatementSyntax.ImportsClauses">
	<summary>
 A list of one or more import clauses. Each clause is either an alias, namespace
 or XML namespace import.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ImportsStatementSyntax">
	<summary>
 Represents an Imports statement, which has one or more imports clauses.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ImportsClauseSyntax">
	<summary>
 The base class for the possible clauses of an Imports statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AliasImportsClauseSyntax.Alias">
	<summary>
 The identifier that the alias is being defined for.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AliasImportsClauseSyntax.EqualsToken">
	<summary>
 The equals sign token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AliasImportsClauseSyntax.Name">
	<summary>
 The namespace or type the alias refers to.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AliasImportsClauseSyntax">
	<summary>
 Represents the clause of an Imports statement that defines an alias for a
 namespace or type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MembersImportsClauseSyntax.Name">
	<summary>
 The namespace or type being imported.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.MembersImportsClauseSyntax">
	<summary>
 Represents the clause of an Imports statement that imports all members of a
 namespace.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNamespaceImportsClauseSyntax.XmlNamespace">
	<summary>
 Identifies the XML namespace alias and URI.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNamespaceImportsClauseSyntax">
	<summary>
 Defines a XML namespace for XML expressions.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamespaceBlockSyntax.Begin">
	<summary>
 The statement that begins the NamespaceBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamespaceBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamespaceBlockSyntax.Members">
	<summary>
 The declarations contained in the namespace statement.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamespaceBlockSyntax.End">
	<summary>
 The End Namespace statement that ends the block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.NamespaceBlockSyntax">
	<summary>
 Represents a Namespace statement, its contents and the End Namespace statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamespaceStatementSyntax.NamespaceKeyword">
	<summary>
 The "Namespace" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamespaceStatementSyntax.Name">
	<summary>
 A (possibly dotted) name denoting the namespace being declared.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.NamespaceStatementSyntax">
	<summary>
 Represents the beginning statement of a namespace declaration. This node always
 appears as the Begin of a BlockStatement with Kind=NamespaceBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeBlockSyntax.Begin">
	<summary>
 The statement that begins the type or module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeBlockSyntax.Inherits">
	<summary>
 A list of the Inherits declarations for the type.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeBlockSyntax.Implements">
	<summary>
 A list of the Implements declarations for the type.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeBlockSyntax.Members">
	<summary>
 The declarations contained in the type or module.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeBlockSyntax.End">
	<summary>
 The End XXX statement that ends the block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeBlockSyntax">
	<summary>
 Represents a declaration of a Class, Interface, Structure, Module, its contents
 and the End statement that ends it.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ModuleBlockSyntax">
	<summary>
 Represents a declaration of Module, its contents and the End statement that
 ends it.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.StructureBlockSyntax">
	<summary>
 Represents a declaration of a Structure, its contents and the End statement
 that ends it.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.InterfaceBlockSyntax">
	<summary>
 Represents a declaration of a Interface, its contents and the End statement
 that ends it.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ClassBlockSyntax">
	<summary>
 Represents a declaration of a Class its contents and the End statement that
 ends it.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumBlockSyntax.Begin">
	<summary>
 The statement that begins the type or module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumBlockSyntax.Members">
	<summary>
 The declarations contained in the enumeration.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumBlockSyntax.End">
	<summary>
 The End XXX statement that ends the block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumBlockSyntax">
	<summary>
 Represents a declaration of an Enum, its contents and the End Enum statement
 that ends it.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.InheritsOrImplementsStatementSyntax">
	<summary>
 Represents an Inherits or Implements statement in a Class, Structure or
 Interface.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.InheritsStatementSyntax.InheritsKeyword">
	<summary>
 The "Inherits" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.InheritsStatementSyntax.Types">
	<summary>
 A list of the types being inherited.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.InheritsStatementSyntax">
	<summary>
 Represents an Inherits statement in a Class, Structure or Interface.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsStatementSyntax.ImplementsKeyword">
	<summary>
 The "Implements" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsStatementSyntax.Types">
	<summary>
 A list of the types being implemented.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsStatementSyntax">
	<summary>
 Represents an Implements statement in a Class or Structure.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeStatementSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeStatementSyntax.Keyword">
	<summary>
 The "Module", "Class", "Interface" or "Structure" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeStatementSyntax.Identifier">
	<summary>
 The name of the type being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeStatementSyntax.TypeParameterList">
	<summary>
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeStatementSyntax">
	<summary>
 Abstract class for the beginning statement of a Module, Class, Interface or
 Structure declaration. This node always appears as the Begin of a TypeBlock
 with Kind=ModuleDeclarationBlock, ClassDeclarationBlock,
 InterfaceDeclarationBlock or StructureDeclarationBlock.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ModuleStatementSyntax">
	<summary>
 Represents the beginning statement of a Module declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.StructureStatementSyntax">
	<summary>
 Represents the beginning statement of a Structure declaration. This node always
 appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.InterfaceStatementSyntax">
	<summary>
 Represents the beginning statement of a Interface declaration. This node always
 appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ClassStatementSyntax">
	<summary>
 Represents the beginning statement of a Class declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumStatementSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumStatementSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumStatementSyntax.EnumKeyword">
	<summary>
 The "Enum" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumStatementSyntax.Identifier">
	<summary>
 The name of the enum being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumStatementSyntax.UnderlyingType">
	<summary>
 Optional "As XXX" clause describing the underlying type of the enumeration. If
 no As clause was specified, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumStatementSyntax">
	<summary>
 Represents the beginning statement of an Enum declaration. This node always
 appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax.OfKeyword">
	<summary>
 The "Of" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax.Parameters">
	<summary>
 A list of the type parameters. There must be at least one type parameter in the
 list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax">
	<summary>
 Represents the type parameter list in a declaration.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterSyntax.VarianceKeyword">
	<summary>
 Represents the "In" or "Out" variance keyword on a type parameter, if present.
 If no variance modifier was present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterSyntax.Identifier">
	<summary>
 The name of the type parameter
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterSyntax.TypeParameterConstraintClause">
	<summary>
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterSyntax">
	<summary>
 Represents a type parameter on a generic type declaration.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterConstraintClauseSyntax">
	<summary>
 An abstract node class that is the parent of classes that describe type
 parameter constraint clauses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterSingleConstraintClauseSyntax.AsKeyword">
	<summary>
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterSingleConstraintClauseSyntax.Constraint">
	<summary>
 A list of the supplied constraints. If no constraints were supplied, Nothing is
 returned.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterSingleConstraintClauseSyntax">
	<summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As Constraint".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterMultipleConstraintClauseSyntax.AsKeyword">
	<summary>
 The "As" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterMultipleConstraintClauseSyntax.OpenBraceToken">
	<summary>
 The "{" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterMultipleConstraintClauseSyntax.Constraints">
	<summary>
 A list of the supplied constraints. If no constraints were supplied, an empty
 list is returned.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterMultipleConstraintClauseSyntax.CloseBraceToken">
	<summary>
 The "}" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterMultipleConstraintClauseSyntax">
	<summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As { Constraints }".
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ConstraintSyntax">
	<summary>
 An abstract node class that is the parent of classes that describe type
 parameter constraints.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SpecialConstraintSyntax.ConstraintKeyword">
	<summary>
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SpecialConstraintSyntax">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeConstraintSyntax.Type">
	<summary>
 The type describing the constraint.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeConstraintSyntax">
	<summary>
 Represents a type parameter constraint that is a type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumMemberDeclarationSyntax.AttributeLists">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumMemberDeclarationSyntax.Initializer">
	<summary>
 An optional value for the enum member.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EnumMemberDeclarationSyntax">
	<summary>
 Represents a name and value in an EnumDeclarationBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBlockSyntax.Begin">
	<summary>
 The declaration that begins the block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBlockSyntax.Statements">
	<summary>
 The statements contained in the block statement. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBlockSyntax.End">
	<summary>
 The End XXX statement that ends the block declaration.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBlockSyntax">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PropertyBlockSyntax.Begin">
	<summary>
 The property declaration that begins the block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PropertyBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PropertyBlockSyntax.Accessors">
	<summary>
 The accessor blocks contained in the property, between the Property and the End
 Property statements.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PropertyBlockSyntax.End">
	<summary>
 The End Property statement that ends the block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.PropertyBlockSyntax">
	<summary>
 Represents a block property declaration: A declaration that has a beginning
 declaration, some get or set accessor blocks and an end statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EventBlockSyntax.Begin">
	<summary>
 The event declaration that begins the block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EventBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EventBlockSyntax.Accessors">
	<summary>
 The accessor blocks contained in the custom event declaration, between the
 Event statement and the End Event statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EventBlockSyntax.End">
	<summary>
 The End Event statement that ends the block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EventBlockSyntax">
	<summary>
 Represents a custom event declaration: A declaration that has a beginning event
 declaration, some accessor blocks and an end statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax.Keyword">
	<summary>
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax.ParameterList">
	<summary>
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax.AsClause">
	<summary>
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax">
	<summary>
 An abstract node class that is the parent for declarations that are
 "method-like"; i.e., that have a parameter list and return type. This includes
 methods, constructors, properties, events, operators, declares, delegates,
 property accessors and custom event accessors.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax.OpenParenToken">
	<summary>
 The "(" token that introduces the parameter list. If no parameter list was
 present, Nothing is returned.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax.Parameters">
	<summary>
 The list of parameters. If no parameter list was present, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax.CloseParenToken">
	<summary>
 The ")" token that concludes the parameter list. If no parameter list was
 present, Nothing is returned.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax">
	<summary>
 Represents the parameter list in a method declaration.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodStatementSyntax.Identifier">
	<summary>
 The name of the method being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodStatementSyntax.TypeParameterList">
	<summary>
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodStatementSyntax.HandlesClause">
	<summary>
 If present, a Handles clause indicated the events that this method handles.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodStatementSyntax.ImplementsClause">
	<summary>
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.MethodStatementSyntax">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ConstructorStatementSyntax.NewKeyword">
	<summary>
 The "New" keyword in the constructor declaration.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ConstructorStatementSyntax">
	<summary>
 A statement that declares a constructor. This statement will be the Begin of a
 BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
 will be the Body of that BlockStatement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DeclareStatementSyntax.DeclareKeyword">
	<summary>
 The "Declare" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DeclareStatementSyntax.CharsetKeyword">
	<summary>
 If present, the keyword that defines the string translation semantics of the
 external method.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DeclareStatementSyntax.Identifier">
	<summary>
 The name of the method being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DeclareStatementSyntax.LibKeyword">
	<summary>
 The "Lib" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DeclareStatementSyntax.LibraryName">
	<summary>
 The string literal with the library name.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DeclareStatementSyntax.AliasKeyword">
	<summary>
 If present, the "Alias" keyword. If not present, returns Nothing.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DeclareStatementSyntax.AliasName">
	<summary>
 The string literal with the alias. If not present, returns Nothing.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.DeclareStatementSyntax">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DelegateStatementSyntax.DelegateKeyword">
	<summary>
 The "Delegate" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DelegateStatementSyntax.Identifier">
	<summary>
 The name of the delegate being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DelegateStatementSyntax.TypeParameterList">
	<summary>
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.DelegateStatementSyntax">
	<summary>
 A statement that declares a delegate type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EventStatementSyntax.CustomKeyword">
	<summary>
 The optional Custom keyword for custom event declarations.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EventStatementSyntax.Identifier">
	<summary>
 The name of the event being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EventStatementSyntax.ImplementsClause">
	<summary>
 If present, an Implements clause indicates the interface methods that this
 method implements.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EventStatementSyntax">
	<summary>
 A statement that declares an event. If the event being declared is a custom
 event, this statement will be the Begin of a PropertyOrEventBlock, and the
 accessors will be part of the Accessors of that node.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OperatorStatementSyntax.Operator">
	<summary>
 The operator being defined.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.OperatorStatementSyntax">
	<summary>
 A statement that declares an operator. If this operator has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PropertyStatementSyntax.Identifier">
	<summary>
 The name of the property being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PropertyStatementSyntax.Initializer">
	<summary>
 If present, an "= initial-value" clause describing the initial value of the
 property.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PropertyStatementSyntax.ImplementsClause">
	<summary>
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.PropertyStatementSyntax">
	<summary>
 Statement that declares a property. If this property has accessors declared,
 this statement will be the Begin of a BlockNode, and the accessors will be the
 Body of that node. Auto properties are property declarations without a
 PropertyBlock.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AccessorStatementSyntax">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsClauseSyntax.ImplementsKeyword">
	<summary>
 The "Implements" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsClauseSyntax.InterfaceMembers">
	<summary>
 The list of interface members being implemented.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsClauseSyntax">
	<summary>
 Represents the "Implements ..." clause on a type member, which describes which
 interface members this member implements.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.HandlesClauseSyntax.HandlesKeyword">
	<summary>
 The "Handles" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.HandlesClauseSyntax.Events">
	<summary>
 The list of event members being handled.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.HandlesClauseSyntax">
	<summary>
 Represents the "Handles ..." clause on a method declaration that describes
 which events this method handles.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EventContainerSyntax">
	<summary>
 Represents container of an event in a Handles clause item.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordEventContainerSyntax.Keyword">
	<summary>
 The container of the event. This can be one of the special keywords: "Me",
 "MyBase" or "MyClass".
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordEventContainerSyntax">
	<summary>
 Represents event container specified through special keywords "Me", "MyBase" or
 "MyClass"..
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierEventContainerSyntax.Identifier">
	<summary>
 The container of the event. It is a simple identifier that refers to a
 WithEvents member of the containing type.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierEventContainerSyntax">
	<summary>
 Represents event container that refers to a WithEvents member.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.HandlesClauseItemSyntax.EventContainer">
	<summary>
 The container of the event. This can either be a simple identifier (identifying
 a members of the containing type) or one of the special keywords "Me", "MyBase"
 or "MyClass".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.HandlesClauseItemSyntax.DotToken">
	<summary>
 The "." token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.HandlesClauseItemSyntax.EventMember">
	<summary>
 The event being handled. This must be a simple identifier.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.HandlesClauseItemSyntax">
	<summary>
 Represents a single handled event in a "Handles ..." clause.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IncompleteMemberSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IncompleteMemberSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IncompleteMemberSyntax.MissingIdentifier">
	<summary>
 The missing identifier token for this incomplete member. Should only be used to
 have a location for error reporting.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.IncompleteMemberSyntax">
	<summary>
 Represents the beginning of a declaration. However, not enough syntax is
 detected to classify this as a field, method, property or event. This is node
 always represents a syntax error.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FieldDeclarationSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FieldDeclarationSyntax.Modifiers">
	<summary>
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FieldDeclarationSyntax.Declarators">
	<summary>
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.FieldDeclarationSyntax">
	<summary>
 Represents the declaration of one or more variables or constants, either as
 local variables or as class/structure members. In the case of a constant, it is
 represented by having "Const" in the Modifiers (although technically "Const" is
 not a modifier, it is represented as one in the parse trees.)
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.VariableDeclaratorSyntax.Names">
	<summary>
 The names of the variables being declared. Each name might have a "?" or "()"
 modifier(s) attached.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.VariableDeclaratorSyntax.AsClause">
	<summary>
 The "As" clause that describes the return type, and possibly includes "New",
 "With" or "From". If no As clause was present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.VariableDeclaratorSyntax.Initializer">
	<summary>
 If present, an "= initial-value" clause describing the initial value of the
 variable or the value of the constant.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.VariableDeclaratorSyntax">
	<summary>
 Represents the part of a variable or constant declaration statement that
 associated one or more variable names with a type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax.AsKeyword">
	<summary>
 The "As" keyword.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax">
	<summary>
 Abstract node class that represents the different kinds of "As {type-name}"
 clauses in a declaration: simple "As" clauses and "As New" clauses. The type
 has optional attributes associated with it, although attributes are not
 permitted in all possible places where this node occurs.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleAsClauseSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleAsClauseSyntax.Type">
	<summary>
 The type-name part of the As clause.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleAsClauseSyntax">
	<summary>
 Represents an "As {type-name}" clause that does not have an initializer or
 "New". The type has optional attributes associated with it, although attributes
 are not permitted in all possible places where this node occurs.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AsNewClauseSyntax.NewExpression">
	<summary>
 The New expression
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AsNewClauseSyntax">
	<summary>
 Represents an "As New {type-name} [arguments] [initializers]" clause in a
 declaration. The type has optional attributes associated with it, although
 attributes are not permitted in many places where this node occurs (they are
 permitted, for example, on automatically implemented properties.)
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectCreationInitializerSyntax">
	<summary>
 An abstract node class that represents a "With" or "From" clause used to
 initializer an new object.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectMemberInitializerSyntax.WithKeyword">
	<summary>
 The "With" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectMemberInitializerSyntax.OpenBraceToken">
	<summary>
 The "{" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectMemberInitializerSyntax.Initializers">
	<summary>
 The comma-separated list of field initializers.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectMemberInitializerSyntax.CloseBraceToken">
	<summary>
 The "}" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectMemberInitializerSyntax">
	<summary>
 Represents a "With {...} clause used to initialize a new object's members.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectCollectionInitializerSyntax.FromKeyword">
	<summary>
 The "From" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectCollectionInitializerSyntax.Initializer">
	<summary>
 The initializer including the braces.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectCollectionInitializerSyntax">
	<summary>
 Represents a "From {...} clause used to initialize a new collection object's
 elements.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FieldInitializerSyntax.KeyKeyword">
	<summary>
 The optional "Key" keyword.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.FieldInitializerSyntax">
	<summary>
 Abstract class that represent a single field initializer used in a "With {...}"
 field initializer list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.InferredFieldInitializerSyntax.Expression">
	<summary>
 The value being assigned.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.InferredFieldInitializerSyntax">
	<summary>
 Represent a field initializer in a With {...} initializer where the field name
 is inferred from the initializer expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamedFieldInitializerSyntax.DotToken">
	<summary>
 The "." token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamedFieldInitializerSyntax.Name">
	<summary>
 The name of the field being initialized.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamedFieldInitializerSyntax.EqualsToken">
	<summary>
 The "=" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamedFieldInitializerSyntax.Expression">
	<summary>
 The value being assigned to the field.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.NamedFieldInitializerSyntax">
	<summary>
 Represent a named field initializer in a With {...} initializer, such as ".x =
 expr".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EqualsValueSyntax.EqualsToken">
	<summary>
 The "=" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EqualsValueSyntax.Value">
	<summary>
 The expression used as the initial value.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EqualsValueSyntax">
	<summary>
 Represents an "= initializer" clause in a declaration for a variable,
 pararameter or automatic property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on this parameter. If no attributes were
 specified, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterSyntax.Modifiers">
	<summary>
 A list of the modifier tokens "ByVal", "ByRef", "Optional" or "ParamArray" that
 modify this parameter.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterSyntax.Identifier">
	<summary>
 The name of the parameter, including any "?" or "()" modifiers.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterSyntax.AsClause">
	<summary>
 If present, the "As type-name" clause describing the type of the parameter. If
 no As clause is present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterSyntax.Default">
	<summary>
 If present, an initializer with the default value of the parameter. If no
 default value is present, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterSyntax">
	<summary>
 Represent a parameter to a method, property, constructor, etc.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ModifiedIdentifierSyntax.Identifier">
	<summary>
 The identifier that names the item being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ModifiedIdentifierSyntax.Nullable">
	<summary>
 The "?" token that indicates a nullable type.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ModifiedIdentifierSyntax.ArrayBounds">
	<summary>
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ModifiedIdentifierSyntax.ArrayRankSpecifiers">
	<summary>
 A list of array modifiers for the type. If no array modifiers were present, an
 empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ModifiedIdentifierSyntax">
	<summary>
 Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
 used in parameter declarations and variable declarations.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ArrayRankSpecifierSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ArrayRankSpecifierSyntax.CommaTokens">
	<summary>
 The comma tokens in the array type. There is one less comma than the rank.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ArrayRankSpecifierSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ArrayRankSpecifierSyntax">
	<summary>
 Represents a modifier that describes an array type, without bounds, such as
 "()" or "(,)".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeListSyntax.LessThanToken">
	<summary>
 The "&lt;" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeListSyntax.Attributes">
	<summary>
 A comma separated list of attribute declarations in this attribute list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeListSyntax.GreaterThanToken">
	<summary>
 The "&gt;" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeListSyntax">
	<summary>
 Represents a group of attributes within "&lt;" and "&gt;" brackets.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeSyntax.Target">
	<summary>
 Optional attribute target. Assembly|Module :
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeSyntax.Name">
	<summary>
 The name of the attribute.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeSyntax.ArgumentList">
	<summary>
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeSyntax">
	<summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeTargetSyntax.AttributeModifier">
	<summary>
 The "Assembly" or "Module" attribute modifier, is present. If no attribute
 modifier is present, Nothing is returned.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeTargetSyntax.ColonToken">
	<summary>
 The ":" token, if an attribute modifier is present. If no attribute modifier is
 present, Nothing is returned.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeTargetSyntax">
	<summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributesStatementSyntax.AttributeLists">
	<summary>
 The list of attribute lists.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AttributesStatementSyntax">
	<summary>
 Represents a file-level attribute, in which the attributes have no other
 syntactic element they are attached to.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionStatementSyntax.QuestionToken">
	<summary>
 "?" token, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionStatementSyntax.Expression">
	<summary>
 The expression.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionStatementSyntax">
	<summary>
 Represent an expression in a statement context.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WhileBlockSyntax.Begin">
	<summary>
 The While statement that begins the block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WhileBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WhileBlockSyntax.Statements">
	<summary>
 The statements contained in the While...End While. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WhileBlockSyntax.End">
	<summary>
 The End While statement that ends the block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.WhileBlockSyntax">
	<summary>
 Represents a While...End While statement, including the While, body and End
 While.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.UsingBlockSyntax.Begin">
	<summary>
 The UsingStatement that begins the Using...End Using block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.UsingBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.UsingBlockSyntax.Statements">
	<summary>
 The statements contained in the Using...End Using block. This might be an empty
 list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.UsingBlockSyntax.End">
	<summary>
 The End Using statement that ends the block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.UsingBlockSyntax">
	<summary>
 Represents an entire Using...End Using statement, including the Using, body and
 End Using statements.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SyncLockBlockSyntax.Begin">
	<summary>
 The SyncLock statement that begins the block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SyncLockBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SyncLockBlockSyntax.Statements">
	<summary>
 The statements contained in the SyncLock...End SyncLock statement. This might
 be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SyncLockBlockSyntax.End">
	<summary>
 The End SyncLock statement that ends the block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SyncLockBlockSyntax">
	<summary>
 Represents a entire SyncLock...End SyncLock block, including the SyncLock
 statement, the enclosed statements, and the End SyncLock statment.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WithBlockSyntax.Begin">
	<summary>
 The WithStatement that begins the With...End With block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WithBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WithBlockSyntax.Statements">
	<summary>
 The statements contained in the With...End With block. This might be an empty
 list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WithBlockSyntax.End">
	<summary>
 The End With statement that ends the block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.WithBlockSyntax">
	<summary>
 Represents a With...End With block, include the With statement, the body of the
 block and the End With statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.LocalDeclarationStatementSyntax.Modifiers">
	<summary>
 The modifier token (Static, Dim or Const) that introduces this local variable
 declaration.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.LocalDeclarationStatementSyntax.Declarators">
	<summary>
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.LocalDeclarationStatementSyntax">
	<summary>
 Represents the declaration of one or more local variables or constants.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.LabelStatementSyntax.LabelToken">
	<summary>
 The name of the label. If the label is a line number, returns an IntegerLiteral
 that is the line number, otherwise, returns an Identifier.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.LabelStatementSyntax">
	<summary>
 Represents a label statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GoToStatementSyntax.GoToKeyword">
	<summary>
 The "GoTo" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GoToStatementSyntax.Label">
	<summary>
 The name of the label. If the label is a line number, wraps an IntegerLiteral
 that is the line number, otherwise, wraps an Identifier.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.GoToStatementSyntax">
	<summary>
 Represents a "GoTo" statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.LabelSyntax.LabelToken">
	<summary>
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.LabelSyntax">
	<summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.StopOrEndStatementSyntax.StopOrEndKeyword">
	<summary>
 The "Stop" or "End" keyword.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.StopOrEndStatementSyntax">
	<summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ExitStatementSyntax.ExitKeyword">
	<summary>
 The "Exit" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ExitStatementSyntax.BlockKeyword">
	<summary>
 The keyword describing the block to exit.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ExitStatementSyntax">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ContinueStatementSyntax.ContinueKeyword">
	<summary>
 The "Continue" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ContinueStatementSyntax.BlockKeyword">
	<summary>
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ContinueStatementSyntax">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ReturnStatementSyntax.ReturnKeyword">
	<summary>
 The "Return" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ReturnStatementSyntax.Expression">
	<summary>
 The expression being returned, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ReturnStatementSyntax">
	<summary>
 Represents a "Return" statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineIfStatementSyntax.IfPart">
	<summary>
 The If part of the statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineIfStatementSyntax.ElsePart">
	<summary>
 The Else part of the statement. If there is no Else part, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineIfStatementSyntax">
	<summary>
 Represents a line If-Then-Else statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineIfPartSyntax.Begin">
	<summary>
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineIfPartSyntax.Statements">
	<summary>
 The statements controlled by this If or Else If. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineIfPartSyntax">
	<summary>
 Represents part of a single line If statement, consisting of a beginning
 if-statement, followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an SingleLineIf.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineElsePartSyntax.Begin">
	<summary>
 The Else statement that introduces this part.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineElsePartSyntax.Statements">
	<summary>
 The statements controlled by the Else.This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineElsePartSyntax">
	<summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MultiLineIfBlockSyntax.IfPart">
	<summary>
 The If part of the statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MultiLineIfBlockSyntax.ElseIfParts">
	<summary>
 A list of the "ElseIf" parts of the statement. If there are no ElseIf parts,
 then an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MultiLineIfBlockSyntax.ElsePart">
	<summary>
 The Else part of the statement. If there is no Else part, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MultiLineIfBlockSyntax.End">
	<summary>
 If this is a block if, returns the "End If" statement.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.MultiLineIfBlockSyntax">
	<summary>
 Represents a block If...Then...Else...EndIf Statement. The Kind property can be
 used to determine if it is a block or line If.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IfPartSyntax.Begin">
	<summary>
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IfPartSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IfPartSyntax.Statements">
	<summary>
 The statements controlled by this If or Else If. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.IfPartSyntax">
	<summary>
 Represents part of an If statement, consisting of a beginning statement (If or
 ElseIf), followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an If or ElseIf.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ElsePartSyntax.Begin">
	<summary>
 The Else statement that introduces this part.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ElsePartSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ElsePartSyntax.Statements">
	<summary>
 The statements controlled by the Else. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ElsePartSyntax">
	<summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IfStatementSyntax.ElseKeyword">
	<summary>
 If this ElseIf was written as "Else If", contains the "Else" keyword. Otherwise
 returns Nothing.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IfStatementSyntax.IfOrElseIfKeyword">
	<summary>
 The "If" or "ElseIf" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IfStatementSyntax.Condition">
	<summary>
 The boolean expression that is being tested.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IfStatementSyntax.ThenKeyword">
	<summary>
 The "Then" keyword.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.IfStatementSyntax">
	<summary>
 Represents the If part or ElseIf part of a If...End If block (or line If). This
 statement is always the Begin of a IfPart. The Kind can be examined to
 determine if this is an If or an ElseIf statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ElseStatementSyntax.ElseKeyword">
	<summary>
 The "Else" keyword
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ElseStatementSyntax">
	<summary>
 Represents the Else part of a If...End If block (or line If). This statement is
 always the Begin of a ElsePart.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TryBlockSyntax.TryPart">
	<summary>
 The Try part of the statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TryBlockSyntax.CatchParts">
	<summary>
 A list of the Catch parts of the statement. If there are no Catch parts, then
 an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TryBlockSyntax.FinallyPart">
	<summary>
 The Finally part of the statement, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TryBlockSyntax.End">
	<summary>
 The "End Try" statement.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TryBlockSyntax">
	<summary>
 Represents an entire Try...Catch...Finally...End Try statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TryPartSyntax.Begin">
	<summary>
 The TryStatement that introduces this part of the Try...Catch...Finally...End
 Try.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TryPartSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TryPartSyntax.Statements">
	<summary>
 The statements inside the Try part of the Try...Catch...Finally...End Try. This
 might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TryPartSyntax">
	<summary>
 Represents part of an Try...Catch...Finally...End Try statement, consisting of
 a beginning statement (Try, Catch or Finally), followed by a body of statements
 controlled by that beginning statement. The Kind property returns which kind of
 part this is.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CatchPartSyntax.Begin">
	<summary>
 The CatchStatement that introduces this part.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CatchPartSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CatchPartSyntax.Statements">
	<summary>
 The statements controlled by the Catch statement. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CatchPartSyntax">
	<summary>
 Represents a Catch part of an Try...Catch...Finally...End Try statement,
 consisting of a Catch statement, followed by a body of statements controlled by
 that Catch statement. The Kind property returns which kind of part this is.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FinallyPartSyntax.Begin">
	<summary>
 The FinallyStatement that introduces the Finally part of a Try.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FinallyPartSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FinallyPartSyntax.Statements">
	<summary>
 The statements inside the Finally part of the Try...Catch...Finally...End Try.
 This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.FinallyPartSyntax">
	<summary>
 Represents the Finally part of an Try...Catch...Finally...End Try statement,
 consisting of a Finally statement, followed by a body of statements controlled
 by the Finally.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TryStatementSyntax.TryKeyword">
	<summary>
 The "Try" keyword
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TryStatementSyntax">
	<summary>
 Represents the Try part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a TryPart.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CatchStatementSyntax.CatchKeyword">
	<summary>
 The "Catch" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CatchStatementSyntax.IdentifierName">
	<summary>
 The identifier representing the exception that was caught, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CatchStatementSyntax.AsClause">
	<summary>
 The As clause that defines the type of exception being caught.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CatchStatementSyntax.WhenClause">
	<summary>
 The "When" clause, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CatchStatementSyntax">
	<summary>
 Represents the Catch part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a CatchPart.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CatchFilterClauseSyntax.WhenKeyword">
	<summary>
 The "When" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CatchFilterClauseSyntax.Filter">
	<summary>
 The filter expression
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CatchFilterClauseSyntax">
	<summary>
 Represents the When/Filter clause of a Catch statement
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FinallyStatementSyntax.FinallyKeyword">
	<summary>
 The "Finally" keyword.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.FinallyStatementSyntax">
	<summary>
 Represents the Finally part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a FinallyPart.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ErrorStatementSyntax.ErrorKeyword">
	<summary>
 The "Error" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ErrorStatementSyntax.ErrorNumber">
	<summary>
 The expression that represents the error number.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ErrorStatementSyntax">
	<summary>
 Represents the "Error" statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OnErrorGoToStatementSyntax.OnKeyword">
	<summary>
 The "On" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OnErrorGoToStatementSyntax.ErrorKeyword">
	<summary>
 The "Error" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OnErrorGoToStatementSyntax.GoToKeyword">
	<summary>
 The "GoTo" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OnErrorGoToStatementSyntax.Minus">
	<summary>
 An optional minus for On Error Goto -1
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OnErrorGoToStatementSyntax.Label">
	<summary>
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.OnErrorGoToStatementSyntax">
	<summary>
 Represents an OnError Goto statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OnErrorResumeNextStatementSyntax.OnKeyword">
	<summary>
 The "On" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OnErrorResumeNextStatementSyntax.ErrorKeyword">
	<summary>
 The "Error" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OnErrorResumeNextStatementSyntax.ResumeKeyword">
	<summary>
 The "Resume" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OnErrorResumeNextStatementSyntax.NextKeyword">
	<summary>
 The "Next"
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.OnErrorResumeNextStatementSyntax">
	<summary>
 Represents an OnError Resume Next statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ResumeStatementSyntax.ResumeKeyword">
	<summary>
 The "Resume" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ResumeStatementSyntax.Label">
	<summary>
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ResumeStatementSyntax">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SelectBlockSyntax.Begin">
	<summary>
 The Select Case statement that begins the block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SelectBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SelectBlockSyntax.CaseBlocks">
	<summary>
 A list of the contained Case blocks.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SelectBlockSyntax.End">
	<summary>
 The End Select statement that ends the block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SelectBlockSyntax">
	<summary>
 Represents a Select Case block, including the Select Case that begins it, the
 contains Case blocks and the End Select.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SelectStatementSyntax.SelectKeyword">
	<summary>
 The "Select" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SelectStatementSyntax.CaseKeyword">
	<summary>
 The "Case" keyword, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SelectStatementSyntax.Expression">
	<summary>
 The value that branching is based on.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SelectStatementSyntax">
	<summary>
 Represents a Select Case statement. This statement always occurs as the Begin
 of a SelectBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseBlockSyntax.Begin">
	<summary>
 The statement that begins the case block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseBlockSyntax.Statements">
	<summary>
 The statements contained in the case block. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseBlockSyntax">
	<summary>
 Represents a case statement and its subsequent block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseStatementSyntax.CaseKeyword">
	<summary>
 The "Case" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseStatementSyntax.Cases">
	<summary>
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a CaseElseClause.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseStatementSyntax">
	<summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseClauseSyntax">
	<summary>
 Represents a single clause in a case statement. An abstract node that is the
 parent of different kinds of Case clauses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseElseClauseSyntax.ElseKeyword">
	<summary>
 The "Else" keyword.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseElseClauseSyntax">
	<summary>
 The "Else" part in a Case Else statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseValueClauseSyntax.Value">
	<summary>
 The expression that denotes the value being tested against.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseValueClauseSyntax">
	<summary>
 Represents a single value in a Case.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseRangeClauseSyntax.LowerBound">
	<summary>
 The lower bound of the range.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseRangeClauseSyntax.ToKeyword">
	<summary>
 The "To" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseRangeClauseSyntax.UpperBound">
	<summary>
 The upper bound of the range.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseRangeClauseSyntax">
	<summary>
 Represents a range "expression To expression" in a Case.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseRelationalClauseSyntax.IsKeyword">
	<summary>
 The "Is" keyword, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseRelationalClauseSyntax.OperatorToken">
	<summary>
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseRelationalClauseSyntax.Value">
	<summary>
 The expression that denotes the value being tested against.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CaseRelationalClauseSyntax">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SyncLockStatementSyntax.SyncLockKeyword">
	<summary>
 The "SyncLock" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SyncLockStatementSyntax.Expression">
	<summary>
 The expression being synchronized on.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SyncLockStatementSyntax">
	<summary>
 Represents the "SyncLock" statement. This statement always occurs as the Begin
 of a SyncLockBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DoLoopBlockSyntax.Begin">
	<summary>
 The Do statement that begins the block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DoLoopBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DoLoopBlockSyntax.Statements">
	<summary>
 The statements contained in the block statement. This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DoLoopBlockSyntax.End">
	<summary>
 The Loop statement that ends the block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.DoLoopBlockSyntax">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DoStatementSyntax.DoKeyword">
	<summary>
 The "Do" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DoStatementSyntax.WhileUntilClause">
	<summary>
 The "While expression" or "Until expression" part of the Do statement, if
 present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.DoStatementSyntax">
	<summary>
 The Do statement that begins a Do-Loop block. This statement always occurs as
 the Begin of a DoLoopBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.LoopStatementSyntax.LoopKeyword">
	<summary>
 The "Loop" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.LoopStatementSyntax.WhileUntilClause">
	<summary>
 The "While expression" or "Until expression" part of the Loop statement, if
 present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.LoopStatementSyntax">
	<summary>
 The Loop statement that ends a Do-Loop block. This statement always occurs as
 the End of a DoLoopBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WhileUntilClauseSyntax.WhileOrUntilKeyword">
	<summary>
 The "While" or "Until" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WhileUntilClauseSyntax.Condition">
	<summary>
 The boolean expression after the While or Until.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.WhileUntilClauseSyntax">
	<summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WhileStatementSyntax.WhileKeyword">
	<summary>
 The "While" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WhileStatementSyntax.Condition">
	<summary>
 The boolean expression that controls the While loop.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.WhileStatementSyntax">
	<summary>
 The While statement that begins a While...End While block. This statement
 always occurs as the Begin of a WhileBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForBlockSyntax.Begin">
	<summary>
 The For or For Each statement that begins the block.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForBlockSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForBlockSyntax.Statements">
	<summary>
 The statements contained in the For or For Each loop. This might be an empty
 list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForBlockSyntax.End">
	<summary>
 The Next statement that ends the block. If two For statements are ended by a
 single Next statement, the inner For will not have an EndStatment.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ForBlockSyntax">
	<summary>
 Represents a For or For Each block, including the introducting statement, the
 body and the "Next" (which can be omitted if a containing For has a Next with
 multiple variables).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForStatementSyntax.ForKeyword">
	<summary>
 The "For" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForStatementSyntax.ControlVariable">
	<summary>
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForStatementSyntax.EqualsToken">
	<summary>
 The "=" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForStatementSyntax.FromValue">
	<summary>
 The expression denoting the initial value of the iteration.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForStatementSyntax.ToKeyword">
	<summary>
 The "To" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForStatementSyntax.ToValue">
	<summary>
 The expression denoting the final value of the iteration.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForStatementSyntax.StepClause">
	<summary>
 The optional Step clause.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ForStatementSyntax">
	<summary>
 The For statement that begins a For-Next block. This statement always occurs as
 the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForStepClauseSyntax.StepKeyword">
	<summary>
 The "Step" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForStepClauseSyntax.StepValue">
	<summary>
 The expression denoting the step increment.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ForStepClauseSyntax">
	<summary>
 The Step clause in a For Statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForEachStatementSyntax.ForKeyword">
	<summary>
 The "For" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForEachStatementSyntax.EachKeyword">
	<summary>
 The "Each" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForEachStatementSyntax.ControlVariable">
	<summary>
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForEachStatementSyntax.InKeyword">
	<summary>
 The "In" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ForEachStatementSyntax.Expression">
	<summary>
 The expression denoting the collection to iterate over.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ForEachStatementSyntax">
	<summary>
 The For Each statement that begins a For Each-Next block. This statement always
 occurs as the Begin of a ForBlock, and the body of the For Each-Next is the
 Body of that ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NextStatementSyntax.NextKeyword">
	<summary>
 The "Next" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NextStatementSyntax.ControlVariables">
	<summary>
 The variables in the Next statement, if present
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.NextStatementSyntax">
	<summary>
 The Next statement that ends a For-Next or For Each-Next block. This statement
 always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
 and the body of the For-Next is the Body of that ForBlock. The Begin of that
 ForBlock has the corresponding For or For Each statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.UsingStatementSyntax.UsingKeyword">
	<summary>
 The "Using" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.UsingStatementSyntax.Expression">
	<summary>
 If the Using statement is of a form that does not declare a new variable, this
 is the expression used in the using. Otherwise, Nothing is returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.UsingStatementSyntax.Variables">
	<summary>
 If the Using statement is of a form that declares one or more new variables,
 this is the list of variable declarations. Otherwise, Nothing is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.UsingStatementSyntax">
	<summary>
 The Using statement that begins a Using block. This statement always occurs as
 the Begin of a UsingBlock, and the body of the Using is the Body of that
 UsingBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ThrowStatementSyntax.ThrowKeyword">
	<summary>
 The "Throw" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ThrowStatementSyntax.Expression">
	<summary>
 The expression denoting the value being thrown.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ThrowStatementSyntax">
	<summary>
 Represents a Throw statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AssignmentStatementSyntax.Left">
	<summary>
 The target (left hand side) of the assignment.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AssignmentStatementSyntax.OperatorToken">
	<summary>
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AssignmentStatementSyntax.Right">
	<summary>
 The source (right hand side) of the assignment.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AssignmentStatementSyntax">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CallStatementSyntax.CallKeyword">
	<summary>
 The "Call" keyword, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CallStatementSyntax.Invocation">
	<summary>
 The expression denoting the call. This could be an Invocation or a MemberAccess
 (in the case where no parentheses were supplied.)
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CallStatementSyntax">
	<summary>
 Represent an call statement (also known as a invocation statement).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AddRemoveHandlerStatementSyntax.AddHandlerOrRemoveHandlerKeyword">
	<summary>
 The "AddHandler" or "RemoveHandler" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AddRemoveHandlerStatementSyntax.EventExpression">
	<summary>
 The event being accessed.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AddRemoveHandlerStatementSyntax.CommaToken">
	<summary>
 The "," token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AddRemoveHandlerStatementSyntax.DelegateExpression">
	<summary>
 The delegate being added or removed.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AddRemoveHandlerStatementSyntax">
	<summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.RaiseEventStatementSyntax.RaiseEventKeyword">
	<summary>
 The "RaiseEvent" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.RaiseEventStatementSyntax.Name">
	<summary>
 The name of the event being raised.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.RaiseEventStatementSyntax.ArgumentList">
	<summary>
 The argument list, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.RaiseEventStatementSyntax">
	<summary>
 Represent a RaiseEvent statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WithStatementSyntax.WithKeyword">
	<summary>
 The "With" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WithStatementSyntax.Expression">
	<summary>
 The expression that is the operand of the With statement.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.WithStatementSyntax">
	<summary>
 Represents a "With" statement. This statement always occurs as the
 BeginStatement of a WithBlock, and the body of the With is the Body of that
 WithBlock.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ReDimStatementSyntax.ReDimKeyword">
	<summary>
 The "ReDim" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ReDimStatementSyntax.PreserveKeyword">
	<summary>
 Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
 Kind=RedimPreserve.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ReDimStatementSyntax.Clauses">
	<summary>
 The list of ReDim clauses. Each clause is a Invocation node with an argument
 list denoting the new bounds for the array.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ReDimStatementSyntax">
	<summary>
 Represents a ReDim statement.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EraseStatementSyntax.EraseKeyword">
	<summary>
 The "Erase" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EraseStatementSyntax.Expressions">
	<summary>
 A list of expressions denoting the arrays to erase.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EraseStatementSyntax">
	<summary>
 Represents an "Erase" statement.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax">
	<summary>
 An abstract base class for all node classes that define expressions.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.LiteralExpressionSyntax.Token">
	<summary>
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.LiteralExpressionSyntax">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ParenthesizedExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ParenthesizedExpressionSyntax.Expression">
	<summary>
 The expression inside the parentheses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ParenthesizedExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ParenthesizedExpressionSyntax">
	<summary>
 Represents a parenthesized expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.InstanceExpressionSyntax.Keyword">
	<summary>
 The "Me", "MyClass" or "MyBase" keyword.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.InstanceExpressionSyntax">
	<summary>
 Identifies one of the special instances "Me", "MyClass" or "MyBase". The Kind
 property identifies which.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.MeExpressionSyntax">
	<summary>
 Identifies the special instance "Me"
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.MyBaseExpressionSyntax">
	<summary>
 Identifies the special instance "MyBase"
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.MyClassExpressionSyntax">
	<summary>
 Identifies the special instance "MyClass"
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GetTypeExpressionSyntax.GetTypeKeyword">
	<summary>
 The "GetType" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GetTypeExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GetTypeExpressionSyntax.Type">
	<summary>
 The type to get the Type object for. This can be an open generic type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GetTypeExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.GetTypeExpressionSyntax">
	<summary>
 Represents a GetType expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeOfExpressionSyntax.TypeOfKeyword">
	<summary>
 The "TypeOf" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeOfExpressionSyntax.Expression">
	<summary>
 The expression being tested.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeOfExpressionSyntax.OperatorToken">
	<summary>
 The "Is" or "IsNot" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeOfExpressionSyntax.Type">
	<summary>
 The name of the type being tested against.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeOfExpressionSyntax">
	<summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GetXmlNamespaceExpressionSyntax.GetXmlNamespaceKeyword">
	<summary>
 The "GetXmlNamespace" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GetXmlNamespaceExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GetXmlNamespaceExpressionSyntax.Name">
	<summary>
 The Xml namespace name being referenced.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GetXmlNamespaceExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.GetXmlNamespaceExpressionSyntax">
	<summary>
 Represents a GetXmlNamespace expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MemberAccessExpressionSyntax.Expression">
	<summary>
 The expression on the left-hand-side of the "." or "!" token.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MemberAccessExpressionSyntax.OperatorToken">
	<summary>
 The "." or "!" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MemberAccessExpressionSyntax.Name">
	<summary>
 The identifier after the "." or "!" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.MemberAccessExpressionSyntax">
	<summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlMemberAccessExpressionSyntax.Base">
	<summary>
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlMemberAccessExpressionSyntax.Token1">
	<summary>
 The initial dot "." part of the separator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlMemberAccessExpressionSyntax.Token2">
	<summary>
 The "@" part of .@ or the second "." of "...".
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlMemberAccessExpressionSyntax.Token3">
	<summary>
 The third "." in a "..." separator.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlMemberAccessExpressionSyntax.Name">
	<summary>
 The identifier after the ".", ".@" or "..."
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlMemberAccessExpressionSyntax">
	<summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.InvocationExpressionSyntax.Expression">
	<summary>
 The target of the call or index expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.InvocationExpressionSyntax.ArgumentList">
	<summary>
 The argument list.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.InvocationExpressionSyntax">
	<summary>
 Represents an invocation expression consisting of an invocation target and an
 optional argument list or an array, parameterized property or object default
 property index.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NewExpressionSyntax.NewKeyword">
	<summary>
 The "New" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NewExpressionSyntax.AttributeLists">
	<summary>
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.NewExpressionSyntax">
	<summary>
 Base class for object, array and anonymous object creation expressions
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectCreationExpressionSyntax.Type">
	<summary>
 The type of the object being initialized.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectCreationExpressionSyntax.ArgumentList">
	<summary>
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectCreationExpressionSyntax.Initializer">
	<summary>
 An optional From or With clause to initialize the new object.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectCreationExpressionSyntax">
	<summary>
 Represents a New expression that creates a new non-array object, possibly with
 a "With" or "From" clause.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AnonymousObjectCreationExpressionSyntax.Initializer">
	<summary>
 The With clause to initialize the new object.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AnonymousObjectCreationExpressionSyntax">
	<summary>
 Represents a New expression that create an object of anonymous type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ArrayCreationExpressionSyntax.Type">
	<summary>
 The element type of the array being created.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ArrayCreationExpressionSyntax.ArrayBounds">
	<summary>
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ArrayCreationExpressionSyntax.RankSpecifiers">
	<summary>
 A list of array modifiers such as "()" or "(,)". If no array modifiers were
 present, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ArrayCreationExpressionSyntax.Initializer">
	<summary>
 The initializer including the braces.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ArrayCreationExpressionSyntax">
	<summary>
 Represents an expression that creates a new array.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionInitializerSyntax.OpenBraceToken">
	<summary>
 The "{" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionInitializerSyntax.Initializers">
	<summary>
 The list of initializers between the braces.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionInitializerSyntax.CloseBraceToken">
	<summary>
 The "}" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionInitializerSyntax">
	<summary>
 Represents an expression that creates a new array without naming the element
 type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CastExpressionSyntax.Keyword">
	<summary>
 The "CType", "DirectCast" or "TryCast" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CastExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CastExpressionSyntax.Expression">
	<summary>
 The expression being cast.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CastExpressionSyntax.CommaToken">
	<summary>
 The "," token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CastExpressionSyntax.Type">
	<summary>
 The type the expression is being cast to.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CastExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CastExpressionSyntax">
	<summary>
 Represents a CType, DirectCast or TryCast conversion expression. The Kind
 property determines which kind of cast it is.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PredefinedCastExpressionSyntax.Keyword">
	<summary>
 The keyword that was used in the cast operation.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PredefinedCastExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PredefinedCastExpressionSyntax.Expression">
	<summary>
 The expression being cast.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PredefinedCastExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.PredefinedCastExpressionSyntax">
	<summary>
 Represents a cast to a pre-defined type using a pre-defined cast expression,
 such as CInt or CLng.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.BinaryExpressionSyntax.Left">
	<summary>
 The left operand.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.BinaryExpressionSyntax.Right">
	<summary>
 The right operand.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.BinaryExpressionSyntax">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.UnaryExpressionSyntax.OperatorToken">
	<summary>
 The token that is the operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.UnaryExpressionSyntax.Operand">
	<summary>
 The expression being operated on.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.UnaryExpressionSyntax">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.BinaryConditionalExpressionSyntax.IfKeyword">
	<summary>
 The "If" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.BinaryConditionalExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.BinaryConditionalExpressionSyntax.FirstExpression">
	<summary>
 The first expression inside the parentheses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.BinaryConditionalExpressionSyntax.CommaToken">
	<summary>
 The "," token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.BinaryConditionalExpressionSyntax.SecondExpression">
	<summary>
 The second expression inside the parentheses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.BinaryConditionalExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.BinaryConditionalExpressionSyntax">
	<summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TernaryConditionalExpressionSyntax.IfKeyword">
	<summary>
 The "If" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TernaryConditionalExpressionSyntax.OpenParenToken">
	<summary>
 The "(" token
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TernaryConditionalExpressionSyntax.Condition">
	<summary>
 The first expression inside the parentheses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TernaryConditionalExpressionSyntax.FirstCommaToken">
	<summary>
 The "," token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TernaryConditionalExpressionSyntax.WhenTrue">
	<summary>
 The second expression inside the parentheses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TernaryConditionalExpressionSyntax.SecondCommaToken">
	<summary>
 The "," token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TernaryConditionalExpressionSyntax.WhenFalse">
	<summary>
 The second expression inside the parentheses.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TernaryConditionalExpressionSyntax.CloseParenToken">
	<summary>
 The ")" token
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TernaryConditionalExpressionSyntax">
	<summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.LambdaExpressionSyntax.Begin">
	<summary>
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.LambdaExpressionSyntax.BeginTerminator">
	<summary>
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.LambdaExpressionSyntax">
	<summary>
 Represents a lambda expression, either single line or multi-line.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineLambdaExpressionSyntax.Body">
	<summary>
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineLambdaExpressionSyntax">
	<summary>
 Represents a single line lambda expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MultiLineLambdaExpressionSyntax.Statements">
	<summary>
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.MultiLineLambdaExpressionSyntax.End">
	<summary>
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.MultiLineLambdaExpressionSyntax">
	<summary>
 Represents a multi-line lambda expression.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.LambdaHeaderSyntax">
	<summary>
 Represents the header part of a lambda expression
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ArgumentListSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ArgumentListSyntax.Arguments">
	<summary>
 The list of arguments. This may be empty. Ommitted argument are represented by
 an OmittedArgumentSyntax node.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ArgumentListSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ArgumentListSyntax">
	<summary>
 Represents a parenthesized argument list.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ArgumentSyntax">
	<summary>
 Base class for the possible kinds of arguments that can appear in an argument
 list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OmittedArgumentSyntax.Empty">
	<summary>
 An empty token because all non terminals must have a token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.OmittedArgumentSyntax">
	<summary>
 Represents an omitted argument in an argument list. An omitted argument is not
 considered a syntax error but a valid case when no argument is required.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleArgumentSyntax.Expression">
	<summary>
 The expression that is the argument.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleArgumentSyntax">
	<summary>
 Represents a simple argument that is just an expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamedArgumentSyntax.IdentifierName">
	<summary>
 The name used to identify the named argument.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamedArgumentSyntax.ColonEqualsToken">
	<summary>
 The ":=" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NamedArgumentSyntax.Expression">
	<summary>
 The expression that is the named argument.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.NamedArgumentSyntax">
	<summary>
 Represents a named argument, such as "Value:=7".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.RangeArgumentSyntax.LowerBound">
	<summary>
 The lower bound of the range. This is typically the integer constant zero.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.RangeArgumentSyntax.ToKeyword">
	<summary>
 The "To" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.RangeArgumentSyntax.UpperBound">
	<summary>
 The upper bound of the range.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.RangeArgumentSyntax">
	<summary>
 Represents a range argument, such as "0 to 5", used in array bounds. The
 "Value" property represents the upper bound of the range.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.QueryExpressionSyntax.Clauses">
	<summary>
 A list of all the query operators in this query expression. This list always
 contains at least one operator.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.QueryExpressionSyntax">
	<summary>
 This class represents a query expression. A query expression is composed of one
 or more query operators in a row. The first query operator must be a From or
 Aggregate.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.QueryClauseSyntax">
	<summary>
 This is a base class for all query operators.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionRangeVariableSyntax.Identifier">
	<summary>
 The name of the range variable being defined.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionRangeVariableSyntax.AsClause">
	<summary>
 Describes the type of the variable being defined.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionRangeVariableSyntax.InKeyword">
	<summary>
 The "In" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionRangeVariableSyntax.Expression">
	<summary>
 The expression that serves as the source of items for the range variable.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionRangeVariableSyntax">
	<summary>
 Describes a single variable of the form "x [As Type] In expression" for use in
 query expressions.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionRangeVariableSyntax.NameEquals">
	<summary>
 The optional name and type of the expression range variable. If ommitted, the
 name of the expression range variable is inferred from the expression.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionRangeVariableSyntax.Expression">
	<summary>
 The expression used to initialize the expression variable.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionRangeVariableSyntax">
	<summary>
 Describes a single variable of the form "[x [As Type] =] expression" for use in
 query expressions.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AggregationRangeVariableSyntax.NameEquals">
	<summary>
 The optional name and type of the expression range variable. If ommitted, the
 name of the expression range variable is inferred from the aggregation
 expression.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AggregationRangeVariableSyntax.Aggregation">
	<summary>
 The name of the aggregation function. The "Group" aggregation function is
 represented by the identifier "Group".
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AggregationRangeVariableSyntax">
	<summary>
 Describes a single variable of the form "[x [As Type] =] aggregation-function"
 for use in the Into clause of Aggregate or Group By or Group Join query
 operators.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.VariableNameEqualsSyntax.Identifier">
	<summary>
 The name of the variable being defined.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.VariableNameEqualsSyntax.AsClause">
	<summary>
 Describes the type of the variable being defined.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.VariableNameEqualsSyntax.EqualsToken">
	<summary>
 The "=" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.VariableNameEqualsSyntax">
	<summary>
 Represents the name and optional type of an expression range variable.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AggregationSyntax">
	<summary>
 Represents aggregation in aggregation range variable declaration of a Group By,
 Group Join or Aggregate query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FunctionAggregationSyntax.FunctionName">
	<summary>
 The name of the aggregation function.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FunctionAggregationSyntax.OpenParenToken">
	<summary>
 The "(" token if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FunctionAggregationSyntax.Argument">
	<summary>
 The argument to the aggregation function.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FunctionAggregationSyntax.CloseParenToken">
	<summary>
 The ")" token, if present.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.FunctionAggregationSyntax">
	<summary>
 Represents an invocation of an Aggregation function in the aggregation range
 variable declaration of a Group By, Group Join or Aggregate query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GroupAggregationSyntax.GroupKeyword">
	<summary>
 The "Group" keyword.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.GroupAggregationSyntax">
	<summary>
 Represents the use of "Group" as the aggregation function in the in the
 aggregation range variable declaration of a Group By or Group Join query
 operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FromClauseSyntax.FromKeyword">
	<summary>
 The "From" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FromClauseSyntax.Variables">
	<summary>
 The list of collection variables declared by this From operator.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.FromClauseSyntax">
	<summary>
 Represents a "From" query operator. If this is the beginning of a query, the
 Source will be Nothing. Otherwise, the Source will be the part of the query to
 the left of the From.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.LetClauseSyntax.LetKeyword">
	<summary>
 The "Let" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.LetClauseSyntax.Variables">
	<summary>
 The list of expression range variable being defined by the Let operator.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.LetClauseSyntax">
	<summary>
 Represents a "Let" query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AggregateClauseSyntax.AggregateKeyword">
	<summary>
 The "Aggregate" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AggregateClauseSyntax.Variables">
	<summary>
 The list of collection range variables declared by this Aggregate operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AggregateClauseSyntax.AdditionalQueryOperators">
	<summary>
 A list of additional query operators. It may be empty.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AggregateClauseSyntax.IntoKeyword">
	<summary>
 The "Into" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.AggregateClauseSyntax.AggregationVariables">
	<summary>
 The list of new variables being defined by the aggregation.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.AggregateClauseSyntax">
	<summary>
 Represents an Aggregate query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DistinctClauseSyntax.DistinctKeyword">
	<summary>
 The "Distinct" keyword.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.DistinctClauseSyntax">
	<summary>
 Represents the "Distinct" query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WhereClauseSyntax.WhereKeyword">
	<summary>
 The "Where" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.WhereClauseSyntax.Condition">
	<summary>
 The boolean expression used for filtering.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.WhereClauseSyntax">
	<summary>
 Represents a "Where" query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PartitionWhileClauseSyntax.SkipOrTakeKeyword">
	<summary>
 The "Skip" or "Take" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PartitionWhileClauseSyntax.WhileKeyword">
	<summary>
 The "While" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PartitionWhileClauseSyntax.Condition">
	<summary>
 The boolean expression used for partitioning.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.PartitionWhileClauseSyntax">
	<summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PartitionClauseSyntax.SkipOrTakeKeyword">
	<summary>
 The "Skip" or "Take" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PartitionClauseSyntax.Count">
	<summary>
 Represents the expression with the number of items to take or skip.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.PartitionClauseSyntax">
	<summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GroupByClauseSyntax.GroupKeyword">
	<summary>
 The "Group" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GroupByClauseSyntax.Items">
	<summary>
 The optional list of variables being grouped; the contents of the Group clause.
 If none were specified, an empty list is returned.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GroupByClauseSyntax.ByKeyword">
	<summary>
 The "By" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GroupByClauseSyntax.Keys">
	<summary>
 The key values being used for grouping.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GroupByClauseSyntax.AggregationVariables">
	<summary>
 The list of new variables that calculate aggregations.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.GroupByClauseSyntax">
	<summary>
 Represents the "Group By" query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.JoinClauseSyntax.JoinKeyword">
	<summary>
 The "Join" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.JoinClauseSyntax.JoinedVariables">
	<summary>
 Defines the collection range variables being joined to.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.JoinClauseSyntax.AdditionalJoins">
	<summary>
 An additional Join or Group Join query operator.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.JoinClauseSyntax.OnKeyword">
	<summary>
 The "On" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.JoinClauseSyntax.JoinConditions">
	<summary>
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.JoinClauseSyntax">
	<summary>
 Represents a Join query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.JoinConditionSyntax.Left">
	<summary>
 The left expression in the Join condition.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.JoinConditionSyntax.EqualsKeyword">
	<summary>
 The "Equals" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.JoinConditionSyntax.Right">
	<summary>
 The right expression in the Join condition.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.JoinConditionSyntax">
	<summary>
 Represents the "expression Equals expression" condition in a Join.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GroupJoinClauseSyntax.GroupKeyword">
	<summary>
 The "Group" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GroupJoinClauseSyntax.IntoKeyword">
	<summary>
 The "Into" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GroupJoinClauseSyntax.AggregationVariables">
	<summary>
 The list of new variables that calculate aggregations.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.GroupJoinClauseSyntax">
	<summary>
 Represents the "Group Join" query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OrderByClauseSyntax.OrderKeyword">
	<summary>
 The "Order" keyword
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OrderByClauseSyntax.ByKeyword">
	<summary>
 The "By" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OrderByClauseSyntax.Orderings">
	<summary>
 The list of OrderExpression's to sort by.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.OrderByClauseSyntax">
	<summary>
 Represents the "Order By" query operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OrderingSyntax.Expression">
	<summary>
 The expression to sort by.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.OrderingSyntax.AscendingOrDescendingKeyword">
	<summary>
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </summary>
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.OrderingSyntax">
	<summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SelectClauseSyntax.SelectKeyword">
	<summary>
 The "Select" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SelectClauseSyntax.Variables">
	<summary>
 The list of expression range variables being defined by the Select query
 operator.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SelectClauseSyntax">
	<summary>
 Represents the "Select" query operator.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNodeSyntax">
	<summary>
 This is the base class for all XML expression syntax nodes (XmlDocument and
 XmlElement).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlDocumentSyntax.PrecedingMisc">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlDocumentSyntax.FollowingMisc">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlDocumentSyntax">
	<summary>
 Represents and XML Document literal expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlDeclarationSyntax.Encoding">
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlDeclarationSyntax.Standalone">
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlDeclarationSyntax">
	<summary>
 Represents the XML declaration prologue in an XML literal expression.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlDeclarationOptionSyntax">
	<summary>
 Represents an XML document prologue option - version, encoding, standalone or
 whitespace in an XML literal expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlElementSyntax.Content">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlElementSyntax">
	<summary>
 Represents an XML element with content in an XML literal expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlTextSyntax.TextTokens">
	<summary>
 A list of all the text tokens in the Xml text. This list always contains at
 least one token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlTextSyntax">
	<summary>
 Represents Xml text.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlElementStartTagSyntax.Attributes">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlElementStartTagSyntax">
	<summary>
 Represents the start tag of an XML element of the form &lt;element&gt;.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlElementEndTagSyntax.Name">
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlElementEndTagSyntax">
	<summary>
 Represents the end tag of an XML element of the form &lt;/element&gt;.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlEmptyElementSyntax.Attributes">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlEmptyElementSyntax">
	<summary>
 Represents an empty XML element of the form &lt;element /&gt;
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlAttributeSyntax">
	<summary>
 Represents an XML attribute in an XML literal expression.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlStringSyntax.TextTokens">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlStringSyntax">
	<summary>
 Represents a string of XML characters embedded as the content of an XML
 element.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlPrefixNameSyntax">
	<summary>
 Represents an XML name of the form 'name' appearing in GetXmlNamespace().
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNameSyntax.Prefix">
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNameSyntax">
	<summary>
 Represents an XML name of the form 'name' or 'namespace:name' appearing in
 source as part of an XML literal or member access expression or an XML
 namespace import clause.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlBracketedNameSyntax">
	<summary>
 Represents an XML name of the form &lt;xml-name&gt; appearing in source as part
 of an XML literal or member access expression or an XML namespace import
 clause.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlPrefixSyntax">
	<summary>
 Represents and XML namespace prefix of the form 'prefix:' as in xml:ns="".
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlCommentSyntax">
	<summary>
 Represents an XML comment of the form &lt;-- Comment --&gt; appearing in an XML
 literal expression.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlProcessingInstructionSyntax">
	<summary>
 Represents an XML processing instruction of the form '&lt;? XMLProcessingTarget
 XMLProcessingValue ?&gt;'.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlCDataSectionSyntax">
	<summary>
 Represents an XML CDATA section in an XML literal expression.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlEmbeddedExpressionSyntax">
	<summary>
 Represents an embedded expression in an XML literal e.g. '&lt;name&gt;&lt;%=
 obj.Name =%&gt;&lt;/name&gt;'.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax">
	<summary>
 Abstract node class that represents the textual description of a type, possibly
 include generic type arguments, qualified names, array specifiers, nullable
 specifier and the like.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ArrayTypeSyntax.ElementType">
	<summary>
 The type of the elements of the array.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ArrayTypeSyntax.RankSpecifiers">
	<summary>
 Represents the list of "()" or "(,,)" modifiers on the array type.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ArrayTypeSyntax">
	<summary>
 Represents an array type, such as "A() or "A(,)", without bounds specified for
 the array.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NullableTypeSyntax.ElementType">
	<summary>
 The kind of type that is this type is a nullable of. Cannot be an array type or
 a nullable type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.NullableTypeSyntax.QuestionMarkToken">
	<summary>
 The "?" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.NullableTypeSyntax">
	<summary>
 A type name that represents a nullable type, such as "Integer?".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.PredefinedTypeSyntax.Keyword">
	<summary>
 The keyword that was used to describe the built-in type.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.PredefinedTypeSyntax">
	<summary>
 Represents an occurrence of a Visual Basic built-in type such as Integer or
 String in source code.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.NameSyntax">
	<summary>
 Abstract node class that represents a name, possibly include generic arguments
 and qualified names.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleNameSyntax.Identifier">
	<summary>
 The identifier in the name.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleNameSyntax">
	<summary>
 Abstract node class that represents a name, possibly include generic arguments.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierNameSyntax">
	<summary>
 Represents a type name consisting of a single identifier (which might include
 brackets or a type character).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GenericNameSyntax.TypeArgumentList">
	<summary>
 The generic argument list.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.GenericNameSyntax">
	<summary>
 Represents a simple type name with one or more generic arguments, such as "X(Of
 Y, Z).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.QualifiedNameSyntax.Left">
	<summary>
 The part of the name that appears to the left of the dot. This can itself be
 any name.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.QualifiedNameSyntax.DotToken">
	<summary>
 The "." token that separates the names.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.QualifiedNameSyntax.Right">
	<summary>
 The part of the name that appears to the right of the dot. This must be a
 simple identifier.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.QualifiedNameSyntax">
	<summary>
 Represents a qualified type name, for example X.Y or X(Of Z).Y.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.GlobalNameSyntax.GlobalKeyword">
	<summary>
 The "Global" keyword.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.GlobalNameSyntax">
	<summary>
 Represents a name in the global namespace.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeArgumentListSyntax.OpenParenToken">
	<summary>
 The "(" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeArgumentListSyntax.OfKeyword">
	<summary>
 The "Of" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeArgumentListSyntax.Arguments">
	<summary>
 A list of all the type arguments.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeArgumentListSyntax.CloseParenToken">
	<summary>
 The ")" token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.TypeArgumentListSyntax">
	<summary>
 Represents a parenthesized list of generic type arguments.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken">
	<summary>
 Represents a single syntactic token in a VB program. A token is a keyword,
 punctuator, literal, identifier or XML token. The type of keyword or punctuator
 can be determined from the Kind property.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax">
	<summary>
 Represents a single keyword in a VB program. Which keyword can be determined
 from the Kind property.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax">
	<summary>
 Represents a single punctuation mark or operator in a VB program. Which one can
 be determined from the Kind property.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNameTokenSyntax">
	<summary>
 Represents an Xml NCName per Namespaces in XML 1.0
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlTextTokenSyntax.Value">
	<summary>
 The text of the attribute or pcdata after normalization.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.XmlTextTokenSyntax">
	<summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DecimalLiteralTokenSyntax.TypeSuffix">
	<summary>
 The type suffix or type character that was on the literal, if any. If no suffix
 was present, TypeCharacter.None is returned.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DecimalLiteralTokenSyntax.Value">
	<summary>
 The value of the token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.DecimalLiteralTokenSyntax">
	<summary>
 Represents a Decimal literal token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DateLiteralTokenSyntax.Value">
	<summary>
 The value of the token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.DateLiteralTokenSyntax">
	<summary>
 Represents an Date literal token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.StringLiteralTokenSyntax.Value">
	<summary>
 The value of the string, after removing the quotation marks and combining
 doubled quotation marks.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.StringLiteralTokenSyntax">
	<summary>
 Represents an string literal token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.CharacterLiteralTokenSyntax.Value">
	<summary>
 The value of the character, after removing the quotation marks.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.CharacterLiteralTokenSyntax">
	<summary>
 Represents an string literal token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.StructuredTriviaSyntax">
	<summary>
 Abstract class that represent structured trivia.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SkippedTokensTriviaSyntax.Tokens">
	<summary>
 The list of tokens that were skipped by the parser.
 </summary>
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SkippedTokensTriviaSyntax">
	<summary>
 Represents tokens that were skipped by the parser as part of error recovery,
 and thus are not part of any syntactic structure.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DocumentationCommentTriviaSyntax.Content">
	<remarks>
 If nothing is present, an empty list is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.DocumentationCommentTriviaSyntax">
	<summary>
 Represents a documentation comment e.g. ''' &lt;Summary&gt; apearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DirectiveTriviaSyntax.Terminator">
	<summary>
 The statement terminator token that ended the Directive.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.DirectiveTriviaSyntax">
	<summary>
 Represents a preprocessor directive
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxTrivia">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.DirectiveStatementSyntax.HashToken">
	<summary>
 The "#" token in a preprocessor directive.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.DirectiveStatementSyntax">
	<summary>
 Represents a pre-processing directive (such as #If, #Const or #Region)
 appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ConstDirectiveSyntax.ConstKeyword">
	<summary>
 The "Const" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ConstDirectiveSyntax.Name">
	<summary>
 The name of the pre-processing constant being defined.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ConstDirectiveSyntax.EqualsToken">
	<summary>
 The "=" token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ConstDirectiveSyntax.Value">
	<summary>
 An expression representing the value of the pre-processing constant being
 defined.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ConstDirectiveSyntax">
	<summary>
 Represents a #Const pre-processing constant declaration appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IfDirectiveSyntax.ElseKeyword">
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IfDirectiveSyntax.ThenKeyword">
	<remarks>
 This child is optional. If it is not present, then Nothing is returned.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.IfDirectiveSyntax">
	<summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ElseDirectiveSyntax">
	<summary>
 Represents an #Else pre-processing directive appearing in source.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EndIfDirectiveSyntax">
	<summary>
 Represents an #End If pre-processing directive appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.RegionDirectiveSyntax.RegionKeyword">
	<summary>
 The "Region" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.RegionDirectiveSyntax.Name">
	<summary>
 The label of the code region being defined.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.RegionDirectiveSyntax">
	<summary>
 Represents the beginning of a #Region directive appearing in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EndRegionDirectiveSyntax.EndKeyword">
	<summary>
 The "End" keyword.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.EndRegionDirectiveSyntax.RegionKeyword">
	<summary>
 The "Region" keyword.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EndRegionDirectiveSyntax">
	<summary>
 Represents an #End Region directive appearing in source.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ExternalSourceDirectiveSyntax">
	<summary>
 Represents the beginning of a #ExternalSource pre-processing directive
 appearing in source.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.EndExternalSourceDirective">
	<summary>
 Represents an #End ExternalSource pre-processing directive appearing in source.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ExternalChecksumDirectiveSyntax">
	<summary>
 Represents an #ExternalChecksum pre-processing directive appearing in source.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.ReferenceDirectiveSyntax">
	<summary>
 Represents an #r directive appearing in scripts.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.BadDirectiveSyntax">
	<summary>
 Represents an unrecognized pre-processing directive. This occurs when the
 parser encounters a hash '#' token at the beginning of a physical line but does
 recognize the text that follows as a valid Visual Basic pre-processing
 directive.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EmptyStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 A class to represent an empty statement. This can occur when a colon is on a
 line without anything else.
 </summary>
	<param name="empty">
 An empty token because all non terminals must have a token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EmptyStatement">
	<summary>
 A class to represent an empty statement. This can occur when a colon is on a
 line without anything else.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndIfStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndIfStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndUsingStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndUsingStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndWithStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndWithStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndSelectStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndSelectStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndStructureStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndStructureStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndEnumStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndEnumStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndInterfaceStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndInterfaceStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndClassStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndClassStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndModuleStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndModuleStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndNamespaceStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndNamespaceStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndSubStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndSubStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndFunctionStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndFunctionStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndGetStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndGetStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndSetStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndSetStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndPropertyStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndPropertyStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndOperatorStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndOperatorStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndEventStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndEventStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndAddHandlerStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndAddHandlerStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndRemoveHandlerStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndRemoveHandlerStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndRaiseEventStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndRaiseEventStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndWhileStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndWhileStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndTryStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndTryStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndSyncLockStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndSyncLockStatement">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndBlockStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 EndBlockStatementSyntax. One of EndIfStatement, EndUsingStatement,
 EndWithStatement, EndSelectStatement, EndStructureStatement, EndEnumStatement,
 EndInterfaceStatement, EndClassStatement, EndModuleStatement,
 EndNamespaceStatement, EndSubStatement, EndFunctionStatement, EndGetStatement,
 EndSetStatement, EndPropertyStatement, EndOperatorStatement, EndEventStatement,
 EndAddHandlerStatement, EndRemoveHandlerStatement, EndRaiseEventStatement,
 EndWhileStatement, EndTryStatement, EndSyncLockStatement.
 </param>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndBlockStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 EndBlockStatementSyntax. One of EndIfStatement, EndUsingStatement,
 EndWithStatement, EndSelectStatement, EndStructureStatement, EndEnumStatement,
 EndInterfaceStatement, EndClassStatement, EndModuleStatement,
 EndNamespaceStatement, EndSubStatement, EndFunctionStatement, EndGetStatement,
 EndSetStatement, EndPropertyStatement, EndOperatorStatement, EndEventStatement,
 EndAddHandlerStatement, EndRemoveHandlerStatement, EndRaiseEventStatement,
 EndWhileStatement, EndTryStatement, EndSyncLockStatement.
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CompilationUnit(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.OptionStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImportsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AttributesStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an entire source file of VB code.
 </summary>
	<param name="options">
 Represents the list of Option statements at the beginning of a source file.
 </param>
	<param name="imports">
 Represents the list of Imports statements at the beginning of a source file.
 </param>
	<param name="attributes">
 Represents the list of AttributeStatements at the beginning of a source file
 that contain the Assembly and Module attributes.
 </param>
	<param name="members">
 Represents the members of the default namespace for this source file: all the
 top-level type and namespace declarations in the file. May also contain
 Statements that are not valid
 </param>
	<param name="endOfFileToken">
 Represents the end of the source file. This token may have trivia (whitespace,
 comments, ...) attached to it.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CompilationUnit(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.OptionStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImportsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AttributesStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents an entire source file of VB code.
 </summary>
	<param name="options">
 Represents the list of Option statements at the beginning of a source file.
 </param>
	<param name="imports">
 Represents the list of Imports statements at the beginning of a source file.
 </param>
	<param name="attributes">
 Represents the list of AttributeStatements at the beginning of a source file
 that contain the Assembly and Module attributes.
 </param>
	<param name="members">
 Represents the members of the default namespace for this source file: all the
 top-level type and namespace declarations in the file. May also contain
 Statements that are not valid
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CompilationUnit">
	<summary>
 Represents an entire source file of VB code.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OptionStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an Option statement, such as "Option Strict On".
 </summary>
	<param name="optionKeyword">
 The "Option" keyword.
 </param>
	<param name="nameKeyword">
 The keyword that identifies the option being set: Explicit, Strict, Compare or
 Infer.
 </param>
	<param name="valueKeyword">
 The keyword that identifiers the value being set for the opition: On, Off, Text
 or Binary.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OptionStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an Option statement, such as "Option Strict On".
 </summary>
	<param name="nameKeyword">
 The keyword that identifies the option being set: Explicit, Strict, Compare or
 Infer.
 </param>
	<param name="valueKeyword">
 The keyword that identifiers the value being set for the opition: On, Off, Text
 or Binary.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OptionStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an Option statement, such as "Option Strict On".
 </summary>
	<param name="nameKeyword">
 The keyword that identifies the option being set: Explicit, Strict, Compare or
 Infer.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ImportsStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImportsClauseSyntax})">
	<summary>
 Represents an Imports statement, which has one or more imports clauses.
 </summary>
	<param name="importsKeyword">
 The "Imports" keyword.
 </param>
	<param name="importsClauses">
 A list of one or more import clauses. Each clause is either an alias, namespace
 or XML namespace import.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ImportsStatement(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImportsClauseSyntax})">
	<summary>
 Represents an Imports statement, which has one or more imports clauses.
 </summary>
	<param name="importsClauses">
 A list of one or more import clauses. Each clause is either an alias, namespace
 or XML namespace import.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ImportsStatement">
	<summary>
 Represents an Imports statement, which has one or more imports clauses.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AliasImportsClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.NameSyntax)">
	<summary>
 Represents the clause of an Imports statement that defines an alias for a
 namespace or type.
 </summary>
	<param name="alias">
 The identifier that the alias is being defined for.
 </param>
	<param name="equalsToken">
 The equals sign token.
 </param>
	<param name="name">
 The namespace or type the alias refers to.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AliasImportsClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.NameSyntax)">
	<summary>
 Represents the clause of an Imports statement that defines an alias for a
 namespace or type.
 </summary>
	<param name="alias">
 The identifier that the alias is being defined for.
 </param>
	<param name="name">
 The namespace or type the alias refers to.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AliasImportsClause(System.String,Roslyn.Compilers.VisualBasic.NameSyntax)">
	<summary>
 Represents the clause of an Imports statement that defines an alias for a
 namespace or type.
 </summary>
	<param name="alias">
 The identifier that the alias is being defined for.
 </param>
	<param name="name">
 The namespace or type the alias refers to.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MembersImportsClause(Roslyn.Compilers.VisualBasic.NameSyntax)">
	<summary>
 Represents the clause of an Imports statement that imports all members of a
 namespace.
 </summary>
	<param name="name">
 The namespace or type being imported.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlNamespaceImportsClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlAttributeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Defines a XML namespace for XML expressions.
 </summary>
	<param name="xmlNamespace">
 Identifies the XML namespace alias and URI.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlNamespaceImportsClause(Roslyn.Compilers.VisualBasic.XmlAttributeSyntax)">
	<summary>
 Defines a XML namespace for XML expressions.
 </summary>
	<param name="xmlNamespace">
 Identifies the XML namespace alias and URI.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NamespaceBlock(Roslyn.Compilers.VisualBasic.NamespaceStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a Namespace statement, its contents and the End Namespace statement.
 </summary>
	<param name="begin">
 The statement that begins the NamespaceBlock.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="members">
 The declarations contained in the namespace statement.
 </param>
	<param name="end">
 The End Namespace statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NamespaceBlock(Roslyn.Compilers.VisualBasic.NamespaceStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents a Namespace statement, its contents and the End Namespace statement.
 </summary>
	<param name="begin">
 The statement that begins the NamespaceBlock.
 </param>
	<param name="members">
 The declarations contained in the namespace statement.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NamespaceBlock(Roslyn.Compilers.VisualBasic.NamespaceStatementSyntax)">
	<summary>
 Represents a Namespace statement, its contents and the End Namespace statement.
 </summary>
	<param name="begin">
 The statement that begins the NamespaceBlock.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NamespaceStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.NameSyntax)">
	<summary>
 Represents the beginning statement of a namespace declaration. This node always
 appears as the Begin of a BlockStatement with Kind=NamespaceBlock.
 </summary>
	<param name="namespaceKeyword">
 The "Namespace" keyword.
 </param>
	<param name="name">
 A (possibly dotted) name denoting the namespace being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NamespaceStatement(Roslyn.Compilers.VisualBasic.NameSyntax)">
	<summary>
 Represents the beginning statement of a namespace declaration. This node always
 appears as the Begin of a BlockStatement with Kind=NamespaceBlock.
 </summary>
	<param name="name">
 A (possibly dotted) name denoting the namespace being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ModuleBlock(Roslyn.Compilers.VisualBasic.ModuleStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a declaration of Module, its contents and the End statement that
 ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
	<param name="implements">
 A list of the Implements declarations for the type.
 </param>
	<param name="members">
 The declarations contained in the type or module.
 </param>
	<param name="end">
 The End XXX statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ModuleBlock(Roslyn.Compilers.VisualBasic.ModuleStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents a declaration of Module, its contents and the End statement that
 ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
	<param name="implements">
 A list of the Implements declarations for the type.
 </param>
	<param name="members">
 The declarations contained in the type or module.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ModuleBlock(Roslyn.Compilers.VisualBasic.ModuleStatementSyntax)">
	<summary>
 Represents a declaration of Module, its contents and the End statement that
 ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.StructureBlock(Roslyn.Compilers.VisualBasic.StructureStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a declaration of a Structure, its contents and the End statement
 that ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
	<param name="implements">
 A list of the Implements declarations for the type.
 </param>
	<param name="members">
 The declarations contained in the type or module.
 </param>
	<param name="end">
 The End XXX statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.StructureBlock(Roslyn.Compilers.VisualBasic.StructureStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents a declaration of a Structure, its contents and the End statement
 that ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
	<param name="implements">
 A list of the Implements declarations for the type.
 </param>
	<param name="members">
 The declarations contained in the type or module.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.StructureBlock(Roslyn.Compilers.VisualBasic.StructureStatementSyntax)">
	<summary>
 Represents a declaration of a Structure, its contents and the End statement
 that ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.InterfaceBlock(Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a declaration of a Interface, its contents and the End statement
 that ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
	<param name="implements">
 A list of the Implements declarations for the type.
 </param>
	<param name="members">
 The declarations contained in the type or module.
 </param>
	<param name="end">
 The End XXX statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.InterfaceBlock(Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents a declaration of a Interface, its contents and the End statement
 that ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
	<param name="implements">
 A list of the Implements declarations for the type.
 </param>
	<param name="members">
 The declarations contained in the type or module.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.InterfaceBlock(Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax)">
	<summary>
 Represents a declaration of a Interface, its contents and the End statement
 that ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ClassBlock(Roslyn.Compilers.VisualBasic.ClassStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a declaration of a Class its contents and the End statement that
 ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
	<param name="implements">
 A list of the Implements declarations for the type.
 </param>
	<param name="members">
 The declarations contained in the type or module.
 </param>
	<param name="end">
 The End XXX statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ClassBlock(Roslyn.Compilers.VisualBasic.ClassStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents a declaration of a Class its contents and the End statement that
 ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
	<param name="implements">
 A list of the Implements declarations for the type.
 </param>
	<param name="members">
 The declarations contained in the type or module.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ClassBlock(Roslyn.Compilers.VisualBasic.ClassStatementSyntax)">
	<summary>
 Represents a declaration of a Class its contents and the End statement that
 ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EnumBlock(Roslyn.Compilers.VisualBasic.EnumStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a declaration of an Enum, its contents and the End Enum statement
 that ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="members">
 The declarations contained in the enumeration.
 </param>
	<param name="end">
 The End XXX statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EnumBlock(Roslyn.Compilers.VisualBasic.EnumStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents a declaration of an Enum, its contents and the End Enum statement
 that ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="members">
 The declarations contained in the enumeration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EnumBlock(Roslyn.Compilers.VisualBasic.EnumStatementSyntax)">
	<summary>
 Represents a declaration of an Enum, its contents and the End Enum statement
 that ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.InheritsStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeSyntax})">
	<summary>
 Represents an Inherits statement in a Class, Structure or Interface.
 </summary>
	<param name="inheritsKeyword">
 The "Inherits" keyword.
 </param>
	<param name="types">
 A list of the types being inherited.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.InheritsStatement(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeSyntax})">
	<summary>
 Represents an Inherits statement in a Class, Structure or Interface.
 </summary>
	<param name="types">
 A list of the types being inherited.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.InheritsStatement(Roslyn.Compilers.VisualBasic.TypeSyntax[])">
	<summary>
 Represents an Inherits statement in a Class, Structure or Interface.
 </summary>
	<param name="types">
 A list of the types being inherited.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ImplementsStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeSyntax})">
	<summary>
 Represents an Implements statement in a Class or Structure.
 </summary>
	<param name="implementsKeyword">
 The "Implements" keyword.
 </param>
	<param name="types">
 A list of the types being implemented.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ImplementsStatement(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeSyntax})">
	<summary>
 Represents an Implements statement in a Class or Structure.
 </summary>
	<param name="types">
 A list of the types being implemented.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ImplementsStatement(Roslyn.Compilers.VisualBasic.TypeSyntax[])">
	<summary>
 Represents an Implements statement in a Class or Structure.
 </summary>
	<param name="types">
 A list of the types being implemented.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ModuleStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Represents the beginning statement of a Module declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="keyword">
 The "Module", "Class", "Interface" or "Structure" keyword.
 </param>
	<param name="identifier">
 The name of the type being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ModuleStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Represents the beginning statement of a Module declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="identifier">
 The name of the type being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ModuleStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the beginning statement of a Module declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
 </summary>
	<param name="identifier">
 The name of the type being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ModuleStatement(System.String)">
	<summary>
 Represents the beginning statement of a Module declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
 </summary>
	<param name="identifier">
 The name of the type being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.StructureStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Represents the beginning statement of a Structure declaration. This node always
 appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="keyword">
 The "Module", "Class", "Interface" or "Structure" keyword.
 </param>
	<param name="identifier">
 The name of the type being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.StructureStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Represents the beginning statement of a Structure declaration. This node always
 appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="identifier">
 The name of the type being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.StructureStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the beginning statement of a Structure declaration. This node always
 appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
 </summary>
	<param name="identifier">
 The name of the type being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.StructureStatement(System.String)">
	<summary>
 Represents the beginning statement of a Structure declaration. This node always
 appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
 </summary>
	<param name="identifier">
 The name of the type being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.InterfaceStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Represents the beginning statement of a Interface declaration. This node always
 appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="keyword">
 The "Module", "Class", "Interface" or "Structure" keyword.
 </param>
	<param name="identifier">
 The name of the type being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.InterfaceStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Represents the beginning statement of a Interface declaration. This node always
 appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="identifier">
 The name of the type being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.InterfaceStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the beginning statement of a Interface declaration. This node always
 appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
 </summary>
	<param name="identifier">
 The name of the type being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.InterfaceStatement(System.String)">
	<summary>
 Represents the beginning statement of a Interface declaration. This node always
 appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
 </summary>
	<param name="identifier">
 The name of the type being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ClassStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Represents the beginning statement of a Class declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="keyword">
 The "Module", "Class", "Interface" or "Structure" keyword.
 </param>
	<param name="identifier">
 The name of the type being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ClassStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax)">
	<summary>
 Represents the beginning statement of a Class declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="identifier">
 The name of the type being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ClassStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the beginning statement of a Class declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
 </summary>
	<param name="identifier">
 The name of the type being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ClassStatement(System.String)">
	<summary>
 Represents the beginning statement of a Class declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
 </summary>
	<param name="identifier">
 The name of the type being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EnumStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents the beginning statement of an Enum declaration. This node always
 appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="enumKeyword">
 The "Enum" keyword.
 </param>
	<param name="identifier">
 The name of the enum being declared.
 </param>
	<param name="underlyingType">
 Optional "As XXX" clause describing the underlying type of the enumeration. If
 no As clause was specified, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EnumStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents the beginning statement of an Enum declaration. This node always
 appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="identifier">
 The name of the enum being declared.
 </param>
	<param name="underlyingType">
 Optional "As XXX" clause describing the underlying type of the enumeration. If
 no As clause was specified, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EnumStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the beginning statement of an Enum declaration. This node always
 appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
 </summary>
	<param name="identifier">
 The name of the enum being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EnumStatement(System.String)">
	<summary>
 Represents the beginning statement of an Enum declaration. This node always
 appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
 </summary>
	<param name="identifier">
 The name of the enum being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeParameterList(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeParameterSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the type parameter list in a declaration.
 </summary>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="ofKeyword">
 The "Of" keyword.
 </param>
	<param name="parameters">
 A list of the type parameters. There must be at least one type parameter in the
 list.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeParameterList(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeParameterSyntax})">
	<summary>
 Represents the type parameter list in a declaration.
 </summary>
	<param name="parameters">
 A list of the type parameters. There must be at least one type parameter in the
 list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeParameterList(Roslyn.Compilers.VisualBasic.TypeParameterSyntax[])">
	<summary>
 Represents the type parameter list in a declaration.
 </summary>
	<param name="parameters">
 A list of the type parameters. There must be at least one type parameter in the
 list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeParameter(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterConstraintClauseSyntax)">
	<summary>
 Represents a type parameter on a generic type declaration.
 </summary>
	<param name="varianceKeyword">
 Represents the "In" or "Out" variance keyword on a type parameter, if present.
 If no variance modifier was present, Nothing is returned.
 </param>
	<param name="identifier">
 The name of the type parameter
 </param>
	<param name="typeParameterConstraintClause">
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeParameter(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a type parameter on a generic type declaration.
 </summary>
	<param name="identifier">
 The name of the type parameter
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeParameter(System.String)">
	<summary>
 Represents a type parameter on a generic type declaration.
 </summary>
	<param name="identifier">
 The name of the type parameter
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeParameterSingleConstraintClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ConstraintSyntax)">
	<summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As Constraint".
 </summary>
	<param name="asKeyword">
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </param>
	<param name="constraint">
 A list of the supplied constraints. If no constraints were supplied, Nothing is
 returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeParameterSingleConstraintClause(Roslyn.Compilers.VisualBasic.ConstraintSyntax)">
	<summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As Constraint".
 </summary>
	<param name="constraint">
 A list of the supplied constraints. If no constraints were supplied, Nothing is
 returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeParameterMultipleConstraintClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ConstraintSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As { Constraints }".
 </summary>
	<param name="asKeyword">
 The "As" keyword.
 </param>
	<param name="openBraceToken">
 The "{" token.
 </param>
	<param name="constraints">
 A list of the supplied constraints. If no constraints were supplied, an empty
 list is returned.
 </param>
	<param name="closeBraceToken">
 The "}" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeParameterMultipleConstraintClause(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ConstraintSyntax})">
	<summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As { Constraints }".
 </summary>
	<param name="constraints">
 A list of the supplied constraints. If no constraints were supplied, an empty
 list is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeParameterMultipleConstraintClause(Roslyn.Compilers.VisualBasic.ConstraintSyntax[])">
	<summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As { Constraints }".
 </summary>
	<param name="constraints">
 A list of the supplied constraints. If no constraints were supplied, an empty
 list is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NewConstraint(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
	<param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ClassConstraint(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
	<param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.StructureConstraint(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
	<param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SpecialConstraint(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 SpecialConstraintSyntax. One of NewConstraint, ClassConstraint,
 StructureConstraint.
 </param>
	<param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeConstraint(Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Represents a type parameter constraint that is a type.
 </summary>
	<param name="type">
 The type describing the constraint.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EnumMemberDeclaration(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.EqualsValueSyntax)">
	<summary>
 Represents a name and value in an EnumDeclarationBlock.
 </summary>
	<param name="initializer">
 An optional value for the enum member.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EnumMemberDeclaration(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a name and value in an EnumDeclarationBlock.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EnumMemberDeclaration(System.String)">
	<summary>
 Represents a name and value in an EnumDeclarationBlock.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SubBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SubBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SubBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FunctionBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FunctionBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FunctionBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ConstructorBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ConstructorBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ConstructorBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OperatorBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OperatorBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OperatorBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PropertyGetBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PropertyGetBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PropertyGetBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PropertySetBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PropertySetBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PropertySetBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AddHandlerBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AddHandlerBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AddHandlerBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RemoveHandlerBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RemoveHandlerBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RemoveHandlerBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RaiseEventBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RaiseEventBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RaiseEventBlock(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MethodBlock(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of MethodBlockSyntax.
 One of SubBlock, FunctionBlock, ConstructorBlock, OperatorBlock,
 PropertyGetBlock, PropertySetBlock, AddHandlerBlock, RemoveHandlerBlock,
 RaiseEventBlock.
 </param>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MethodBlock(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of MethodBlockSyntax.
 One of SubBlock, FunctionBlock, ConstructorBlock, OperatorBlock,
 PropertyGetBlock, PropertySetBlock, AddHandlerBlock, RemoveHandlerBlock,
 RaiseEventBlock.
 </param>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MethodBlock(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of MethodBlockSyntax.
 One of SubBlock, FunctionBlock, ConstructorBlock, OperatorBlock,
 PropertyGetBlock, PropertySetBlock, AddHandlerBlock, RemoveHandlerBlock,
 RaiseEventBlock.
 </param>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PropertyBlock(Roslyn.Compilers.VisualBasic.PropertyStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.MethodBlockSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block property declaration: A declaration that has a beginning
 declaration, some get or set accessor blocks and an end statement.
 </summary>
	<param name="begin">
 The property declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="accessors">
 The accessor blocks contained in the property, between the Property and the End
 Property statements.
 </param>
	<param name="end">
 The End Property statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PropertyBlock(Roslyn.Compilers.VisualBasic.PropertyStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.MethodBlockSyntax})">
	<summary>
 Represents a block property declaration: A declaration that has a beginning
 declaration, some get or set accessor blocks and an end statement.
 </summary>
	<param name="begin">
 The property declaration that begins the block.
 </param>
	<param name="accessors">
 The accessor blocks contained in the property, between the Property and the End
 Property statements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EventBlock(Roslyn.Compilers.VisualBasic.EventStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.MethodBlockSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a custom event declaration: A declaration that has a beginning event
 declaration, some accessor blocks and an end statement.
 </summary>
	<param name="begin">
 The event declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="accessors">
 The accessor blocks contained in the custom event declaration, between the
 Event statement and the End Event statement.
 </param>
	<param name="end">
 The End Event statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EventBlock(Roslyn.Compilers.VisualBasic.EventStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.MethodBlockSyntax})">
	<summary>
 Represents a custom event declaration: A declaration that has a beginning event
 declaration, some accessor blocks and an end statement.
 </summary>
	<param name="begin">
 The event declaration that begins the block.
 </param>
	<param name="accessors">
 The accessor blocks contained in the custom event declaration, between the
 Event statement and the End Event statement.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParameterList(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ParameterSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the parameter list in a method declaration.
 </summary>
	<param name="openParenToken">
 The "(" token that introduces the parameter list. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="parameters">
 The list of parameters. If no parameter list was present, Nothing is returned.
 </param>
	<param name="closeParenToken">
 The ")" token that concludes the parameter list. If no parameter list was
 present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParameterList(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ParameterSyntax})">
	<summary>
 Represents the parameter list in a method declaration.
 </summary>
	<param name="parameters">
 The list of parameters. If no parameter list was present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParameterList">
	<summary>
 Represents the parameter list in a method declaration.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SubStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.HandlesClauseSyntax,Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax)">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
	<param name="handlesClause">
 If present, a Handles clause indicated the events that this method handles.
 </param>
	<param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SubStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.HandlesClauseSyntax,Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax)">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
	<param name="handlesClause">
 If present, a Handles clause indicated the events that this method handles.
 </param>
	<param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SubStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="identifier">
 The name of the method being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SubStatement(System.String)">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="identifier">
 The name of the method being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FunctionStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.HandlesClauseSyntax,Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax)">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
	<param name="handlesClause">
 If present, a Handles clause indicated the events that this method handles.
 </param>
	<param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FunctionStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.HandlesClauseSyntax,Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax)">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
	<param name="handlesClause">
 If present, a Handles clause indicated the events that this method handles.
 </param>
	<param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FunctionStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="identifier">
 The name of the method being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FunctionStatement(System.String)">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="identifier">
 The name of the method being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MethodStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.HandlesClauseSyntax,Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax)">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 MethodStatementSyntax. One of SubStatement, FunctionStatement.
 </param>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
	<param name="handlesClause">
 If present, a Handles clause indicated the events that this method handles.
 </param>
	<param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MethodStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 MethodStatementSyntax. One of SubStatement, FunctionStatement.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MethodStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,System.String)">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 MethodStatementSyntax. One of SubStatement, FunctionStatement.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ConstructorStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 A statement that declares a constructor. This statement will be the Begin of a
 BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
 will be the Body of that BlockStatement.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="newKeyword">
 The "New" keyword in the constructor declaration.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ConstructorStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 A statement that declares a constructor. This statement will be the Begin of a
 BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
 will be the Body of that BlockStatement.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ConstructorStatement">
	<summary>
 A statement that declares a constructor. This statement will be the Begin of a
 BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
 will be the Body of that BlockStatement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DeclareSubStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="declareKeyword">
 The "Declare" keyword.
 </param>
	<param name="charsetKeyword">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="libKeyword">
 The "Lib" keyword.
 </param>
	<param name="libraryName">
 The string literal with the library name.
 </param>
	<param name="aliasKeyword">
 If present, the "Alias" keyword. If not present, returns Nothing.
 </param>
	<param name="aliasName">
 The string literal with the alias. If not present, returns Nothing.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DeclareSubStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="charsetKeyword">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="libraryName">
 The string literal with the library name.
 </param>
	<param name="aliasName">
 The string literal with the alias. If not present, returns Nothing.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DeclareSubStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax)">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="libraryName">
 The string literal with the library name.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DeclareSubStatement(System.String,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax)">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="libraryName">
 The string literal with the library name.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DeclareFunctionStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="declareKeyword">
 The "Declare" keyword.
 </param>
	<param name="charsetKeyword">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="libKeyword">
 The "Lib" keyword.
 </param>
	<param name="libraryName">
 The string literal with the library name.
 </param>
	<param name="aliasKeyword">
 If present, the "Alias" keyword. If not present, returns Nothing.
 </param>
	<param name="aliasName">
 The string literal with the alias. If not present, returns Nothing.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DeclareFunctionStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="charsetKeyword">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="libraryName">
 The string literal with the library name.
 </param>
	<param name="aliasName">
 The string literal with the alias. If not present, returns Nothing.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DeclareFunctionStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax)">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="libraryName">
 The string literal with the library name.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DeclareFunctionStatement(System.String,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax)">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="libraryName">
 The string literal with the library name.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DeclareStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 DeclareStatementSyntax. One of DeclareSubStatement, DeclareFunctionStatement.
 </param>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="declareKeyword">
 The "Declare" keyword.
 </param>
	<param name="charsetKeyword">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="libKeyword">
 The "Lib" keyword.
 </param>
	<param name="libraryName">
 The string literal with the library name.
 </param>
	<param name="aliasKeyword">
 If present, the "Alias" keyword. If not present, returns Nothing.
 </param>
	<param name="aliasName">
 The string literal with the alias. If not present, returns Nothing.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DeclareStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 DeclareStatementSyntax. One of DeclareSubStatement, DeclareFunctionStatement.
 </param>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="charsetKeyword">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="libraryName">
 The string literal with the library name.
 </param>
	<param name="aliasName">
 The string literal with the alias. If not present, returns Nothing.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DeclareStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax)">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 DeclareStatementSyntax. One of DeclareSubStatement, DeclareFunctionStatement.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="libraryName">
 The string literal with the library name.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DeclareStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,System.String,Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax)">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 DeclareStatementSyntax. One of DeclareSubStatement, DeclareFunctionStatement.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="libraryName">
 The string literal with the library name.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DelegateSubStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 A statement that declares a delegate type.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="delegateKeyword">
 The "Delegate" keyword.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the delegate being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DelegateSubStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 A statement that declares a delegate type.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="identifier">
 The name of the delegate being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DelegateSubStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 A statement that declares a delegate type.
 </summary>
	<param name="identifier">
 The name of the delegate being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DelegateSubStatement(System.String)">
	<summary>
 A statement that declares a delegate type.
 </summary>
	<param name="identifier">
 The name of the delegate being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DelegateFunctionStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 A statement that declares a delegate type.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="delegateKeyword">
 The "Delegate" keyword.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the delegate being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DelegateFunctionStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 A statement that declares a delegate type.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="identifier">
 The name of the delegate being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DelegateFunctionStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 A statement that declares a delegate type.
 </summary>
	<param name="identifier">
 The name of the delegate being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DelegateFunctionStatement(System.String)">
	<summary>
 A statement that declares a delegate type.
 </summary>
	<param name="identifier">
 The name of the delegate being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DelegateStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 A statement that declares a delegate type.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 DelegateStatementSyntax. One of DelegateSubStatement,
 DelegateFunctionStatement.
 </param>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="delegateKeyword">
 The "Delegate" keyword.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the delegate being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DelegateStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 A statement that declares a delegate type.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 DelegateStatementSyntax. One of DelegateSubStatement,
 DelegateFunctionStatement.
 </param>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the delegate being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DelegateStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 A statement that declares a delegate type.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 DelegateStatementSyntax. One of DelegateSubStatement,
 DelegateFunctionStatement.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the delegate being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DelegateStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,System.String)">
	<summary>
 A statement that declares a delegate type.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 DelegateStatementSyntax. One of DelegateSubStatement,
 DelegateFunctionStatement.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the delegate being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EventStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax)">
	<summary>
 A statement that declares an event. If the event being declared is a custom
 event, this statement will be the Begin of a PropertyOrEventBlock, and the
 accessors will be part of the Accessors of that node.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="customKeyword">
 The optional Custom keyword for custom event declarations.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the event being declared.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
	<param name="implementsClause">
 If present, an Implements clause indicates the interface methods that this
 method implements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EventStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax)">
	<summary>
 A statement that declares an event. If the event being declared is a custom
 event, this statement will be the Begin of a PropertyOrEventBlock, and the
 accessors will be part of the Accessors of that node.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="identifier">
 The name of the event being declared.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
	<param name="implementsClause">
 If present, an Implements clause indicates the interface methods that this
 method implements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EventStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 A statement that declares an event. If the event being declared is a custom
 event, this statement will be the Begin of a PropertyOrEventBlock, and the
 accessors will be part of the Accessors of that node.
 </summary>
	<param name="identifier">
 The name of the event being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EventStatement(System.String)">
	<summary>
 A statement that declares an event. If the event being declared is a custom
 event, this statement will be the Begin of a PropertyOrEventBlock, and the
 accessors will be part of the Accessors of that node.
 </summary>
	<param name="identifier">
 The name of the event being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OperatorStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 A statement that declares an operator. If this operator has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="operator">
 The operator being defined.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OperatorStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 A statement that declares an operator. If this operator has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="operator">
 The operator being defined.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OperatorStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 A statement that declares an operator. If this operator has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="operator">
 The operator being defined.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PropertyStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.EqualsValueSyntax,Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax)">
	<summary>
 Statement that declares a property. If this property has accessors declared,
 this statement will be the Begin of a BlockNode, and the accessors will be the
 Body of that node. Auto properties are property declarations without a
 PropertyBlock.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the property being declared.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
	<param name="initializer">
 If present, an "= initial-value" clause describing the initial value of the
 property.
 </param>
	<param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PropertyStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.EqualsValueSyntax,Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax)">
	<summary>
 Statement that declares a property. If this property has accessors declared,
 this statement will be the Begin of a BlockNode, and the accessors will be the
 Body of that node. Auto properties are property declarations without a
 PropertyBlock.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="identifier">
 The name of the property being declared.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
	<param name="initializer">
 If present, an "= initial-value" clause describing the initial value of the
 property.
 </param>
	<param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PropertyStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Statement that declares a property. If this property has accessors declared,
 this statement will be the Begin of a BlockNode, and the accessors will be the
 Body of that node. Auto properties are property declarations without a
 PropertyBlock.
 </summary>
	<param name="identifier">
 The name of the property being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PropertyStatement(System.String)">
	<summary>
 Statement that declares a property. If this property has accessors declared,
 this statement will be the Begin of a BlockNode, and the accessors will be the
 Body of that node. Auto properties are property declarations without a
 PropertyBlock.
 </summary>
	<param name="identifier">
 The name of the property being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GetAccessorStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GetAccessorStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GetAccessorStatement">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SetAccessorStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SetAccessorStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SetAccessorStatement">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AddHandlerAccessorStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AddHandlerAccessorStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AddHandlerAccessorStatement">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RemoveHandlerAccessorStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RemoveHandlerAccessorStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RemoveHandlerAccessorStatement">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RaiseEventHandlerAccessorStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RaiseEventHandlerAccessorStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RaiseEventHandlerAccessorStatement">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AccessorStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 AccessorStatementSyntax. One of GetAccessorStatement, SetAccessorStatement,
 AddHandlerAccessorStatement, RemoveHandlerAccessorStatement,
 RaiseEventHandlerAccessorStatement.
 </param>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AccessorStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 AccessorStatementSyntax. One of GetAccessorStatement, SetAccessorStatement,
 AddHandlerAccessorStatement, RemoveHandlerAccessorStatement,
 RaiseEventHandlerAccessorStatement.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ImplementsClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.QualifiedNameSyntax})">
	<summary>
 Represents the "Implements ..." clause on a type member, which describes which
 interface members this member implements.
 </summary>
	<param name="implementsKeyword">
 The "Implements" keyword.
 </param>
	<param name="interfaceMembers">
 The list of interface members being implemented.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ImplementsClause(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.QualifiedNameSyntax})">
	<summary>
 Represents the "Implements ..." clause on a type member, which describes which
 interface members this member implements.
 </summary>
	<param name="interfaceMembers">
 The list of interface members being implemented.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ImplementsClause(Roslyn.Compilers.VisualBasic.QualifiedNameSyntax[])">
	<summary>
 Represents the "Implements ..." clause on a type member, which describes which
 interface members this member implements.
 </summary>
	<param name="interfaceMembers">
 The list of interface members being implemented.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.HandlesClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.HandlesClauseItemSyntax})">
	<summary>
 Represents the "Handles ..." clause on a method declaration that describes
 which events this method handles.
 </summary>
	<param name="handlesKeyword">
 The "Handles" keyword.
 </param>
	<param name="events">
 The list of event members being handled.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.HandlesClause(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.HandlesClauseItemSyntax})">
	<summary>
 Represents the "Handles ..." clause on a method declaration that describes
 which events this method handles.
 </summary>
	<param name="events">
 The list of event members being handled.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.HandlesClause(Roslyn.Compilers.VisualBasic.HandlesClauseItemSyntax[])">
	<summary>
 Represents the "Handles ..." clause on a method declaration that describes
 which events this method handles.
 </summary>
	<param name="events">
 The list of event members being handled.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.KeywordEventContainer(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents event container specified through special keywords "Me", "MyBase" or
 "MyClass"..
 </summary>
	<param name="keyword">
 The container of the event. This can be one of the special keywords: "Me",
 "MyBase" or "MyClass".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IdentifierEventContainer(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents event container that refers to a WithEvents member.
 </summary>
	<param name="identifier">
 The container of the event. It is a simple identifier that refers to a
 WithEvents member of the containing type.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IdentifierEventContainer(System.String)">
	<summary>
 Represents event container that refers to a WithEvents member.
 </summary>
	<param name="identifier">
 The container of the event. It is a simple identifier that refers to a
 WithEvents member of the containing type.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.HandlesClauseItem(Roslyn.Compilers.VisualBasic.EventContainerSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.IdentifierNameSyntax)">
	<summary>
 Represents a single handled event in a "Handles ..." clause.
 </summary>
	<param name="eventContainer">
 The container of the event. This can either be a simple identifier (identifying
 a members of the containing type) or one of the special keywords "Me", "MyBase"
 or "MyClass".
 </param>
	<param name="dotToken">
 The "." token.
 </param>
	<param name="eventMember">
 The event being handled. This must be a simple identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.HandlesClauseItem(Roslyn.Compilers.VisualBasic.EventContainerSyntax,Roslyn.Compilers.VisualBasic.IdentifierNameSyntax)">
	<summary>
 Represents a single handled event in a "Handles ..." clause.
 </summary>
	<param name="eventContainer">
 The container of the event. This can either be a simple identifier (identifying
 a members of the containing type) or one of the special keywords "Me", "MyBase"
 or "MyClass".
 </param>
	<param name="eventMember">
 The event being handled. This must be a simple identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IncompleteMember(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the beginning of a declaration. However, not enough syntax is
 detected to classify this as a field, method, property or event. This is node
 always represents a syntax error.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="missingIdentifier">
 The missing identifier token for this incomplete member. Should only be used to
 have a location for error reporting.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IncompleteMember">
	<summary>
 Represents the beginning of a declaration. However, not enough syntax is
 detected to classify this as a field, method, property or event. This is node
 always represents a syntax error.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FieldDeclaration(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax})">
	<summary>
 Represents the declaration of one or more variables or constants, either as
 local variables or as class/structure members. In the case of a constant, it is
 represented by having "Const" in the Modifiers (although technically "Const" is
 not a modifier, it is represented as one in the parse trees.)
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="declarators">
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FieldDeclaration(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax})">
	<summary>
 Represents the declaration of one or more variables or constants, either as
 local variables or as class/structure members. In the case of a constant, it is
 represented by having "Const" in the Modifiers (although technically "Const" is
 not a modifier, it is represented as one in the parse trees.)
 </summary>
	<param name="declarators">
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FieldDeclaration(Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax[])">
	<summary>
 Represents the declaration of one or more variables or constants, either as
 local variables or as class/structure members. In the case of a constant, it is
 represented by having "Const" in the Modifiers (although technically "Const" is
 not a modifier, it is represented as one in the parse trees.)
 </summary>
	<param name="declarators">
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.VariableDeclarator(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax},Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.EqualsValueSyntax)">
	<summary>
 Represents the part of a variable or constant declaration statement that
 associated one or more variable names with a type.
 </summary>
	<param name="names">
 The names of the variables being declared. Each name might have a "?" or "()"
 modifier(s) attached.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type, and possibly includes "New",
 "With" or "From". If no As clause was present, Nothing is returned.
 </param>
	<param name="initializer">
 If present, an "= initial-value" clause describing the initial value of the
 variable or the value of the constant.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.VariableDeclarator(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax})">
	<summary>
 Represents the part of a variable or constant declaration statement that
 associated one or more variable names with a type.
 </summary>
	<param name="names">
 The names of the variables being declared. Each name might have a "?" or "()"
 modifier(s) attached.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.VariableDeclarator(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax[])">
	<summary>
 Represents the part of a variable or constant declaration statement that
 associated one or more variable names with a type.
 </summary>
	<param name="names">
 The names of the variables being declared. Each name might have a "?" or "()"
 modifier(s) attached.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SimpleAsClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Represents an "As {type-name}" clause that does not have an initializer or
 "New". The type has optional attributes associated with it, although attributes
 are not permitted in all possible places where this node occurs.
 </summary>
	<param name="asKeyword">
 The "As" keyword.
 </param>
	<param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
	<param name="type">
 The type-name part of the As clause.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SimpleAsClause(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Represents an "As {type-name}" clause that does not have an initializer or
 "New". The type has optional attributes associated with it, although attributes
 are not permitted in all possible places where this node occurs.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
	<param name="type">
 The type-name part of the As clause.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SimpleAsClause(Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Represents an "As {type-name}" clause that does not have an initializer or
 "New". The type has optional attributes associated with it, although attributes
 are not permitted in all possible places where this node occurs.
 </summary>
	<param name="type">
 The type-name part of the As clause.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AsNewClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.NewExpressionSyntax)">
	<summary>
 Represents an "As New {type-name} [arguments] [initializers]" clause in a
 declaration. The type has optional attributes associated with it, although
 attributes are not permitted in many places where this node occurs (they are
 permitted, for example, on automatically implemented properties.)
 </summary>
	<param name="asKeyword">
 The "As" keyword.
 </param>
	<param name="newExpression">
 The New expression
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AsNewClause(Roslyn.Compilers.VisualBasic.NewExpressionSyntax)">
	<summary>
 Represents an "As New {type-name} [arguments] [initializers]" clause in a
 declaration. The type has optional attributes associated with it, although
 attributes are not permitted in many places where this node occurs (they are
 permitted, for example, on automatically implemented properties.)
 </summary>
	<param name="newExpression">
 The New expression
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ObjectMemberInitializer(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.FieldInitializerSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a "With {...} clause used to initialize a new object's members.
 </summary>
	<param name="withKeyword">
 The "With" keyword.
 </param>
	<param name="openBraceToken">
 The "{" token.
 </param>
	<param name="initializers">
 The comma-separated list of field initializers.
 </param>
	<param name="closeBraceToken">
 The "}" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ObjectMemberInitializer(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.FieldInitializerSyntax})">
	<summary>
 Represents a "With {...} clause used to initialize a new object's members.
 </summary>
	<param name="initializers">
 The comma-separated list of field initializers.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ObjectMemberInitializer(Roslyn.Compilers.VisualBasic.FieldInitializerSyntax[])">
	<summary>
 Represents a "With {...} clause used to initialize a new object's members.
 </summary>
	<param name="initializers">
 The comma-separated list of field initializers.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ObjectCollectionInitializer(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax)">
	<summary>
 Represents a "From {...} clause used to initialize a new collection object's
 elements.
 </summary>
	<param name="fromKeyword">
 The "From" keyword.
 </param>
	<param name="initializer">
 The initializer including the braces.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ObjectCollectionInitializer(Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax)">
	<summary>
 Represents a "From {...} clause used to initialize a new collection object's
 elements.
 </summary>
	<param name="initializer">
 The initializer including the braces.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.InferredFieldInitializer(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represent a field initializer in a With {...} initializer where the field name
 is inferred from the initializer expression.
 </summary>
	<param name="keyKeyword">
 The optional "Key" keyword.
 </param>
	<param name="expression">
 The value being assigned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.InferredFieldInitializer(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represent a field initializer in a With {...} initializer where the field name
 is inferred from the initializer expression.
 </summary>
	<param name="expression">
 The value being assigned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NamedFieldInitializer(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.IdentifierNameSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represent a named field initializer in a With {...} initializer, such as ".x =
 expr".
 </summary>
	<param name="keyKeyword">
 The optional "Key" keyword.
 </param>
	<param name="dotToken">
 The "." token.
 </param>
	<param name="name">
 The name of the field being initialized.
 </param>
	<param name="equalsToken">
 The "=" token.
 </param>
	<param name="expression">
 The value being assigned to the field.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NamedFieldInitializer(Roslyn.Compilers.VisualBasic.IdentifierNameSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represent a named field initializer in a With {...} initializer, such as ".x =
 expr".
 </summary>
	<param name="name">
 The name of the field being initialized.
 </param>
	<param name="expression">
 The value being assigned to the field.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EqualsValue(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an "= initializer" clause in a declaration for a variable,
 pararameter or automatic property.
 </summary>
	<param name="equalsToken">
 The "=" token.
 </param>
	<param name="value">
 The expression used as the initial value.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EqualsValue(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an "= initializer" clause in a declaration for a variable,
 pararameter or automatic property.
 </summary>
	<param name="value">
 The expression used as the initial value.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Parameter(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.EqualsValueSyntax)">
	<summary>
 Represent a parameter to a method, property, constructor, etc.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this parameter. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of the modifier tokens "ByVal", "ByRef", "Optional" or "ParamArray" that
 modify this parameter.
 </param>
	<param name="identifier">
 The name of the parameter, including any "?" or "()" modifiers.
 </param>
	<param name="asClause">
 If present, the "As type-name" clause describing the type of the parameter. If
 no As clause is present, Nothing is returned.
 </param>
	<param name="default">
 If present, an initializer with the default value of the parameter. If no
 default value is present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Parameter(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax)">
	<summary>
 Represent a parameter to a method, property, constructor, etc.
 </summary>
	<param name="identifier">
 The name of the parameter, including any "?" or "()" modifiers.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ModifiedIdentifier(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ArgumentListSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax})">
	<summary>
 Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
 used in parameter declarations and variable declarations.
 </summary>
	<param name="identifier">
 The identifier that names the item being declared.
 </param>
	<param name="nullable">
 The "?" token that indicates a nullable type.
 </param>
	<param name="arrayBounds">
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </param>
	<param name="arrayRankSpecifiers">
 A list of array modifiers for the type. If no array modifiers were present, an
 empty list is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ModifiedIdentifier(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ArgumentListSyntax)">
	<summary>
 Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
 used in parameter declarations and variable declarations.
 </summary>
	<param name="identifier">
 The identifier that names the item being declared.
 </param>
	<param name="arrayBounds">
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ModifiedIdentifier(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
 used in parameter declarations and variable declarations.
 </summary>
	<param name="identifier">
 The identifier that names the item being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ModifiedIdentifier(System.String)">
	<summary>
 Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
 used in parameter declarations and variable declarations.
 </summary>
	<param name="identifier">
 The identifier that names the item being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ArrayRankSpecifier(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a modifier that describes an array type, without bounds, such as
 "()" or "(,)".
 </summary>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="commaTokens">
 The comma tokens in the array type. There is one less comma than the rank.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ArrayRankSpecifier">
	<summary>
 Represents a modifier that describes an array type, without bounds, such as
 "()" or "(,)".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AttributeList(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AttributeSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a group of attributes within "&lt;" and "&gt;" brackets.
 </summary>
	<param name="lessThanToken">
 The "&lt;" token.
 </param>
	<param name="attributes">
 A comma separated list of attribute declarations in this attribute list.
 </param>
	<param name="greaterThanToken">
 The "&gt;" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AttributeList(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AttributeSyntax})">
	<summary>
 Represents a group of attributes within "&lt;" and "&gt;" brackets.
 </summary>
	<param name="attributes">
 A comma separated list of attribute declarations in this attribute list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AttributeList">
	<summary>
 Represents a group of attributes within "&lt;" and "&gt;" brackets.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Attribute(Roslyn.Compilers.VisualBasic.AttributeTargetSyntax,Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.ArgumentListSyntax)">
	<summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
	<param name="target">
 Optional attribute target. Assembly|Module :
 </param>
	<param name="name">
 The name of the attribute.
 </param>
	<param name="argumentList">
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Attribute(Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
	<param name="name">
 The name of the attribute.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AttributeTarget(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
	<param name="attributeModifier">
 The "Assembly" or "Module" attribute modifier, is present. If no attribute
 modifier is present, Nothing is returned.
 </param>
	<param name="colonToken">
 The ":" token, if an attribute modifier is present. If no attribute modifier is
 present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AttributeTarget(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
	<param name="attributeModifier">
 The "Assembly" or "Module" attribute modifier, is present. If no attribute
 modifier is present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AttributesStatement(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax})">
	<summary>
 Represents a file-level attribute, in which the attributes have no other
 syntactic element they are attached to.
 </summary>
	<param name="attributeLists">
 The list of attribute lists.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AttributesStatement">
	<summary>
 Represents a file-level attribute, in which the attributes have no other
 syntactic element they are attached to.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExpressionStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represent an expression in a statement context.
 </summary>
	<param name="questionToken">
 "?" token, if present.
 </param>
	<param name="expression">
 The expression.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExpressionStatement(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represent an expression in a statement context.
 </summary>
	<param name="expression">
 The expression.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.WhileBlock(Roslyn.Compilers.VisualBasic.WhileStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a While...End While statement, including the While, body and End
 While.
 </summary>
	<param name="begin">
 The While statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the While...End While. This might be an empty list.
 </param>
	<param name="end">
 The End While statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.WhileBlock(Roslyn.Compilers.VisualBasic.WhileStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents a While...End While statement, including the While, body and End
 While.
 </summary>
	<param name="begin">
 The While statement that begins the block.
 </param>
	<param name="statements">
 The statements contained in the While...End While. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.WhileBlock(Roslyn.Compilers.VisualBasic.WhileStatementSyntax)">
	<summary>
 Represents a While...End While statement, including the While, body and End
 While.
 </summary>
	<param name="begin">
 The While statement that begins the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.UsingBlock(Roslyn.Compilers.VisualBasic.UsingStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents an entire Using...End Using statement, including the Using, body and
 End Using statements.
 </summary>
	<param name="begin">
 The UsingStatement that begins the Using...End Using block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the Using...End Using block. This might be an empty
 list.
 </param>
	<param name="end">
 The End Using statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.UsingBlock(Roslyn.Compilers.VisualBasic.UsingStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents an entire Using...End Using statement, including the Using, body and
 End Using statements.
 </summary>
	<param name="begin">
 The UsingStatement that begins the Using...End Using block.
 </param>
	<param name="statements">
 The statements contained in the Using...End Using block. This might be an empty
 list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.UsingBlock(Roslyn.Compilers.VisualBasic.UsingStatementSyntax)">
	<summary>
 Represents an entire Using...End Using statement, including the Using, body and
 End Using statements.
 </summary>
	<param name="begin">
 The UsingStatement that begins the Using...End Using block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SyncLockBlock(Roslyn.Compilers.VisualBasic.SyncLockStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a entire SyncLock...End SyncLock block, including the SyncLock
 statement, the enclosed statements, and the End SyncLock statment.
 </summary>
	<param name="begin">
 The SyncLock statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the SyncLock...End SyncLock statement. This might
 be an empty list.
 </param>
	<param name="end">
 The End SyncLock statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SyncLockBlock(Roslyn.Compilers.VisualBasic.SyncLockStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents a entire SyncLock...End SyncLock block, including the SyncLock
 statement, the enclosed statements, and the End SyncLock statment.
 </summary>
	<param name="begin">
 The SyncLock statement that begins the block.
 </param>
	<param name="statements">
 The statements contained in the SyncLock...End SyncLock statement. This might
 be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SyncLockBlock(Roslyn.Compilers.VisualBasic.SyncLockStatementSyntax)">
	<summary>
 Represents a entire SyncLock...End SyncLock block, including the SyncLock
 statement, the enclosed statements, and the End SyncLock statment.
 </summary>
	<param name="begin">
 The SyncLock statement that begins the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.WithBlock(Roslyn.Compilers.VisualBasic.WithStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a With...End With block, include the With statement, the body of the
 block and the End With statement.
 </summary>
	<param name="begin">
 The WithStatement that begins the With...End With block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the With...End With block. This might be an empty
 list.
 </param>
	<param name="end">
 The End With statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.WithBlock(Roslyn.Compilers.VisualBasic.WithStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents a With...End With block, include the With statement, the body of the
 block and the End With statement.
 </summary>
	<param name="begin">
 The WithStatement that begins the With...End With block.
 </param>
	<param name="statements">
 The statements contained in the With...End With block. This might be an empty
 list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.WithBlock(Roslyn.Compilers.VisualBasic.WithStatementSyntax)">
	<summary>
 Represents a With...End With block, include the With statement, the body of the
 block and the End With statement.
 </summary>
	<param name="begin">
 The WithStatement that begins the With...End With block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LocalDeclarationStatement(Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax})">
	<summary>
 Represents the declaration of one or more local variables or constants.
 </summary>
	<param name="modifiers">
 The modifier token (Static, Dim or Const) that introduces this local variable
 declaration.
 </param>
	<param name="declarators">
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LabelStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a label statement.
 </summary>
	<param name="labelToken">
 The name of the label. If the label is a line number, returns an IntegerLiteral
 that is the line number, otherwise, returns an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LabelStatement(System.String)">
	<summary>
 Represents a label statement.
 </summary>
	<param name="labelToken">
 The name of the label. If the label is a line number, returns an IntegerLiteral
 that is the line number, otherwise, returns an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GoToStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LabelSyntax)">
	<summary>
 Represents a "GoTo" statement.
 </summary>
	<param name="goToKeyword">
 The "GoTo" keyword.
 </param>
	<param name="label">
 The name of the label. If the label is a line number, wraps an IntegerLiteral
 that is the line number, otherwise, wraps an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GoToStatement(Roslyn.Compilers.VisualBasic.LabelSyntax)">
	<summary>
 Represents a "GoTo" statement.
 </summary>
	<param name="label">
 The name of the label. If the label is a line number, wraps an IntegerLiteral
 that is the line number, otherwise, wraps an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IdentifierLabel(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
	<param name="labelToken">
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IdentifierLabel(System.String)">
	<summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
	<param name="labelToken">
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NumericLabel(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
	<param name="labelToken">
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NumericLabel">
	<summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NextLabel(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
	<param name="labelToken">
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NextLabel">
	<summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Label(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of LabelSyntax. One of
 IdentifierLabel, NumericLabel, NextLabel.
 </param>
	<param name="labelToken">
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Label(Roslyn.Compilers.VisualBasic.SyntaxKind,System.String)">
	<summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of LabelSyntax. One of
 IdentifierLabel, NumericLabel, NextLabel.
 </param>
	<param name="labelToken">
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.StopStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
	<param name="stopOrEndKeyword">
 The "Stop" or "End" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
	<param name="stopOrEndKeyword">
 The "Stop" or "End" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.StopOrEndStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 StopOrEndStatementSyntax. One of StopStatement, EndStatement.
 </param>
	<param name="stopOrEndKeyword">
 The "Stop" or "End" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitDoStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitDoStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitForStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitForStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitSubStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitSubStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitFunctionStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitFunctionStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitOperatorStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitOperatorStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitPropertyStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitPropertyStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitTryStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitTryStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitSelectStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitSelectStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitWhileStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitWhileStatement">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of ExitStatementSyntax.
 One of ExitDoStatement, ExitForStatement, ExitSubStatement,
 ExitFunctionStatement, ExitOperatorStatement, ExitPropertyStatement,
 ExitTryStatement, ExitSelectStatement, ExitWhileStatement.
 </param>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExitStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of ExitStatementSyntax.
 One of ExitDoStatement, ExitForStatement, ExitSubStatement,
 ExitFunctionStatement, ExitOperatorStatement, ExitPropertyStatement,
 ExitTryStatement, ExitSelectStatement, ExitWhileStatement.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ContinueWhileStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
	<param name="continueKeyword">
 The "Continue" keyword.
 </param>
	<param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ContinueWhileStatement">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ContinueDoStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
	<param name="continueKeyword">
 The "Continue" keyword.
 </param>
	<param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ContinueDoStatement">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ContinueForStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
	<param name="continueKeyword">
 The "Continue" keyword.
 </param>
	<param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ContinueForStatement">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ContinueStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 ContinueStatementSyntax. One of ContinueWhileStatement, ContinueDoStatement,
 ContinueForStatement.
 </param>
	<param name="continueKeyword">
 The "Continue" keyword.
 </param>
	<param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ContinueStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 ContinueStatementSyntax. One of ContinueWhileStatement, ContinueDoStatement,
 ContinueForStatement.
 </param>
	<param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ReturnStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "Return" statement.
 </summary>
	<param name="returnKeyword">
 The "Return" keyword.
 </param>
	<param name="expression">
 The expression being returned, if present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ReturnStatement(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "Return" statement.
 </summary>
	<param name="expression">
 The expression being returned, if present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ReturnStatement">
	<summary>
 Represents a "Return" statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SingleLineIfStatement(Roslyn.Compilers.VisualBasic.SingleLineIfPartSyntax,Roslyn.Compilers.VisualBasic.SingleLineElsePartSyntax)">
	<summary>
 Represents a line If-Then-Else statement.
 </summary>
	<param name="ifPart">
 The If part of the statement.
 </param>
	<param name="elsePart">
 The Else part of the statement. If there is no Else part, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SingleLineIfStatement(Roslyn.Compilers.VisualBasic.SingleLineIfPartSyntax)">
	<summary>
 Represents a line If-Then-Else statement.
 </summary>
	<param name="ifPart">
 The If part of the statement.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SingleLineIfPart(Roslyn.Compilers.VisualBasic.IfStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents part of a single line If statement, consisting of a beginning
 if-statement, followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an SingleLineIf.
 </summary>
	<param name="begin">
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </param>
	<param name="statements">
 The statements controlled by this If or Else If. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SingleLineIfPart(Roslyn.Compilers.VisualBasic.IfStatementSyntax)">
	<summary>
 Represents part of a single line If statement, consisting of a beginning
 if-statement, followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an SingleLineIf.
 </summary>
	<param name="begin">
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SingleLineElsePart(Roslyn.Compilers.VisualBasic.ElseStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
	<param name="begin">
 The Else statement that introduces this part.
 </param>
	<param name="statements">
 The statements controlled by the Else.This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SingleLineElsePart(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
	<param name="statements">
 The statements controlled by the Else.This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SingleLineElsePart">
	<summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MultiLineIfBlock(Roslyn.Compilers.VisualBasic.IfPartSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.IfPartSyntax},Roslyn.Compilers.VisualBasic.ElsePartSyntax,Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a block If...Then...Else...EndIf Statement. The Kind property can be
 used to determine if it is a block or line If.
 </summary>
	<param name="ifPart">
 The If part of the statement.
 </param>
	<param name="elseIfParts">
 A list of the "ElseIf" parts of the statement. If there are no ElseIf parts,
 then an empty list is returned.
 </param>
	<param name="elsePart">
 The Else part of the statement. If there is no Else part, Nothing is returned.
 </param>
	<param name="end">
 If this is a block if, returns the "End If" statement.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MultiLineIfBlock(Roslyn.Compilers.VisualBasic.IfPartSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.IfPartSyntax},Roslyn.Compilers.VisualBasic.ElsePartSyntax)">
	<summary>
 Represents a block If...Then...Else...EndIf Statement. The Kind property can be
 used to determine if it is a block or line If.
 </summary>
	<param name="ifPart">
 The If part of the statement.
 </param>
	<param name="elseIfParts">
 A list of the "ElseIf" parts of the statement. If there are no ElseIf parts,
 then an empty list is returned.
 </param>
	<param name="elsePart">
 The Else part of the statement. If there is no Else part, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MultiLineIfBlock(Roslyn.Compilers.VisualBasic.IfPartSyntax)">
	<summary>
 Represents a block If...Then...Else...EndIf Statement. The Kind property can be
 used to determine if it is a block or line If.
 </summary>
	<param name="ifPart">
 The If part of the statement.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IfPart(Roslyn.Compilers.VisualBasic.IfStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents part of an If statement, consisting of a beginning statement (If or
 ElseIf), followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an If or ElseIf.
 </summary>
	<param name="begin">
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements controlled by this If or Else If. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IfPart(Roslyn.Compilers.VisualBasic.IfStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents part of an If statement, consisting of a beginning statement (If or
 ElseIf), followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an If or ElseIf.
 </summary>
	<param name="begin">
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </param>
	<param name="statements">
 The statements controlled by this If or Else If. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IfPart(Roslyn.Compilers.VisualBasic.IfStatementSyntax)">
	<summary>
 Represents part of an If statement, consisting of a beginning statement (If or
 ElseIf), followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an If or ElseIf.
 </summary>
	<param name="begin">
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ElseIfPart(Roslyn.Compilers.VisualBasic.IfStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents part of an If statement, consisting of a beginning statement (If or
 ElseIf), followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an If or ElseIf.
 </summary>
	<param name="begin">
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements controlled by this If or Else If. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ElseIfPart(Roslyn.Compilers.VisualBasic.IfStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents part of an If statement, consisting of a beginning statement (If or
 ElseIf), followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an If or ElseIf.
 </summary>
	<param name="begin">
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </param>
	<param name="statements">
 The statements controlled by this If or Else If. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ElseIfPart(Roslyn.Compilers.VisualBasic.IfStatementSyntax)">
	<summary>
 Represents part of an If statement, consisting of a beginning statement (If or
 ElseIf), followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an If or ElseIf.
 </summary>
	<param name="begin">
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ElsePart(Roslyn.Compilers.VisualBasic.ElseStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
	<param name="begin">
 The Else statement that introduces this part.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements controlled by the Else. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ElsePart(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
	<param name="statements">
 The statements controlled by the Else. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ElsePart">
	<summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IfStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the If part or ElseIf part of a If...End If block (or line If). This
 statement is always the Begin of a IfPart. The Kind can be examined to
 determine if this is an If or an ElseIf statement.
 </summary>
	<param name="elseKeyword">
 If this ElseIf was written as "Else If", contains the "Else" keyword. Otherwise
 returns Nothing.
 </param>
	<param name="ifOrElseIfKeyword">
 The "If" or "ElseIf" keyword.
 </param>
	<param name="condition">
 The boolean expression that is being tested.
 </param>
	<param name="thenKeyword">
 The "Then" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IfStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents the If part or ElseIf part of a If...End If block (or line If). This
 statement is always the Begin of a IfPart. The Kind can be examined to
 determine if this is an If or an ElseIf statement.
 </summary>
	<param name="ifOrElseIfKeyword">
 The "If" or "ElseIf" keyword.
 </param>
	<param name="condition">
 The boolean expression that is being tested.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ElseIfStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the If part or ElseIf part of a If...End If block (or line If). This
 statement is always the Begin of a IfPart. The Kind can be examined to
 determine if this is an If or an ElseIf statement.
 </summary>
	<param name="elseKeyword">
 If this ElseIf was written as "Else If", contains the "Else" keyword. Otherwise
 returns Nothing.
 </param>
	<param name="ifOrElseIfKeyword">
 The "If" or "ElseIf" keyword.
 </param>
	<param name="condition">
 The boolean expression that is being tested.
 </param>
	<param name="thenKeyword">
 The "Then" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ElseIfStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents the If part or ElseIf part of a If...End If block (or line If). This
 statement is always the Begin of a IfPart. The Kind can be examined to
 determine if this is an If or an ElseIf statement.
 </summary>
	<param name="ifOrElseIfKeyword">
 The "If" or "ElseIf" keyword.
 </param>
	<param name="condition">
 The boolean expression that is being tested.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ElseStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the Else part of a If...End If block (or line If). This statement is
 always the Begin of a ElsePart.
 </summary>
	<param name="elseKeyword">
 The "Else" keyword
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ElseStatement">
	<summary>
 Represents the Else part of a If...End If block (or line If). This statement is
 always the Begin of a ElsePart.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TryBlock(Roslyn.Compilers.VisualBasic.TryPartSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.CatchPartSyntax},Roslyn.Compilers.VisualBasic.FinallyPartSyntax,Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents an entire Try...Catch...Finally...End Try statement.
 </summary>
	<param name="tryPart">
 The Try part of the statement.
 </param>
	<param name="catchParts">
 A list of the Catch parts of the statement. If there are no Catch parts, then
 an empty list is returned.
 </param>
	<param name="finallyPart">
 The Finally part of the statement, if present.
 </param>
	<param name="end">
 The "End Try" statement.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TryBlock(Roslyn.Compilers.VisualBasic.TryPartSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.CatchPartSyntax},Roslyn.Compilers.VisualBasic.FinallyPartSyntax)">
	<summary>
 Represents an entire Try...Catch...Finally...End Try statement.
 </summary>
	<param name="tryPart">
 The Try part of the statement.
 </param>
	<param name="catchParts">
 A list of the Catch parts of the statement. If there are no Catch parts, then
 an empty list is returned.
 </param>
	<param name="finallyPart">
 The Finally part of the statement, if present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TryBlock(Roslyn.Compilers.VisualBasic.TryPartSyntax)">
	<summary>
 Represents an entire Try...Catch...Finally...End Try statement.
 </summary>
	<param name="tryPart">
 The Try part of the statement.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TryPart(Roslyn.Compilers.VisualBasic.TryStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents part of an Try...Catch...Finally...End Try statement, consisting of
 a beginning statement (Try, Catch or Finally), followed by a body of statements
 controlled by that beginning statement. The Kind property returns which kind of
 part this is.
 </summary>
	<param name="begin">
 The TryStatement that introduces this part of the Try...Catch...Finally...End
 Try.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements inside the Try part of the Try...Catch...Finally...End Try. This
 might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TryPart(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents part of an Try...Catch...Finally...End Try statement, consisting of
 a beginning statement (Try, Catch or Finally), followed by a body of statements
 controlled by that beginning statement. The Kind property returns which kind of
 part this is.
 </summary>
	<param name="statements">
 The statements inside the Try part of the Try...Catch...Finally...End Try. This
 might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TryPart">
	<summary>
 Represents part of an Try...Catch...Finally...End Try statement, consisting of
 a beginning statement (Try, Catch or Finally), followed by a body of statements
 controlled by that beginning statement. The Kind property returns which kind of
 part this is.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CatchPart(Roslyn.Compilers.VisualBasic.CatchStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents a Catch part of an Try...Catch...Finally...End Try statement,
 consisting of a Catch statement, followed by a body of statements controlled by
 that Catch statement. The Kind property returns which kind of part this is.
 </summary>
	<param name="begin">
 The CatchStatement that introduces this part.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements controlled by the Catch statement. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CatchPart(Roslyn.Compilers.VisualBasic.CatchStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents a Catch part of an Try...Catch...Finally...End Try statement,
 consisting of a Catch statement, followed by a body of statements controlled by
 that Catch statement. The Kind property returns which kind of part this is.
 </summary>
	<param name="begin">
 The CatchStatement that introduces this part.
 </param>
	<param name="statements">
 The statements controlled by the Catch statement. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CatchPart(Roslyn.Compilers.VisualBasic.CatchStatementSyntax)">
	<summary>
 Represents a Catch part of an Try...Catch...Finally...End Try statement,
 consisting of a Catch statement, followed by a body of statements controlled by
 that Catch statement. The Kind property returns which kind of part this is.
 </summary>
	<param name="begin">
 The CatchStatement that introduces this part.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FinallyPart(Roslyn.Compilers.VisualBasic.FinallyStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents the Finally part of an Try...Catch...Finally...End Try statement,
 consisting of a Finally statement, followed by a body of statements controlled
 by the Finally.
 </summary>
	<param name="begin">
 The FinallyStatement that introduces the Finally part of a Try.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements inside the Finally part of the Try...Catch...Finally...End Try.
 This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FinallyPart(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents the Finally part of an Try...Catch...Finally...End Try statement,
 consisting of a Finally statement, followed by a body of statements controlled
 by the Finally.
 </summary>
	<param name="statements">
 The statements inside the Finally part of the Try...Catch...Finally...End Try.
 This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FinallyPart">
	<summary>
 Represents the Finally part of an Try...Catch...Finally...End Try statement,
 consisting of a Finally statement, followed by a body of statements controlled
 by the Finally.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TryStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the Try part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a TryPart.
 </summary>
	<param name="tryKeyword">
 The "Try" keyword
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TryStatement">
	<summary>
 Represents the Try part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a TryPart.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CatchStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.IdentifierNameSyntax,Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.CatchFilterClauseSyntax)">
	<summary>
 Represents the Catch part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a CatchPart.
 </summary>
	<param name="catchKeyword">
 The "Catch" keyword.
 </param>
	<param name="identifierName">
 The identifier representing the exception that was caught, if present.
 </param>
	<param name="asClause">
 The As clause that defines the type of exception being caught.
 </param>
	<param name="whenClause">
 The "When" clause, if present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CatchStatement(Roslyn.Compilers.VisualBasic.IdentifierNameSyntax,Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.CatchFilterClauseSyntax)">
	<summary>
 Represents the Catch part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a CatchPart.
 </summary>
	<param name="identifierName">
 The identifier representing the exception that was caught, if present.
 </param>
	<param name="asClause">
 The As clause that defines the type of exception being caught.
 </param>
	<param name="whenClause">
 The "When" clause, if present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CatchStatement">
	<summary>
 Represents the Catch part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a CatchPart.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CatchFilterClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents the When/Filter clause of a Catch statement
 </summary>
	<param name="whenKeyword">
 The "When" keyword
 </param>
	<param name="filter">
 The filter expression
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CatchFilterClause(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents the When/Filter clause of a Catch statement
 </summary>
	<param name="filter">
 The filter expression
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FinallyStatement(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the Finally part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a FinallyPart.
 </summary>
	<param name="finallyKeyword">
 The "Finally" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FinallyStatement">
	<summary>
 Represents the Finally part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a FinallyPart.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ErrorStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents the "Error" statement.
 </summary>
	<param name="errorKeyword">
 The "Error" keyword.
 </param>
	<param name="errorNumber">
 The expression that represents the error number.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ErrorStatement(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents the "Error" statement.
 </summary>
	<param name="errorNumber">
 The expression that represents the error number.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OnErrorGoToZeroStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LabelSyntax)">
	<summary>
 Represents an OnError Goto statement.
 </summary>
	<param name="onKeyword">
 The "On" keyword
 </param>
	<param name="errorKeyword">
 The "Error" keyword.
 </param>
	<param name="goToKeyword">
 The "GoTo" keyword
 </param>
	<param name="minus">
 An optional minus for On Error Goto -1
 </param>
	<param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OnErrorGoToZeroStatement(Roslyn.Compilers.VisualBasic.LabelSyntax)">
	<summary>
 Represents an OnError Goto statement.
 </summary>
	<param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OnErrorGoToMinusOneStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LabelSyntax)">
	<summary>
 Represents an OnError Goto statement.
 </summary>
	<param name="onKeyword">
 The "On" keyword
 </param>
	<param name="errorKeyword">
 The "Error" keyword.
 </param>
	<param name="goToKeyword">
 The "GoTo" keyword
 </param>
	<param name="minus">
 An optional minus for On Error Goto -1
 </param>
	<param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OnErrorGoToMinusOneStatement(Roslyn.Compilers.VisualBasic.LabelSyntax)">
	<summary>
 Represents an OnError Goto statement.
 </summary>
	<param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OnErrorGoToLabelStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LabelSyntax)">
	<summary>
 Represents an OnError Goto statement.
 </summary>
	<param name="onKeyword">
 The "On" keyword
 </param>
	<param name="errorKeyword">
 The "Error" keyword.
 </param>
	<param name="goToKeyword">
 The "GoTo" keyword
 </param>
	<param name="minus">
 An optional minus for On Error Goto -1
 </param>
	<param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OnErrorGoToLabelStatement(Roslyn.Compilers.VisualBasic.LabelSyntax)">
	<summary>
 Represents an OnError Goto statement.
 </summary>
	<param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OnErrorGoToStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LabelSyntax)">
	<summary>
 Represents an OnError Goto statement.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 OnErrorGoToStatementSyntax. One of OnErrorGoToZeroStatement,
 OnErrorGoToMinusOneStatement, OnErrorGoToLabelStatement.
 </param>
	<param name="onKeyword">
 The "On" keyword
 </param>
	<param name="errorKeyword">
 The "Error" keyword.
 </param>
	<param name="goToKeyword">
 The "GoTo" keyword
 </param>
	<param name="minus">
 An optional minus for On Error Goto -1
 </param>
	<param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OnErrorGoToStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.LabelSyntax)">
	<summary>
 Represents an OnError Goto statement.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 OnErrorGoToStatementSyntax. One of OnErrorGoToZeroStatement,
 OnErrorGoToMinusOneStatement, OnErrorGoToLabelStatement.
 </param>
	<param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OnErrorResumeNextStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an OnError Resume Next statement.
 </summary>
	<param name="onKeyword">
 The "On" keyword
 </param>
	<param name="errorKeyword">
 The "Error" keyword.
 </param>
	<param name="resumeKeyword">
 The "Resume" keyword.
 </param>
	<param name="nextKeyword">
 The "Next"
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OnErrorResumeNextStatement">
	<summary>
 Represents an OnError Resume Next statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ResumeStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LabelSyntax)">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
	<param name="resumeKeyword">
 The "Resume" keyword.
 </param>
	<param name="label">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ResumeStatement(Roslyn.Compilers.VisualBasic.LabelSyntax)">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
	<param name="label">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ResumeStatement">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ResumeLabelStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LabelSyntax)">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
	<param name="resumeKeyword">
 The "Resume" keyword.
 </param>
	<param name="label">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ResumeLabelStatement(Roslyn.Compilers.VisualBasic.LabelSyntax)">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
	<param name="label">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ResumeLabelStatement">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ResumeNextStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LabelSyntax)">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
	<param name="resumeKeyword">
 The "Resume" keyword.
 </param>
	<param name="label">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ResumeNextStatement(Roslyn.Compilers.VisualBasic.LabelSyntax)">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
	<param name="label">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ResumeNextStatement">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SelectBlock(Roslyn.Compilers.VisualBasic.SelectStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.CaseBlockSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a Select Case block, including the Select Case that begins it, the
 contains Case blocks and the End Select.
 </summary>
	<param name="begin">
 The Select Case statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="caseBlocks">
 A list of the contained Case blocks.
 </param>
	<param name="end">
 The End Select statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SelectBlock(Roslyn.Compilers.VisualBasic.SelectStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.CaseBlockSyntax})">
	<summary>
 Represents a Select Case block, including the Select Case that begins it, the
 contains Case blocks and the End Select.
 </summary>
	<param name="begin">
 The Select Case statement that begins the block.
 </param>
	<param name="caseBlocks">
 A list of the contained Case blocks.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SelectBlock(Roslyn.Compilers.VisualBasic.SelectStatementSyntax)">
	<summary>
 Represents a Select Case block, including the Select Case that begins it, the
 contains Case blocks and the End Select.
 </summary>
	<param name="begin">
 The Select Case statement that begins the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SelectStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a Select Case statement. This statement always occurs as the Begin
 of a SelectBlock.
 </summary>
	<param name="selectKeyword">
 The "Select" keyword.
 </param>
	<param name="caseKeyword">
 The "Case" keyword, if present.
 </param>
	<param name="expression">
 The value that branching is based on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SelectStatement(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a Select Case statement. This statement always occurs as the Begin
 of a SelectBlock.
 </summary>
	<param name="expression">
 The value that branching is based on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseBlock(Roslyn.Compilers.VisualBasic.CaseStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents a case statement and its subsequent block.
 </summary>
	<param name="begin">
 The statement that begins the case block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the case block. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseBlock(Roslyn.Compilers.VisualBasic.CaseStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents a case statement and its subsequent block.
 </summary>
	<param name="begin">
 The statement that begins the case block.
 </param>
	<param name="statements">
 The statements contained in the case block. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseBlock(Roslyn.Compilers.VisualBasic.CaseStatementSyntax)">
	<summary>
 Represents a case statement and its subsequent block.
 </summary>
	<param name="begin">
 The statement that begins the case block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseElseBlock(Roslyn.Compilers.VisualBasic.CaseStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents a case statement and its subsequent block.
 </summary>
	<param name="begin">
 The statement that begins the case block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the case block. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseElseBlock(Roslyn.Compilers.VisualBasic.CaseStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Represents a case statement and its subsequent block.
 </summary>
	<param name="begin">
 The statement that begins the case block.
 </param>
	<param name="statements">
 The statements contained in the case block. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseElseBlock(Roslyn.Compilers.VisualBasic.CaseStatementSyntax)">
	<summary>
 Represents a case statement and its subsequent block.
 </summary>
	<param name="begin">
 The statement that begins the case block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CaseClauseSyntax})">
	<summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
	<param name="caseKeyword">
 The "Case" keyword
 </param>
	<param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a CaseElseClause.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseStatement(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CaseClauseSyntax})">
	<summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
	<param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a CaseElseClause.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseStatement(Roslyn.Compilers.VisualBasic.CaseClauseSyntax[])">
	<summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
	<param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a CaseElseClause.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseElseStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CaseClauseSyntax})">
	<summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
	<param name="caseKeyword">
 The "Case" keyword
 </param>
	<param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a CaseElseClause.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseElseStatement(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CaseClauseSyntax})">
	<summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
	<param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a CaseElseClause.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseElseStatement(Roslyn.Compilers.VisualBasic.CaseClauseSyntax[])">
	<summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
	<param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a CaseElseClause.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseElseClause(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 The "Else" part in a Case Else statement.
 </summary>
	<param name="elseKeyword">
 The "Else" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseElseClause">
	<summary>
 The "Else" part in a Case Else statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseValueClause(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a single value in a Case.
 </summary>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseRangeClause(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a range "expression To expression" in a Case.
 </summary>
	<param name="lowerBound">
 The lower bound of the range.
 </param>
	<param name="toKeyword">
 The "To" keyword
 </param>
	<param name="upperBound">
 The upper bound of the range.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseRangeClause(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a range "expression To expression" in a Case.
 </summary>
	<param name="lowerBound">
 The lower bound of the range.
 </param>
	<param name="upperBound">
 The upper bound of the range.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseEqualsClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
	<param name="isKeyword">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseEqualsClause(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseNotEqualsClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
	<param name="isKeyword">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseNotEqualsClause(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseLessThanClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
	<param name="isKeyword">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseLessThanClause(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseLessThanOrEqualClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
	<param name="isKeyword">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseLessThanOrEqualClause(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseGreaterThanOrEqualClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
	<param name="isKeyword">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseGreaterThanOrEqualClause(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseGreaterThanClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
	<param name="isKeyword">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseGreaterThanClause(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseRelationalClause(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 CaseRelationalClauseSyntax. One of CaseEqualsClause, CaseNotEqualsClause,
 CaseLessThanClause, CaseLessThanOrEqualClause, CaseGreaterThanOrEqualClause,
 CaseGreaterThanClause.
 </param>
	<param name="isKeyword">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CaseRelationalClause(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 CaseRelationalClauseSyntax. One of CaseEqualsClause, CaseNotEqualsClause,
 CaseLessThanClause, CaseLessThanOrEqualClause, CaseGreaterThanOrEqualClause,
 CaseGreaterThanClause.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SyncLockStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents the "SyncLock" statement. This statement always occurs as the Begin
 of a SyncLockBlock.
 </summary>
	<param name="syncLockKeyword">
 The "SyncLock" keyword.
 </param>
	<param name="expression">
 The expression being synchronized on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SyncLockStatement(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents the "SyncLock" statement. This statement always occurs as the Begin
 of a SyncLockBlock.
 </summary>
	<param name="expression">
 The expression being synchronized on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DoLoopTopTestBlock(Roslyn.Compilers.VisualBasic.DoStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.LoopStatementSyntax)">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
	<param name="begin">
 The Do statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The Loop statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DoLoopTopTestBlock(Roslyn.Compilers.VisualBasic.DoStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.LoopStatementSyntax)">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
	<param name="begin">
 The Do statement that begins the block.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The Loop statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DoLoopTopTestBlock(Roslyn.Compilers.VisualBasic.DoStatementSyntax,Roslyn.Compilers.VisualBasic.LoopStatementSyntax)">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
	<param name="begin">
 The Do statement that begins the block.
 </param>
	<param name="end">
 The Loop statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DoLoopBottomTestBlock(Roslyn.Compilers.VisualBasic.DoStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.LoopStatementSyntax)">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
	<param name="begin">
 The Do statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The Loop statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DoLoopBottomTestBlock(Roslyn.Compilers.VisualBasic.DoStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.LoopStatementSyntax)">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
	<param name="begin">
 The Do statement that begins the block.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The Loop statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DoLoopBottomTestBlock(Roslyn.Compilers.VisualBasic.DoStatementSyntax,Roslyn.Compilers.VisualBasic.LoopStatementSyntax)">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
	<param name="begin">
 The Do statement that begins the block.
 </param>
	<param name="end">
 The Loop statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DoLoopForeverBlock(Roslyn.Compilers.VisualBasic.DoStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.LoopStatementSyntax)">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
	<param name="begin">
 The Do statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The Loop statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DoLoopForeverBlock(Roslyn.Compilers.VisualBasic.DoStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.LoopStatementSyntax)">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
	<param name="begin">
 The Do statement that begins the block.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The Loop statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DoLoopForeverBlock(Roslyn.Compilers.VisualBasic.DoStatementSyntax,Roslyn.Compilers.VisualBasic.LoopStatementSyntax)">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
	<param name="begin">
 The Do statement that begins the block.
 </param>
	<param name="end">
 The Loop statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DoLoopBlock(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.DoStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.LoopStatementSyntax)">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of DoLoopBlockSyntax.
 One of DoLoopTopTestBlock, DoLoopBottomTestBlock, DoLoopForeverBlock.
 </param>
	<param name="begin">
 The Do statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The Loop statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DoLoopBlock(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.DoStatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.LoopStatementSyntax)">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of DoLoopBlockSyntax.
 One of DoLoopTopTestBlock, DoLoopBottomTestBlock, DoLoopForeverBlock.
 </param>
	<param name="begin">
 The Do statement that begins the block.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The Loop statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DoLoopBlock(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.DoStatementSyntax,Roslyn.Compilers.VisualBasic.LoopStatementSyntax)">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of DoLoopBlockSyntax.
 One of DoLoopTopTestBlock, DoLoopBottomTestBlock, DoLoopForeverBlock.
 </param>
	<param name="begin">
 The Do statement that begins the block.
 </param>
	<param name="end">
 The Loop statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DoStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.WhileUntilClauseSyntax)">
	<summary>
 The Do statement that begins a Do-Loop block. This statement always occurs as
 the Begin of a DoLoopBlock.
 </summary>
	<param name="doKeyword">
 The "Do" keyword.
 </param>
	<param name="whileUntilClause">
 The "While expression" or "Until expression" part of the Do statement, if
 present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DoStatement(Roslyn.Compilers.VisualBasic.WhileUntilClauseSyntax)">
	<summary>
 The Do statement that begins a Do-Loop block. This statement always occurs as
 the Begin of a DoLoopBlock.
 </summary>
	<param name="whileUntilClause">
 The "While expression" or "Until expression" part of the Do statement, if
 present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DoStatement">
	<summary>
 The Do statement that begins a Do-Loop block. This statement always occurs as
 the Begin of a DoLoopBlock.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LoopStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.WhileUntilClauseSyntax)">
	<summary>
 The Loop statement that ends a Do-Loop block. This statement always occurs as
 the End of a DoLoopBlock.
 </summary>
	<param name="loopKeyword">
 The "Loop" keyword.
 </param>
	<param name="whileUntilClause">
 The "While expression" or "Until expression" part of the Loop statement, if
 present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LoopStatement(Roslyn.Compilers.VisualBasic.WhileUntilClauseSyntax)">
	<summary>
 The Loop statement that ends a Do-Loop block. This statement always occurs as
 the End of a DoLoopBlock.
 </summary>
	<param name="whileUntilClause">
 The "While expression" or "Until expression" part of the Loop statement, if
 present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LoopStatement">
	<summary>
 The Loop statement that ends a Do-Loop block. This statement always occurs as
 the End of a DoLoopBlock.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.WhileClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
	<param name="whileOrUntilKeyword">
 The "While" or "Until" keyword.
 </param>
	<param name="condition">
 The boolean expression after the While or Until.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.WhileClause(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
	<param name="condition">
 The boolean expression after the While or Until.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.UntilClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
	<param name="whileOrUntilKeyword">
 The "While" or "Until" keyword.
 </param>
	<param name="condition">
 The boolean expression after the While or Until.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.UntilClause(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
	<param name="condition">
 The boolean expression after the While or Until.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.WhileUntilClause(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 WhileUntilClauseSyntax. One of WhileClause, UntilClause.
 </param>
	<param name="whileOrUntilKeyword">
 The "While" or "Until" keyword.
 </param>
	<param name="condition">
 The boolean expression after the While or Until.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.WhileStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 The While statement that begins a While...End While block. This statement
 always occurs as the Begin of a WhileBlock.
 </summary>
	<param name="whileKeyword">
 The "While" keyword.
 </param>
	<param name="condition">
 The boolean expression that controls the While loop.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.WhileStatement(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 The While statement that begins a While...End While block. This statement
 always occurs as the Begin of a WhileBlock.
 </summary>
	<param name="condition">
 The boolean expression that controls the While loop.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ForBlock(Roslyn.Compilers.VisualBasic.StatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.NextStatementSyntax)">
	<summary>
 Represents a For or For Each block, including the introducting statement, the
 body and the "Next" (which can be omitted if a containing For has a Next with
 multiple variables).
 </summary>
	<param name="begin">
 The For or For Each statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the For or For Each loop. This might be an empty
 list.
 </param>
	<param name="end">
 The Next statement that ends the block. If two For statements are ended by a
 single Next statement, the inner For will not have an EndStatment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ForBlock(Roslyn.Compilers.VisualBasic.StatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.NextStatementSyntax)">
	<summary>
 Represents a For or For Each block, including the introducting statement, the
 body and the "Next" (which can be omitted if a containing For has a Next with
 multiple variables).
 </summary>
	<param name="begin">
 The For or For Each statement that begins the block.
 </param>
	<param name="statements">
 The statements contained in the For or For Each loop. This might be an empty
 list.
 </param>
	<param name="end">
 The Next statement that ends the block. If two For statements are ended by a
 single Next statement, the inner For will not have an EndStatment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ForBlock(Roslyn.Compilers.VisualBasic.StatementSyntax)">
	<summary>
 Represents a For or For Each block, including the introducting statement, the
 body and the "Next" (which can be omitted if a containing For has a Next with
 multiple variables).
 </summary>
	<param name="begin">
 The For or For Each statement that begins the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ForEachBlock(Roslyn.Compilers.VisualBasic.StatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.NextStatementSyntax)">
	<summary>
 Represents a For or For Each block, including the introducting statement, the
 body and the "Next" (which can be omitted if a containing For has a Next with
 multiple variables).
 </summary>
	<param name="begin">
 The For or For Each statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the For or For Each loop. This might be an empty
 list.
 </param>
	<param name="end">
 The Next statement that ends the block. If two For statements are ended by a
 single Next statement, the inner For will not have an EndStatment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ForEachBlock(Roslyn.Compilers.VisualBasic.StatementSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.NextStatementSyntax)">
	<summary>
 Represents a For or For Each block, including the introducting statement, the
 body and the "Next" (which can be omitted if a containing For has a Next with
 multiple variables).
 </summary>
	<param name="begin">
 The For or For Each statement that begins the block.
 </param>
	<param name="statements">
 The statements contained in the For or For Each loop. This might be an empty
 list.
 </param>
	<param name="end">
 The Next statement that ends the block. If two For statements are ended by a
 single Next statement, the inner For will not have an EndStatment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ForEachBlock(Roslyn.Compilers.VisualBasic.StatementSyntax)">
	<summary>
 Represents a For or For Each block, including the introducting statement, the
 body and the "Next" (which can be omitted if a containing For has a Next with
 multiple variables).
 </summary>
	<param name="begin">
 The For or For Each statement that begins the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ForStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ForStepClauseSyntax)">
	<summary>
 The For statement that begins a For-Next block. This statement always occurs as
 the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
	<param name="forKeyword">
 The "For" keyword.
 </param>
	<param name="controlVariable">
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </param>
	<param name="equalsToken">
 The "=" token.
 </param>
	<param name="fromValue">
 The expression denoting the initial value of the iteration.
 </param>
	<param name="toKeyword">
 The "To" keyword.
 </param>
	<param name="toValue">
 The expression denoting the final value of the iteration.
 </param>
	<param name="stepClause">
 The optional Step clause.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ForStatement(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ForStepClauseSyntax)">
	<summary>
 The For statement that begins a For-Next block. This statement always occurs as
 the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
	<param name="controlVariable">
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </param>
	<param name="fromValue">
 The expression denoting the initial value of the iteration.
 </param>
	<param name="toValue">
 The expression denoting the final value of the iteration.
 </param>
	<param name="stepClause">
 The optional Step clause.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ForStatement(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 The For statement that begins a For-Next block. This statement always occurs as
 the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
	<param name="controlVariable">
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </param>
	<param name="fromValue">
 The expression denoting the initial value of the iteration.
 </param>
	<param name="toValue">
 The expression denoting the final value of the iteration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ForStepClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 The Step clause in a For Statement.
 </summary>
	<param name="stepKeyword">
 The "Step" keyword.
 </param>
	<param name="stepValue">
 The expression denoting the step increment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ForStepClause(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 The Step clause in a For Statement.
 </summary>
	<param name="stepValue">
 The expression denoting the step increment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ForEachStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 The For Each statement that begins a For Each-Next block. This statement always
 occurs as the Begin of a ForBlock, and the body of the For Each-Next is the
 Body of that ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
	<param name="forKeyword">
 The "For" keyword.
 </param>
	<param name="eachKeyword">
 The "Each" keyword.
 </param>
	<param name="controlVariable">
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </param>
	<param name="inKeyword">
 The "In" keyword.
 </param>
	<param name="expression">
 The expression denoting the collection to iterate over.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ForEachStatement(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 The For Each statement that begins a For Each-Next block. This statement always
 occurs as the Begin of a ForBlock, and the body of the For Each-Next is the
 Body of that ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
	<param name="controlVariable">
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </param>
	<param name="expression">
 The expression denoting the collection to iterate over.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NextStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionSyntax})">
	<summary>
 The Next statement that ends a For-Next or For Each-Next block. This statement
 always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
 and the body of the For-Next is the Body of that ForBlock. The Begin of that
 ForBlock has the corresponding For or For Each statement.
 </summary>
	<param name="nextKeyword">
 The "Next" keyword.
 </param>
	<param name="controlVariables">
 The variables in the Next statement, if present
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NextStatement(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionSyntax})">
	<summary>
 The Next statement that ends a For-Next or For Each-Next block. This statement
 always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
 and the body of the For-Next is the Body of that ForBlock. The Begin of that
 ForBlock has the corresponding For or For Each statement.
 </summary>
	<param name="controlVariables">
 The variables in the Next statement, if present
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NextStatement">
	<summary>
 The Next statement that ends a For-Next or For Each-Next block. This statement
 always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
 and the body of the For-Next is the Body of that ForBlock. The Begin of that
 ForBlock has the corresponding For or For Each statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.UsingStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax})">
	<summary>
 The Using statement that begins a Using block. This statement always occurs as
 the Begin of a UsingBlock, and the body of the Using is the Body of that
 UsingBlock.
 </summary>
	<param name="usingKeyword">
 The "Using" keyword.
 </param>
	<param name="expression">
 If the Using statement is of a form that does not declare a new variable, this
 is the expression used in the using. Otherwise, Nothing is returned.
 </param>
	<param name="variables">
 If the Using statement is of a form that declares one or more new variables,
 this is the list of variable declarations. Otherwise, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.UsingStatement(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax})">
	<summary>
 The Using statement that begins a Using block. This statement always occurs as
 the Begin of a UsingBlock, and the body of the Using is the Body of that
 UsingBlock.
 </summary>
	<param name="expression">
 If the Using statement is of a form that does not declare a new variable, this
 is the expression used in the using. Otherwise, Nothing is returned.
 </param>
	<param name="variables">
 If the Using statement is of a form that declares one or more new variables,
 this is the list of variable declarations. Otherwise, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.UsingStatement">
	<summary>
 The Using statement that begins a Using block. This statement always occurs as
 the Begin of a UsingBlock, and the body of the Using is the Body of that
 UsingBlock.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ThrowStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a Throw statement.
 </summary>
	<param name="throwKeyword">
 The "Throw" keyword
 </param>
	<param name="expression">
 The expression denoting the value being thrown.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ThrowStatement(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a Throw statement.
 </summary>
	<param name="expression">
 The expression denoting the value being thrown.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ThrowStatement">
	<summary>
 Represents a Throw statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AssignmentStatement(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MidAssignment(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AddAssignment(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SubtractAssignment(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MultiplyAssignment(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DivideAssignment(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IntegerDivideAssignment(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PowerAssignment(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LeftShiftAssignment(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RightShiftAssignment(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ConcatenateAssignment(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CallStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represent an call statement (also known as a invocation statement).
 </summary>
	<param name="callKeyword">
 The "Call" keyword, if present.
 </param>
	<param name="invocation">
 The expression denoting the call. This could be an Invocation or a MemberAccess
 (in the case where no parentheses were supplied.)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CallStatement(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represent an call statement (also known as a invocation statement).
 </summary>
	<param name="invocation">
 The expression denoting the call. This could be an Invocation or a MemberAccess
 (in the case where no parentheses were supplied.)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AddHandlerStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
	<param name="addHandlerOrRemoveHandlerKeyword">
 The "AddHandler" or "RemoveHandler" keyword.
 </param>
	<param name="eventExpression">
 The event being accessed.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AddHandlerStatement(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
	<param name="eventExpression">
 The event being accessed.
 </param>
	<param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RemoveHandlerStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
	<param name="addHandlerOrRemoveHandlerKeyword">
 The "AddHandler" or "RemoveHandler" keyword.
 </param>
	<param name="eventExpression">
 The event being accessed.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RemoveHandlerStatement(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
	<param name="eventExpression">
 The event being accessed.
 </param>
	<param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AddRemoveHandlerStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 AddRemoveHandlerStatementSyntax. One of AddHandlerStatement,
 RemoveHandlerStatement.
 </param>
	<param name="addHandlerOrRemoveHandlerKeyword">
 The "AddHandler" or "RemoveHandler" keyword.
 </param>
	<param name="eventExpression">
 The event being accessed.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AddRemoveHandlerStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 AddRemoveHandlerStatementSyntax. One of AddHandlerStatement,
 RemoveHandlerStatement.
 </param>
	<param name="addHandlerOrRemoveHandlerKeyword">
 The "AddHandler" or "RemoveHandler" keyword.
 </param>
	<param name="eventExpression">
 The event being accessed.
 </param>
	<param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RaiseEventStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.IdentifierNameSyntax,Roslyn.Compilers.VisualBasic.ArgumentListSyntax)">
	<summary>
 Represent a RaiseEvent statement.
 </summary>
	<param name="raiseEventKeyword">
 The "RaiseEvent" keyword
 </param>
	<param name="name">
 The name of the event being raised.
 </param>
	<param name="argumentList">
 The argument list, if present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RaiseEventStatement(Roslyn.Compilers.VisualBasic.IdentifierNameSyntax,Roslyn.Compilers.VisualBasic.ArgumentListSyntax)">
	<summary>
 Represent a RaiseEvent statement.
 </summary>
	<param name="name">
 The name of the event being raised.
 </param>
	<param name="argumentList">
 The argument list, if present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RaiseEventStatement(Roslyn.Compilers.VisualBasic.IdentifierNameSyntax)">
	<summary>
 Represent a RaiseEvent statement.
 </summary>
	<param name="name">
 The name of the event being raised.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.WithStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "With" statement. This statement always occurs as the
 BeginStatement of a WithBlock, and the body of the With is the Body of that
 WithBlock.
 </summary>
	<param name="withKeyword">
 The "With" keyword.
 </param>
	<param name="expression">
 The expression that is the operand of the With statement.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.WithStatement(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "With" statement. This statement always occurs as the
 BeginStatement of a WithBlock, and the body of the With is the Body of that
 WithBlock.
 </summary>
	<param name="expression">
 The expression that is the operand of the With statement.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ReDimStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax})">
	<summary>
 Represents a ReDim statement.
 </summary>
	<param name="reDimKeyword">
 The "ReDim" keyword.
 </param>
	<param name="preserveKeyword">
 Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
 Kind=RedimPreserve.
 </param>
	<param name="clauses">
 The list of ReDim clauses. Each clause is a Invocation node with an argument
 list denoting the new bounds for the array.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ReDimStatement(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax})">
	<summary>
 Represents a ReDim statement.
 </summary>
	<param name="clauses">
 The list of ReDim clauses. Each clause is a Invocation node with an argument
 list denoting the new bounds for the array.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ReDimStatement(Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax[])">
	<summary>
 Represents a ReDim statement.
 </summary>
	<param name="clauses">
 The list of ReDim clauses. Each clause is a Invocation node with an argument
 list denoting the new bounds for the array.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ReDimPreserveStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax})">
	<summary>
 Represents a ReDim statement.
 </summary>
	<param name="reDimKeyword">
 The "ReDim" keyword.
 </param>
	<param name="preserveKeyword">
 Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
 Kind=RedimPreserve.
 </param>
	<param name="clauses">
 The list of ReDim clauses. Each clause is a Invocation node with an argument
 list denoting the new bounds for the array.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ReDimPreserveStatement(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax})">
	<summary>
 Represents a ReDim statement.
 </summary>
	<param name="clauses">
 The list of ReDim clauses. Each clause is a Invocation node with an argument
 list denoting the new bounds for the array.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ReDimPreserveStatement(Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax[])">
	<summary>
 Represents a ReDim statement.
 </summary>
	<param name="clauses">
 The list of ReDim clauses. Each clause is a Invocation node with an argument
 list denoting the new bounds for the array.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EraseStatement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionSyntax})">
	<summary>
 Represents an "Erase" statement.
 </summary>
	<param name="eraseKeyword">
 The "Erase" keyword.
 </param>
	<param name="expressions">
 A list of expressions denoting the arrays to erase.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EraseStatement(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionSyntax})">
	<summary>
 Represents an "Erase" statement.
 </summary>
	<param name="expressions">
 A list of expressions denoting the arrays to erase.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EraseStatement(Roslyn.Compilers.VisualBasic.ExpressionSyntax[])">
	<summary>
 Represents an "Erase" statement.
 </summary>
	<param name="expressions">
 A list of expressions denoting the arrays to erase.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CharacterLiteralExpression(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TrueLiteralExpression(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FalseLiteralExpression(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NumericLiteralExpression(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DateLiteralExpression(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.StringLiteralExpression(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NothingLiteralExpression(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LiteralExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 LiteralExpressionSyntax. One of CharacterLiteralExpression,
 TrueLiteralExpression, FalseLiteralExpression, NumericLiteralExpression,
 DateLiteralExpression, StringLiteralExpression, NothingLiteralExpression.
 </param>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParenthesizedExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a parenthesized expression.
 </summary>
	<param name="openParenToken">
 The "(" token
 </param>
	<param name="expression">
 The expression inside the parentheses.
 </param>
	<param name="closeParenToken">
 The ")" token
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParenthesizedExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a parenthesized expression.
 </summary>
	<param name="expression">
 The expression inside the parentheses.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MeExpression(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Identifies the special instance "Me"
 </summary>
	<param name="keyword">
 The "Me", "MyClass" or "MyBase" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MeExpression">
	<summary>
 Identifies the special instance "Me"
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MyBaseExpression(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Identifies the special instance "MyBase"
 </summary>
	<param name="keyword">
 The "Me", "MyClass" or "MyBase" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MyBaseExpression">
	<summary>
 Identifies the special instance "MyBase"
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MyClassExpression(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Identifies the special instance "MyClass"
 </summary>
	<param name="keyword">
 The "Me", "MyClass" or "MyBase" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MyClassExpression">
	<summary>
 Identifies the special instance "MyClass"
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GetTypeExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a GetType expression.
 </summary>
	<param name="getTypeKeyword">
 The "GetType" keyword.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="type">
 The type to get the Type object for. This can be an open generic type.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GetTypeExpression(Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Represents a GetType expression.
 </summary>
	<param name="type">
 The type to get the Type object for. This can be an open generic type.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeOfIsExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
	<param name="typeOfKeyword">
 The "TypeOf" keyword.
 </param>
	<param name="expression">
 The expression being tested.
 </param>
	<param name="operatorToken">
 The "Is" or "IsNot" keyword.
 </param>
	<param name="type">
 The name of the type being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeOfIsExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
	<param name="expression">
 The expression being tested.
 </param>
	<param name="type">
 The name of the type being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeOfIsNotExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
	<param name="typeOfKeyword">
 The "TypeOf" keyword.
 </param>
	<param name="expression">
 The expression being tested.
 </param>
	<param name="operatorToken">
 The "Is" or "IsNot" keyword.
 </param>
	<param name="type">
 The name of the type being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeOfIsNotExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
	<param name="expression">
 The expression being tested.
 </param>
	<param name="type">
 The name of the type being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeOfExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 TypeOfExpressionSyntax. One of TypeOfIsExpression, TypeOfIsNotExpression.
 </param>
	<param name="typeOfKeyword">
 The "TypeOf" keyword.
 </param>
	<param name="expression">
 The expression being tested.
 </param>
	<param name="operatorToken">
 The "Is" or "IsNot" keyword.
 </param>
	<param name="type">
 The name of the type being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeOfExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 TypeOfExpressionSyntax. One of TypeOfIsExpression, TypeOfIsNotExpression.
 </param>
	<param name="expression">
 The expression being tested.
 </param>
	<param name="operatorToken">
 The "Is" or "IsNot" keyword.
 </param>
	<param name="type">
 The name of the type being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GetXmlNamespaceExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlPrefixNameSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a GetXmlNamespace expression.
 </summary>
	<param name="getXmlNamespaceKeyword">
 The "GetXmlNamespace" keyword.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="name">
 The Xml namespace name being referenced.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GetXmlNamespaceExpression">
	<summary>
 Represents a GetXmlNamespace expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MemberAccessExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SimpleNameSyntax)">
	<summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
	<param name="expression">
 The expression on the left-hand-side of the "." or "!" token.
 </param>
	<param name="operatorToken">
 The "." or "!" token.
 </param>
	<param name="name">
 The identifier after the "." or "!" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MemberAccessExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SimpleNameSyntax)">
	<summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
	<param name="operatorToken">
 The "." or "!" token.
 </param>
	<param name="name">
 The identifier after the "." or "!" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DictionaryAccessExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SimpleNameSyntax)">
	<summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
	<param name="expression">
 The expression on the left-hand-side of the "." or "!" token.
 </param>
	<param name="operatorToken">
 The "." or "!" token.
 </param>
	<param name="name">
 The identifier after the "." or "!" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DictionaryAccessExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SimpleNameSyntax)">
	<summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
	<param name="operatorToken">
 The "." or "!" token.
 </param>
	<param name="name">
 The identifier after the "." or "!" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlElementAccessExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
	<param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
	<param name="token1">
 The initial dot "." part of the separator.
 </param>
	<param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
	<param name="token3">
 The third "." in a "..." separator.
 </param>
	<param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlElementAccessExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
	<param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
	<param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
	<param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlElementAccessExpression(Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
	<param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlDescendantAccessExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
	<param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
	<param name="token1">
 The initial dot "." part of the separator.
 </param>
	<param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
	<param name="token3">
 The third "." in a "..." separator.
 </param>
	<param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlDescendantAccessExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
	<param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
	<param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
	<param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlDescendantAccessExpression(Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
	<param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlAttributeAccessExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
	<param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
	<param name="token1">
 The initial dot "." part of the separator.
 </param>
	<param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
	<param name="token3">
 The third "." in a "..." separator.
 </param>
	<param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlAttributeAccessExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
	<param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
	<param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
	<param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlAttributeAccessExpression(Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
	<param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlMemberAccessExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 XmlMemberAccessExpressionSyntax. One of XmlElementAccessExpression,
 XmlDescendantAccessExpression, XmlAttributeAccessExpression.
 </param>
	<param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
	<param name="token1">
 The initial dot "." part of the separator.
 </param>
	<param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
	<param name="token3">
 The third "." in a "..." separator.
 </param>
	<param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlMemberAccessExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 XmlMemberAccessExpressionSyntax. One of XmlElementAccessExpression,
 XmlDescendantAccessExpression, XmlAttributeAccessExpression.
 </param>
	<param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
	<param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
	<param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlMemberAccessExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 XmlMemberAccessExpressionSyntax. One of XmlElementAccessExpression,
 XmlDescendantAccessExpression, XmlAttributeAccessExpression.
 </param>
	<param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.InvocationExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ArgumentListSyntax)">
	<summary>
 Represents an invocation expression consisting of an invocation target and an
 optional argument list or an array, parameterized property or object default
 property index.
 </summary>
	<param name="expression">
 The target of the call or index expression.
 </param>
	<param name="argumentList">
 The argument list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.InvocationExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an invocation expression consisting of an invocation target and an
 optional argument list or an array, parameterized property or object default
 property index.
 </summary>
	<param name="expression">
 The target of the call or index expression.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ObjectCreationExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.ArgumentListSyntax,Roslyn.Compilers.VisualBasic.ObjectCreationInitializerSyntax)">
	<summary>
 Represents a New expression that creates a new non-array object, possibly with
 a "With" or "From" clause.
 </summary>
	<param name="newKeyword">
 The "New" keyword.
 </param>
	<param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
	<param name="type">
 The type of the object being initialized.
 </param>
	<param name="argumentList">
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </param>
	<param name="initializer">
 An optional From or With clause to initialize the new object.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ObjectCreationExpression(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.ArgumentListSyntax,Roslyn.Compilers.VisualBasic.ObjectCreationInitializerSyntax)">
	<summary>
 Represents a New expression that creates a new non-array object, possibly with
 a "With" or "From" clause.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
	<param name="type">
 The type of the object being initialized.
 </param>
	<param name="argumentList">
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </param>
	<param name="initializer">
 An optional From or With clause to initialize the new object.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ObjectCreationExpression(Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Represents a New expression that creates a new non-array object, possibly with
 a "With" or "From" clause.
 </summary>
	<param name="type">
 The type of the object being initialized.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AnonymousObjectCreationExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.ObjectMemberInitializerSyntax)">
	<summary>
 Represents a New expression that create an object of anonymous type.
 </summary>
	<param name="newKeyword">
 The "New" keyword.
 </param>
	<param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
	<param name="initializer">
 The With clause to initialize the new object.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AnonymousObjectCreationExpression(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.ObjectMemberInitializerSyntax)">
	<summary>
 Represents a New expression that create an object of anonymous type.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
	<param name="initializer">
 The With clause to initialize the new object.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AnonymousObjectCreationExpression(Roslyn.Compilers.VisualBasic.ObjectMemberInitializerSyntax)">
	<summary>
 Represents a New expression that create an object of anonymous type.
 </summary>
	<param name="initializer">
 The With clause to initialize the new object.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ArrayCreationExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.ArgumentListSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax},Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax)">
	<summary>
 Represents an expression that creates a new array.
 </summary>
	<param name="newKeyword">
 The "New" keyword.
 </param>
	<param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
	<param name="type">
 The element type of the array being created.
 </param>
	<param name="arrayBounds">
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </param>
	<param name="rankSpecifiers">
 A list of array modifiers such as "()" or "(,)". If no array modifiers were
 present, an empty list is returned.
 </param>
	<param name="initializer">
 The initializer including the braces.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ArrayCreationExpression(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.ArgumentListSyntax,Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax)">
	<summary>
 Represents an expression that creates a new array.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
	<param name="type">
 The element type of the array being created.
 </param>
	<param name="arrayBounds">
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </param>
	<param name="initializer">
 The initializer including the braces.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ArrayCreationExpression(Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax)">
	<summary>
 Represents an expression that creates a new array.
 </summary>
	<param name="type">
 The element type of the array being created.
 </param>
	<param name="initializer">
 The initializer including the braces.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CollectionInitializer(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an expression that creates a new array without naming the element
 type.
 </summary>
	<param name="openBraceToken">
 The "{" token.
 </param>
	<param name="initializers">
 The list of initializers between the braces.
 </param>
	<param name="closeBraceToken">
 The "}" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CollectionInitializer(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionSyntax})">
	<summary>
 Represents an expression that creates a new array without naming the element
 type.
 </summary>
	<param name="initializers">
 The list of initializers between the braces.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CollectionInitializer">
	<summary>
 Represents an expression that creates a new array without naming the element
 type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CTypeExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<param name="keyword">
 The "CType", "DirectCast" or "TryCast" keyword.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="expression">
 The expression being cast.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="type">
 The type the expression is being cast to.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CTypeExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<param name="expression">
 The expression being cast.
 </param>
	<param name="type">
 The type the expression is being cast to.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DirectCastExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<param name="keyword">
 The "CType", "DirectCast" or "TryCast" keyword.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="expression">
 The expression being cast.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="type">
 The type the expression is being cast to.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DirectCastExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<param name="expression">
 The expression being cast.
 </param>
	<param name="type">
 The type the expression is being cast to.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TryCastExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<param name="keyword">
 The "CType", "DirectCast" or "TryCast" keyword.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="expression">
 The expression being cast.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="type">
 The type the expression is being cast to.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TryCastExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<param name="expression">
 The expression being cast.
 </param>
	<param name="type">
 The type the expression is being cast to.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PredefinedCastExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a cast to a pre-defined type using a pre-defined cast expression,
 such as CInt or CLng.
 </summary>
	<param name="keyword">
 The keyword that was used in the cast operation.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="expression">
 The expression being cast.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PredefinedCastExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a cast to a pre-defined type using a pre-defined cast expression,
 such as CInt or CLng.
 </summary>
	<param name="keyword">
 The keyword that was used in the cast operation.
 </param>
	<param name="expression">
 The expression being cast.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AddExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AddExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SubtractExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SubtractExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MultiplyExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MultiplyExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DivideExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DivideExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IntegerDivideExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IntegerDivideExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PowerExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PowerExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LeftShiftExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LeftShiftExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RightShiftExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RightShiftExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ConcatenateExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ConcatenateExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ModuloExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ModuloExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EqualsExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EqualsExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NotEqualsExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NotEqualsExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LessThanExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LessThanExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LessThanOrEqualExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LessThanOrEqualExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GreaterThanOrEqualExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GreaterThanOrEqualExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GreaterThanExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GreaterThanExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IsExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IsExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IsNotExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IsNotExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LikeExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LikeExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OrExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OrExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XorExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XorExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AndExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AndExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OrElseExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OrElseExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AndAlsoExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AndAlsoExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.BinaryExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 BinaryExpressionSyntax. One of AddExpression, SubtractExpression,
 MultiplyExpression, DivideExpression, IntegerDivideExpression, PowerExpression,
 LeftShiftExpression, RightShiftExpression, ConcatenateExpression,
 ModuloExpression, EqualsExpression, NotEqualsExpression, LessThanExpression,
 LessThanOrEqualExpression, GreaterThanOrEqualExpression, GreaterThanExpression,
 IsExpression, IsNotExpression, LikeExpression, OrExpression, XorExpression,
 AndExpression, OrElseExpression, AndAlsoExpression.
 </param>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PlusExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
	<param name="operatorToken">
 The token that is the operator.
 </param>
	<param name="operand">
 The expression being operated on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PlusExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
	<param name="operand">
 The expression being operated on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NegateExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
	<param name="operatorToken">
 The token that is the operator.
 </param>
	<param name="operand">
 The expression being operated on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NegateExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
	<param name="operand">
 The expression being operated on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NotExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
	<param name="operatorToken">
 The token that is the operator.
 </param>
	<param name="operand">
 The expression being operated on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NotExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
	<param name="operand">
 The expression being operated on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AddressOfExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
	<param name="operatorToken">
 The token that is the operator.
 </param>
	<param name="operand">
 The expression being operated on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AddressOfExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
	<param name="operand">
 The expression being operated on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.UnaryExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 UnaryExpressionSyntax. One of PlusExpression, NegateExpression, NotExpression,
 AddressOfExpression.
 </param>
	<param name="operatorToken">
 The token that is the operator.
 </param>
	<param name="operand">
 The expression being operated on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.BinaryConditionalExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
	<param name="ifKeyword">
 The "If" keyword
 </param>
	<param name="openParenToken">
 The "(" token
 </param>
	<param name="firstExpression">
 The first expression inside the parentheses.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="secondExpression">
 The second expression inside the parentheses.
 </param>
	<param name="closeParenToken">
 The ")" token
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.BinaryConditionalExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
	<param name="firstExpression">
 The first expression inside the parentheses.
 </param>
	<param name="secondExpression">
 The second expression inside the parentheses.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TernaryConditionalExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
	<param name="ifKeyword">
 The "If" keyword
 </param>
	<param name="openParenToken">
 The "(" token
 </param>
	<param name="condition">
 The first expression inside the parentheses.
 </param>
	<param name="firstCommaToken">
 The "," token.
 </param>
	<param name="whenTrue">
 The second expression inside the parentheses.
 </param>
	<param name="secondCommaToken">
 The "," token.
 </param>
	<param name="whenFalse">
 The second expression inside the parentheses.
 </param>
	<param name="closeParenToken">
 The ")" token
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TernaryConditionalExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
	<param name="condition">
 The first expression inside the parentheses.
 </param>
	<param name="whenTrue">
 The second expression inside the parentheses.
 </param>
	<param name="whenFalse">
 The second expression inside the parentheses.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SingleLineFunctionLambdaExpression(Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Represents a single line lambda expression.
 </summary>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </param>
	<param name="body">
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SingleLineFunctionLambdaExpression(Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Represents a single line lambda expression.
 </summary>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="body">
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SingleLineSubLambdaExpression(Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Represents a single line lambda expression.
 </summary>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </param>
	<param name="body">
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SingleLineSubLambdaExpression(Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Represents a single line lambda expression.
 </summary>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="body">
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SingleLineLambdaExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Represents a single line lambda expression.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 SingleLineLambdaExpressionSyntax. One of SingleLineFunctionLambdaExpression,
 SingleLineSubLambdaExpression.
 </param>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </param>
	<param name="body">
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SingleLineLambdaExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Represents a single line lambda expression.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 SingleLineLambdaExpressionSyntax. One of SingleLineFunctionLambdaExpression,
 SingleLineSubLambdaExpression.
 </param>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="body">
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MultiLineFunctionLambdaExpression(Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a multi-line lambda expression.
 </summary>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </param>
	<param name="statements">
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </param>
	<param name="end">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MultiLineFunctionLambdaExpression(Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a multi-line lambda expression.
 </summary>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="end">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MultiLineSubLambdaExpression(Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a multi-line lambda expression.
 </summary>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </param>
	<param name="statements">
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </param>
	<param name="end">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MultiLineSubLambdaExpression(Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a multi-line lambda expression.
 </summary>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="end">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MultiLineLambdaExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a multi-line lambda expression.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 MultiLineLambdaExpressionSyntax. One of MultiLineFunctionLambdaExpression,
 MultiLineSubLambdaExpression.
 </param>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </param>
	<param name="statements">
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </param>
	<param name="end">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MultiLineLambdaExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax)">
	<summary>
 Represents a multi-line lambda expression.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 MultiLineLambdaExpressionSyntax. One of MultiLineFunctionLambdaExpression,
 MultiLineSubLambdaExpression.
 </param>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="end">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SubLambdaHeader(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents the header part of a lambda expression
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SubLambdaHeader(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents the header part of a lambda expression
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SubLambdaHeader">
	<summary>
 Represents the header part of a lambda expression
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FunctionLambdaHeader(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents the header part of a lambda expression
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FunctionLambdaHeader(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents the header part of a lambda expression
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FunctionLambdaHeader">
	<summary>
 Represents the header part of a lambda expression
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LambdaHeader(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax},Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Represents the header part of a lambda expression
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of LambdaHeaderSyntax.
 One of SubLambdaHeader, FunctionLambdaHeader.
 </param>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LambdaHeader(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the header part of a lambda expression
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of LambdaHeaderSyntax.
 One of SubLambdaHeader, FunctionLambdaHeader.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ArgumentList(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ArgumentSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a parenthesized argument list.
 </summary>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="arguments">
 The list of arguments. This may be empty. Ommitted argument are represented by
 an OmittedArgumentSyntax node.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ArgumentList(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ArgumentSyntax})">
	<summary>
 Represents a parenthesized argument list.
 </summary>
	<param name="arguments">
 The list of arguments. This may be empty. Ommitted argument are represented by
 an OmittedArgumentSyntax node.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ArgumentList">
	<summary>
 Represents a parenthesized argument list.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OmittedArgument(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an omitted argument in an argument list. An omitted argument is not
 considered a syntax error but a valid case when no argument is required.
 </summary>
	<param name="empty">
 An empty token because all non terminals must have a token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OmittedArgument">
	<summary>
 Represents an omitted argument in an argument list. An omitted argument is not
 considered a syntax error but a valid case when no argument is required.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SimpleArgument(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a simple argument that is just an expression.
 </summary>
	<param name="expression">
 The expression that is the argument.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NamedArgument(Roslyn.Compilers.VisualBasic.IdentifierNameSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a named argument, such as "Value:=7".
 </summary>
	<param name="identifierName">
 The name used to identify the named argument.
 </param>
	<param name="colonEqualsToken">
 The ":=" token.
 </param>
	<param name="expression">
 The expression that is the named argument.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NamedArgument(Roslyn.Compilers.VisualBasic.IdentifierNameSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a named argument, such as "Value:=7".
 </summary>
	<param name="identifierName">
 The name used to identify the named argument.
 </param>
	<param name="expression">
 The expression that is the named argument.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RangeArgument(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a range argument, such as "0 to 5", used in array bounds. The
 "Value" property represents the upper bound of the range.
 </summary>
	<param name="lowerBound">
 The lower bound of the range. This is typically the integer constant zero.
 </param>
	<param name="toKeyword">
 The "To" keyword.
 </param>
	<param name="upperBound">
 The upper bound of the range.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RangeArgument(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a range argument, such as "0 to 5", used in array bounds. The
 "Value" property represents the upper bound of the range.
 </summary>
	<param name="lowerBound">
 The lower bound of the range. This is typically the integer constant zero.
 </param>
	<param name="upperBound">
 The upper bound of the range.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.QueryExpression(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryClauseSyntax})">
	<summary>
 This class represents a query expression. A query expression is composed of one
 or more query operators in a row. The first query operator must be a From or
 Aggregate.
 </summary>
	<param name="clauses">
 A list of all the query operators in this query expression. This list always
 contains at least one operator.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.QueryExpression(Roslyn.Compilers.VisualBasic.QueryClauseSyntax[])">
	<summary>
 This class represents a query expression. A query expression is composed of one
 or more query operators in a row. The first query operator must be a From or
 Aggregate.
 </summary>
	<param name="clauses">
 A list of all the query operators in this query expression. This list always
 contains at least one operator.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CollectionRangeVariable(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Describes a single variable of the form "x [As Type] In expression" for use in
 query expressions.
 </summary>
	<param name="identifier">
 The name of the range variable being defined.
 </param>
	<param name="asClause">
 Describes the type of the variable being defined.
 </param>
	<param name="inKeyword">
 The "In" keyword.
 </param>
	<param name="expression">
 The expression that serves as the source of items for the range variable.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CollectionRangeVariable(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Describes a single variable of the form "x [As Type] In expression" for use in
 query expressions.
 </summary>
	<param name="identifier">
 The name of the range variable being defined.
 </param>
	<param name="asClause">
 Describes the type of the variable being defined.
 </param>
	<param name="expression">
 The expression that serves as the source of items for the range variable.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CollectionRangeVariable(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Describes a single variable of the form "x [As Type] In expression" for use in
 query expressions.
 </summary>
	<param name="identifier">
 The name of the range variable being defined.
 </param>
	<param name="expression">
 The expression that serves as the source of items for the range variable.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExpressionRangeVariable(Roslyn.Compilers.VisualBasic.VariableNameEqualsSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Describes a single variable of the form "[x [As Type] =] expression" for use in
 query expressions.
 </summary>
	<param name="nameEquals">
 The optional name and type of the expression range variable. If ommitted, the
 name of the expression range variable is inferred from the expression.
 </param>
	<param name="expression">
 The expression used to initialize the expression variable.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExpressionRangeVariable(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Describes a single variable of the form "[x [As Type] =] expression" for use in
 query expressions.
 </summary>
	<param name="expression">
 The expression used to initialize the expression variable.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AggregationRangeVariable(Roslyn.Compilers.VisualBasic.VariableNameEqualsSyntax,Roslyn.Compilers.VisualBasic.AggregationSyntax)">
	<summary>
 Describes a single variable of the form "[x [As Type] =] aggregation-function"
 for use in the Into clause of Aggregate or Group By or Group Join query
 operators.
 </summary>
	<param name="nameEquals">
 The optional name and type of the expression range variable. If ommitted, the
 name of the expression range variable is inferred from the aggregation
 expression.
 </param>
	<param name="aggregation">
 The name of the aggregation function. The "Group" aggregation function is
 represented by the identifier "Group".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AggregationRangeVariable(Roslyn.Compilers.VisualBasic.AggregationSyntax)">
	<summary>
 Describes a single variable of the form "[x [As Type] =] aggregation-function"
 for use in the Into clause of Aggregate or Group By or Group Join query
 operators.
 </summary>
	<param name="aggregation">
 The name of the aggregation function. The "Group" aggregation function is
 represented by the identifier "Group".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.VariableNameEquals(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the name and optional type of an expression range variable.
 </summary>
	<param name="identifier">
 The name of the variable being defined.
 </param>
	<param name="asClause">
 Describes the type of the variable being defined.
 </param>
	<param name="equalsToken">
 The "=" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.VariableNameEquals(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax)">
	<summary>
 Represents the name and optional type of an expression range variable.
 </summary>
	<param name="identifier">
 The name of the variable being defined.
 </param>
	<param name="asClause">
 Describes the type of the variable being defined.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.VariableNameEquals(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax)">
	<summary>
 Represents the name and optional type of an expression range variable.
 </summary>
	<param name="identifier">
 The name of the variable being defined.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FunctionAggregation(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an invocation of an Aggregation function in the aggregation range
 variable declaration of a Group By, Group Join or Aggregate query operator.
 </summary>
	<param name="functionName">
 The name of the aggregation function.
 </param>
	<param name="openParenToken">
 The "(" token if present.
 </param>
	<param name="argument">
 The argument to the aggregation function.
 </param>
	<param name="closeParenToken">
 The ")" token, if present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FunctionAggregation(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an invocation of an Aggregation function in the aggregation range
 variable declaration of a Group By, Group Join or Aggregate query operator.
 </summary>
	<param name="functionName">
 The name of the aggregation function.
 </param>
	<param name="argument">
 The argument to the aggregation function.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FunctionAggregation(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an invocation of an Aggregation function in the aggregation range
 variable declaration of a Group By, Group Join or Aggregate query operator.
 </summary>
	<param name="functionName">
 The name of the aggregation function.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FunctionAggregation(System.String)">
	<summary>
 Represents an invocation of an Aggregation function in the aggregation range
 variable declaration of a Group By, Group Join or Aggregate query operator.
 </summary>
	<param name="functionName">
 The name of the aggregation function.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GroupAggregation(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the use of "Group" as the aggregation function in the in the
 aggregation range variable declaration of a Group By or Group Join query
 operator.
 </summary>
	<param name="groupKeyword">
 The "Group" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GroupAggregation">
	<summary>
 Represents the use of "Group" as the aggregation function in the in the
 aggregation range variable declaration of a Group By or Group Join query
 operator.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FromClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax})">
	<summary>
 Represents a "From" query operator. If this is the beginning of a query, the
 Source will be Nothing. Otherwise, the Source will be the part of the query to
 the left of the From.
 </summary>
	<param name="fromKeyword">
 The "From" keyword.
 </param>
	<param name="variables">
 The list of collection variables declared by this From operator.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FromClause(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax})">
	<summary>
 Represents a "From" query operator. If this is the beginning of a query, the
 Source will be Nothing. Otherwise, the Source will be the part of the query to
 the left of the From.
 </summary>
	<param name="variables">
 The list of collection variables declared by this From operator.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.FromClause(Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax[])">
	<summary>
 Represents a "From" query operator. If this is the beginning of a query, the
 Source will be Nothing. Otherwise, the Source will be the part of the query to
 the left of the From.
 </summary>
	<param name="variables">
 The list of collection variables declared by this From operator.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LetClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax})">
	<summary>
 Represents a "Let" query operator.
 </summary>
	<param name="letKeyword">
 The "Let" keyword.
 </param>
	<param name="variables">
 The list of expression range variable being defined by the Let operator.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LetClause(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax})">
	<summary>
 Represents a "Let" query operator.
 </summary>
	<param name="variables">
 The list of expression range variable being defined by the Let operator.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LetClause(Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax[])">
	<summary>
 Represents a "Let" query operator.
 </summary>
	<param name="variables">
 The list of expression range variable being defined by the Let operator.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AggregateClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryClauseSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax})">
	<summary>
 Represents an Aggregate query operator.
 </summary>
	<param name="aggregateKeyword">
 The "Aggregate" keyword.
 </param>
	<param name="variables">
 The list of collection range variables declared by this Aggregate operator.
 </param>
	<param name="additionalQueryOperators">
 A list of additional query operators. It may be empty.
 </param>
	<param name="intoKeyword">
 The "Into" keyword.
 </param>
	<param name="aggregationVariables">
 The list of new variables being defined by the aggregation.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AggregateClause(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryClauseSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax})">
	<summary>
 Represents an Aggregate query operator.
 </summary>
	<param name="variables">
 The list of collection range variables declared by this Aggregate operator.
 </param>
	<param name="additionalQueryOperators">
 A list of additional query operators. It may be empty.
 </param>
	<param name="aggregationVariables">
 The list of new variables being defined by the aggregation.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AggregateClause(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax})">
	<summary>
 Represents an Aggregate query operator.
 </summary>
	<param name="variables">
 The list of collection range variables declared by this Aggregate operator.
 </param>
	<param name="aggregationVariables">
 The list of new variables being defined by the aggregation.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DistinctClause(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the "Distinct" query operator.
 </summary>
	<param name="distinctKeyword">
 The "Distinct" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DistinctClause">
	<summary>
 Represents the "Distinct" query operator.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.WhereClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "Where" query operator.
 </summary>
	<param name="whereKeyword">
 The "Where" keyword.
 </param>
	<param name="condition">
 The boolean expression used for filtering.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.WhereClause(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "Where" query operator.
 </summary>
	<param name="condition">
 The boolean expression used for filtering.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SkipWhileClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="whileKeyword">
 The "While" keyword.
 </param>
	<param name="condition">
 The boolean expression used for partitioning.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SkipWhileClause(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
	<param name="condition">
 The boolean expression used for partitioning.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TakeWhileClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="whileKeyword">
 The "While" keyword.
 </param>
	<param name="condition">
 The boolean expression used for partitioning.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TakeWhileClause(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
	<param name="condition">
 The boolean expression used for partitioning.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PartitionWhileClause(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 PartitionWhileClauseSyntax. One of SkipWhileClause, TakeWhileClause.
 </param>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="whileKeyword">
 The "While" keyword.
 </param>
	<param name="condition">
 The boolean expression used for partitioning.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PartitionWhileClause(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 PartitionWhileClauseSyntax. One of SkipWhileClause, TakeWhileClause.
 </param>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="condition">
 The boolean expression used for partitioning.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SkipClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SkipClause(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
	<param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TakeClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TakeClause(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
	<param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PartitionClause(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 PartitionClauseSyntax. One of SkipClause, TakeClause.
 </param>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GroupByClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax})">
	<summary>
 Represents the "Group By" query operator.
 </summary>
	<param name="groupKeyword">
 The "Group" keyword.
 </param>
	<param name="items">
 The optional list of variables being grouped; the contents of the Group clause.
 If none were specified, an empty list is returned.
 </param>
	<param name="byKeyword">
 The "By" keyword.
 </param>
	<param name="keys">
 The key values being used for grouping.
 </param>
	<param name="aggregationVariables">
 The list of new variables that calculate aggregations.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GroupByClause(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax})">
	<summary>
 Represents the "Group By" query operator.
 </summary>
	<param name="items">
 The optional list of variables being grouped; the contents of the Group clause.
 If none were specified, an empty list is returned.
 </param>
	<param name="keys">
 The key values being used for grouping.
 </param>
	<param name="aggregationVariables">
 The list of new variables that calculate aggregations.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GroupByClause(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax})">
	<summary>
 Represents the "Group By" query operator.
 </summary>
	<param name="keys">
 The key values being used for grouping.
 </param>
	<param name="aggregationVariables">
 The list of new variables that calculate aggregations.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.JoinClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.JoinClauseSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.JoinConditionSyntax})">
	<summary>
 Represents a Join query operator.
 </summary>
	<param name="joinKeyword">
 The "Join" keyword.
 </param>
	<param name="joinedVariables">
 Defines the collection range variables being joined to.
 </param>
	<param name="additionalJoins">
 An additional Join or Group Join query operator.
 </param>
	<param name="onKeyword">
 The "On" keyword.
 </param>
	<param name="joinConditions">
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.JoinClause(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.JoinClauseSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.JoinConditionSyntax})">
	<summary>
 Represents a Join query operator.
 </summary>
	<param name="joinedVariables">
 Defines the collection range variables being joined to.
 </param>
	<param name="additionalJoins">
 An additional Join or Group Join query operator.
 </param>
	<param name="joinConditions">
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.JoinClause(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.JoinConditionSyntax})">
	<summary>
 Represents a Join query operator.
 </summary>
	<param name="joinedVariables">
 Defines the collection range variables being joined to.
 </param>
	<param name="joinConditions">
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.JoinCondition(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents the "expression Equals expression" condition in a Join.
 </summary>
	<param name="left">
 The left expression in the Join condition.
 </param>
	<param name="equalsKeyword">
 The "Equals" keyword.
 </param>
	<param name="right">
 The right expression in the Join condition.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.JoinCondition(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents the "expression Equals expression" condition in a Join.
 </summary>
	<param name="left">
 The left expression in the Join condition.
 </param>
	<param name="right">
 The right expression in the Join condition.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GroupJoinClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.JoinClauseSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.JoinConditionSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax})">
	<summary>
 Represents the "Group Join" query operator.
 </summary>
	<param name="groupKeyword">
 The "Group" keyword.
 </param>
	<param name="joinKeyword">
 The "Join" keyword.
 </param>
	<param name="joinedVariables">
 Defines the collection range variables being joined to.
 </param>
	<param name="additionalJoins">
 An additional Join or Group Join query operator.
 </param>
	<param name="onKeyword">
 The "On" keyword.
 </param>
	<param name="joinConditions">
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </param>
	<param name="intoKeyword">
 The "Into" keyword.
 </param>
	<param name="aggregationVariables">
 The list of new variables that calculate aggregations.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GroupJoinClause(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.JoinClauseSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.JoinConditionSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax})">
	<summary>
 Represents the "Group Join" query operator.
 </summary>
	<param name="joinedVariables">
 Defines the collection range variables being joined to.
 </param>
	<param name="additionalJoins">
 An additional Join or Group Join query operator.
 </param>
	<param name="joinConditions">
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </param>
	<param name="aggregationVariables">
 The list of new variables that calculate aggregations.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GroupJoinClause(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.JoinConditionSyntax},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax})">
	<summary>
 Represents the "Group Join" query operator.
 </summary>
	<param name="joinedVariables">
 Defines the collection range variables being joined to.
 </param>
	<param name="joinConditions">
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </param>
	<param name="aggregationVariables">
 The list of new variables that calculate aggregations.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OrderByClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.OrderingSyntax})">
	<summary>
 Represents the "Order By" query operator.
 </summary>
	<param name="orderKeyword">
 The "Order" keyword
 </param>
	<param name="byKeyword">
 The "By" keyword.
 </param>
	<param name="orderings">
 The list of OrderExpression's to sort by.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OrderByClause(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.OrderingSyntax})">
	<summary>
 Represents the "Order By" query operator.
 </summary>
	<param name="orderings">
 The list of OrderExpression's to sort by.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.OrderByClause(Roslyn.Compilers.VisualBasic.OrderingSyntax[])">
	<summary>
 Represents the "Order By" query operator.
 </summary>
	<param name="orderings">
 The list of OrderExpression's to sort by.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AscendingOrdering(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
	<param name="expression">
 The expression to sort by.
 </param>
	<param name="ascendingOrDescendingKeyword">
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AscendingOrdering(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
	<param name="expression">
 The expression to sort by.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DescendingOrdering(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
	<param name="expression">
 The expression to sort by.
 </param>
	<param name="ascendingOrDescendingKeyword">
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DescendingOrdering(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
	<param name="expression">
 The expression to sort by.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Ordering(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of OrderingSyntax. One
 of AscendingOrdering, DescendingOrdering.
 </param>
	<param name="expression">
 The expression to sort by.
 </param>
	<param name="ascendingOrDescendingKeyword">
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Ordering(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of OrderingSyntax. One
 of AscendingOrdering, DescendingOrdering.
 </param>
	<param name="expression">
 The expression to sort by.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SelectClause(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax})">
	<summary>
 Represents the "Select" query operator.
 </summary>
	<param name="selectKeyword">
 The "Select" keyword.
 </param>
	<param name="variables">
 The list of expression range variables being defined by the Select query
 operator.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SelectClause(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax})">
	<summary>
 Represents the "Select" query operator.
 </summary>
	<param name="variables">
 The list of expression range variables being defined by the Select query
 operator.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SelectClause(Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax[])">
	<summary>
 Represents the "Select" query operator.
 </summary>
	<param name="variables">
 The list of expression range variables being defined by the Select query
 operator.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlDocument(Roslyn.Compilers.VisualBasic.XmlDeclarationSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax},Roslyn.Compilers.VisualBasic.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax})">
	<summary>
 Represents and XML Document literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlDocument(Roslyn.Compilers.VisualBasic.XmlDeclarationSyntax,Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Represents and XML Document literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlDeclaration(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax,Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax,Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the XML declaration prologue in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlDeclaration(Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax,Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax,Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax)">
	<summary>
 Represents the XML declaration prologue in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlDeclaration(Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax)">
	<summary>
 Represents the XML declaration prologue in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlDeclarationOption(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlStringSyntax)">
	<summary>
 Represents an XML document prologue option - version, encoding, standalone or
 whitespace in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlDeclarationOption(Roslyn.Compilers.VisualBasic.XmlStringSyntax)">
	<summary>
 Represents an XML document prologue option - version, encoding, standalone or
 whitespace in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlElement(Roslyn.Compilers.VisualBasic.XmlElementStartTagSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax},Roslyn.Compilers.VisualBasic.XmlElementEndTagSyntax)">
	<summary>
 Represents an XML element with content in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlElement(Roslyn.Compilers.VisualBasic.XmlElementStartTagSyntax,Roslyn.Compilers.VisualBasic.XmlElementEndTagSyntax)">
	<summary>
 Represents an XML element with content in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlText(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Represents Xml text.
 </summary>
	<param name="textTokens">
 A list of all the text tokens in the Xml text. This list always contains at
 least one token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlText">
	<summary>
 Represents Xml text.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlElementStartTag(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the start tag of an XML element of the form &lt;element&gt;.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlElementStartTag(Roslyn.Compilers.VisualBasic.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax})">
	<summary>
 Represents the start tag of an XML element of the form &lt;element&gt;.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlElementStartTag(Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Represents the start tag of an XML element of the form &lt;element&gt;.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlElementEndTag(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNameSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the end tag of an XML element of the form &lt;/element&gt;.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlElementEndTag(Roslyn.Compilers.VisualBasic.XmlNameSyntax)">
	<summary>
 Represents the end tag of an XML element of the form &lt;/element&gt;.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlElementEndTag">
	<summary>
 Represents the end tag of an XML element of the form &lt;/element&gt;.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlEmptyElement(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an empty XML element of the form &lt;element /&gt;
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlEmptyElement(Roslyn.Compilers.VisualBasic.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax})">
	<summary>
 Represents an empty XML element of the form &lt;element /&gt;
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlEmptyElement(Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Represents an empty XML element of the form &lt;element /&gt;
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlAttribute(Roslyn.Compilers.VisualBasic.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Represents an XML attribute in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlAttribute(Roslyn.Compilers.VisualBasic.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.XmlNodeSyntax)">
	<summary>
 Represents an XML attribute in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlString(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a string of XML characters embedded as the content of an XML
 element.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlString(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a string of XML characters embedded as the content of an XML
 element.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlPrefixName(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an XML name of the form 'name' appearing in GetXmlNamespace().
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlPrefixName">
	<summary>
 Represents an XML name of the form 'name' appearing in GetXmlNamespace().
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlName(Roslyn.Compilers.VisualBasic.XmlPrefixSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an XML name of the form 'name' or 'namespace:name' appearing in
 source as part of an XML literal or member access expression or an XML
 namespace import clause.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlName">
	<summary>
 Represents an XML name of the form 'name' or 'namespace:name' appearing in
 source as part of an XML literal or member access expression or an XML
 namespace import clause.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlBracketedName(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.XmlNameSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an XML name of the form &lt;xml-name&gt; appearing in source as part
 of an XML literal or member access expression or an XML namespace import
 clause.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlBracketedName(Roslyn.Compilers.VisualBasic.XmlNameSyntax)">
	<summary>
 Represents an XML name of the form &lt;xml-name&gt; appearing in source as part
 of an XML literal or member access expression or an XML namespace import
 clause.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlPrefix(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents and XML namespace prefix of the form 'prefix:' as in xml:ns="".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlPrefix">
	<summary>
 Represents and XML namespace prefix of the form 'prefix:' as in xml:ns="".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlComment(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an XML comment of the form &lt;-- Comment --&gt; appearing in an XML
 literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlComment">
	<summary>
 Represents an XML comment of the form &lt;-- Comment --&gt; appearing in an XML
 literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlProcessingInstruction(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an XML processing instruction of the form '&lt;? XMLProcessingTarget
 XMLProcessingValue ?&gt;'.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlProcessingInstruction">
	<summary>
 Represents an XML processing instruction of the form '&lt;? XMLProcessingTarget
 XMLProcessingValue ?&gt;'.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlCDataSection(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an XML CDATA section in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlCDataSection">
	<summary>
 Represents an XML CDATA section in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlEmbeddedExpression(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an embedded expression in an XML literal e.g. '&lt;name&gt;&lt;%=
 obj.Name =%&gt;&lt;/name&gt;'.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlEmbeddedExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents an embedded expression in an XML literal e.g. '&lt;name&gt;&lt;%=
 obj.Name =%&gt;&lt;/name&gt;'.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ArrayType(Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax})">
	<summary>
 Represents an array type, such as "A() or "A(,)", without bounds specified for
 the array.
 </summary>
	<param name="elementType">
 The type of the elements of the array.
 </param>
	<param name="rankSpecifiers">
 Represents the list of "()" or "(,,)" modifiers on the array type.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ArrayType(Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Represents an array type, such as "A() or "A(,)", without bounds specified for
 the array.
 </summary>
	<param name="elementType">
 The type of the elements of the array.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NullableType(Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 A type name that represents a nullable type, such as "Integer?".
 </summary>
	<param name="elementType">
 The kind of type that is this type is a nullable of. Cannot be an array type or
 a nullable type.
 </param>
	<param name="questionMarkToken">
 The "?" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.NullableType(Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 A type name that represents a nullable type, such as "Integer?".
 </summary>
	<param name="elementType">
 The kind of type that is this type is a nullable of. Cannot be an array type or
 a nullable type.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.PredefinedType(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an occurrence of a Visual Basic built-in type such as Integer or
 String in source code.
 </summary>
	<param name="keyword">
 The keyword that was used to describe the built-in type.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IdentifierName(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a type name consisting of a single identifier (which might include
 brackets or a type character).
 </summary>
	<param name="identifier">
 The identifier in the name.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IdentifierName(System.String)">
	<summary>
 Represents a type name consisting of a single identifier (which might include
 brackets or a type character).
 </summary>
	<param name="identifier">
 The identifier in the name.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GenericName(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax)">
	<summary>
 Represents a simple type name with one or more generic arguments, such as "X(Of
 Y, Z).
 </summary>
	<param name="identifier">
 The identifier in the name.
 </param>
	<param name="typeArgumentList">
 The generic argument list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GenericName(System.String,Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax)">
	<summary>
 Represents a simple type name with one or more generic arguments, such as "X(Of
 Y, Z).
 </summary>
	<param name="identifier">
 The identifier in the name.
 </param>
	<param name="typeArgumentList">
 The generic argument list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.QualifiedName(Roslyn.Compilers.VisualBasic.NameSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SimpleNameSyntax)">
	<summary>
 Represents a qualified type name, for example X.Y or X(Of Z).Y.
 </summary>
	<param name="left">
 The part of the name that appears to the left of the dot. This can itself be
 any name.
 </param>
	<param name="dotToken">
 The "." token that separates the names.
 </param>
	<param name="right">
 The part of the name that appears to the right of the dot. This must be a
 simple identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.QualifiedName(Roslyn.Compilers.VisualBasic.NameSyntax,Roslyn.Compilers.VisualBasic.SimpleNameSyntax)">
	<summary>
 Represents a qualified type name, for example X.Y or X(Of Z).Y.
 </summary>
	<param name="left">
 The part of the name that appears to the left of the dot. This can itself be
 any name.
 </param>
	<param name="right">
 The part of the name that appears to the right of the dot. This must be a
 simple identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GlobalName(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a name in the global namespace.
 </summary>
	<param name="globalKeyword">
 The "Global" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GlobalName">
	<summary>
 Represents a name in the global namespace.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeArgumentList(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeSyntax},Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a parenthesized list of generic type arguments.
 </summary>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="ofKeyword">
 The "Of" keyword.
 </param>
	<param name="arguments">
 A list of all the type arguments.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeArgumentList(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeSyntax})">
	<summary>
 Represents a parenthesized list of generic type arguments.
 </summary>
	<param name="arguments">
 A list of all the type arguments.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.TypeArgumentList(Roslyn.Compilers.VisualBasic.TypeSyntax[])">
	<summary>
 Represents a parenthesized list of generic type arguments.
 </summary>
	<param name="arguments">
 A list of all the type arguments.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlNameToken(System.String,Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxTriviaList,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary>
 Represents an Xml NCName per Namespaces in XML 1.0
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlTextLiteralToken(System.String,System.String,Roslyn.Compilers.VisualBasic.SyntaxTriviaList,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlEntityLiteralToken(System.String,System.String,Roslyn.Compilers.VisualBasic.SyntaxTriviaList,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DocumentationCommentLineBreakToken(System.String,System.String,Roslyn.Compilers.VisualBasic.SyntaxTriviaList,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.XmlTextToken(Roslyn.Compilers.VisualBasic.SyntaxKind,System.String,System.String,Roslyn.Compilers.VisualBasic.SyntaxTriviaList,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of XmlTextTokenSyntax.
 One of XmlTextLiteralToken, XmlEntityLiteralToken,
 DocumentationCommentLineBreakToken.
 </param>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DecimalLiteralToken(System.String,Roslyn.Compilers.VisualBasic.TypeCharacter,System.Decimal,Roslyn.Compilers.VisualBasic.SyntaxTriviaList,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary>
 Represents a Decimal literal token.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DateLiteralToken(System.String,System.DateTime,Roslyn.Compilers.VisualBasic.SyntaxTriviaList,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary>
 Represents an Date literal token.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.StringLiteralToken(System.String,System.String,Roslyn.Compilers.VisualBasic.SyntaxTriviaList,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary>
 Represents an string literal token.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CharacterLiteralToken(System.String,System.Char,Roslyn.Compilers.VisualBasic.SyntaxTriviaList,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary>
 Represents an string literal token.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SkippedTokensTrivia(Roslyn.Compilers.VisualBasic.SyntaxTokenList)">
	<summary>
 Represents tokens that were skipped by the parser as part of error recovery,
 and thus are not part of any syntactic structure.
 </summary>
	<param name="tokens">
 The list of tokens that were skipped by the parser.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SkippedTokensTrivia">
	<summary>
 Represents tokens that were skipped by the parser as part of error recovery,
 and thus are not part of any syntactic structure.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DocumentationCommentTrivia(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax})">
	<summary>
 Represents a documentation comment e.g. ''' &lt;Summary&gt; apearing in source.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DocumentationCommentTrivia">
	<summary>
 Represents a documentation comment e.g. ''' &lt;Summary&gt; apearing in source.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DirectiveTrivia(Roslyn.Compilers.VisualBasic.DirectiveStatementSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents a preprocessor directive
 </summary>
	<param name="terminator">
 The statement terminator token that ended the Directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.WhitespaceTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndOfLineTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ColonTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.CommentTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.LineContinuationTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ImplicitLineContinuationTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DocumentationCommentExteriorTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.DisabledTextTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.SyntaxTrivia(Roslyn.Compilers.VisualBasic.SyntaxKind,System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of SyntaxTrivia. One of
 WhitespaceTrivia, EndOfLineTrivia, ColonTrivia, CommentTrivia,
 LineContinuationTrivia, ImplicitLineContinuationTrivia,
 DocumentationCommentExteriorTrivia, DisabledTextTrivia.
 </param>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ConstDirective(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a #Const pre-processing constant declaration appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
	<param name="constKeyword">
 The "Const" keyword.
 </param>
	<param name="name">
 The name of the pre-processing constant being defined.
 </param>
	<param name="equalsToken">
 The "=" token.
 </param>
	<param name="value">
 An expression representing the value of the pre-processing constant being
 defined.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ConstDirective(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a #Const pre-processing constant declaration appearing in source.
 </summary>
	<param name="name">
 The name of the pre-processing constant being defined.
 </param>
	<param name="value">
 An expression representing the value of the pre-processing constant being
 defined.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ConstDirective(System.String,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents a #Const pre-processing constant declaration appearing in source.
 </summary>
	<param name="name">
 The name of the pre-processing constant being defined.
 </param>
	<param name="value">
 An expression representing the value of the pre-processing constant being
 defined.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IfDirective(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.IfDirective(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ElseIfDirective(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ElseIfDirective(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ElseDirective(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an #Else pre-processing directive appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ElseDirective">
	<summary>
 Represents an #Else pre-processing directive appearing in source.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndIfDirective(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an #End If pre-processing directive appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndIfDirective">
	<summary>
 Represents an #End If pre-processing directive appearing in source.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RegionDirective(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the beginning of a #Region directive appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
	<param name="regionKeyword">
 The "Region" keyword.
 </param>
	<param name="name">
 The label of the code region being defined.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.RegionDirective">
	<summary>
 Represents the beginning of a #Region directive appearing in source.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndRegionDirective(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an #End Region directive appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
	<param name="endKeyword">
 The "End" keyword.
 </param>
	<param name="regionKeyword">
 The "Region" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndRegionDirective">
	<summary>
 Represents an #End Region directive appearing in source.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExternalSourceDirective(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents the beginning of a #ExternalSource pre-processing directive
 appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExternalSourceDirective">
	<summary>
 Represents the beginning of a #ExternalSource pre-processing directive
 appearing in source.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndExternalSourceDirective(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an #End ExternalSource pre-processing directive appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.EndExternalSourceDirective">
	<summary>
 Represents an #End ExternalSource pre-processing directive appearing in source.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExternalChecksumDirective(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an #ExternalChecksum pre-processing directive appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ExternalChecksumDirective">
	<summary>
 Represents an #ExternalChecksum pre-processing directive appearing in source.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ReferenceDirective(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an #r directive appearing in scripts.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ReferenceDirective">
	<summary>
 Represents an #r directive appearing in scripts.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.BadDirective(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Represents an unrecognized pre-processing directive. This occurs when the
 parser encounters a hash '#' token at the beginning of a physical line but does
 recognize the text that follows as a valid Visual Basic pre-processing
 directive.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.BadDirective">
	<summary>
 Represents an unrecognized pre-processing directive. This occurs when the
 parser encounters a hash '#' token at the beginning of a physical line but does
 recognize the text that follows as a valid Visual Basic pre-processing
 directive.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EmptyStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 A class to represent an empty statement. This can occur when a colon is on a
 line without anything else.
 </summary>
	<param name="empty">
 An empty token because all non terminals must have a token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndIfStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndUsingStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndWithStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndSelectStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndStructureStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndEnumStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndInterfaceStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndClassStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndModuleStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndNamespaceStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndSubStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndFunctionStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndGetStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndSetStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndPropertyStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndOperatorStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndEventStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndAddHandlerStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndRemoveHandlerStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndRaiseEventStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndWhileStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndTryStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndSyncLockStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndBlockStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an "End XXX" statement, where XXX is a single keyword.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 EndBlockStatementSyntax. One of EndIfStatement, EndUsingStatement,
 EndWithStatement, EndSelectStatement, EndStructureStatement, EndEnumStatement,
 EndInterfaceStatement, EndClassStatement, EndModuleStatement,
 EndNamespaceStatement, EndSubStatement, EndFunctionStatement, EndGetStatement,
 EndSetStatement, EndPropertyStatement, EndOperatorStatement, EndEventStatement,
 EndAddHandlerStatement, EndRemoveHandlerStatement, EndRaiseEventStatement,
 EndWhileStatement, EndTryStatement, EndSyncLockStatement.
 </param>
	<param name="endKeyword">
 The "End" keyword
 </param>
	<param name="blockKeyword">
 The keyword that ends the block. Must be one of: "If", "Using", "With",
 "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
 "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
 "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CompilationUnit(Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.OptionStatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ImportsStatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.AttributesStatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents an entire source file of VB code.
 </summary>
	<param name="options">
 Represents the list of Option statements at the beginning of a source file.
 </param>
	<param name="imports">
 Represents the list of Imports statements at the beginning of a source file.
 </param>
	<param name="attributes">
 Represents the list of AttributeStatements at the beginning of a source file
 that contain the Assembly and Module attributes.
 </param>
	<param name="members">
 Represents the members of the default namespace for this source file: all the
 top-level type and namespace declarations in the file. May also contain
 Statements that are not valid
 </param>
	<param name="endOfFileToken">
 Represents the end of the source file. This token may have trivia (whitespace,
 comments, ...) attached to it.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.OptionStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an Option statement, such as "Option Strict On".
 </summary>
	<param name="optionKeyword">
 The "Option" keyword.
 </param>
	<param name="nameKeyword">
 The keyword that identifies the option being set: Explicit, Strict, Compare or
 Infer.
 </param>
	<param name="valueKeyword">
 The keyword that identifiers the value being set for the opition: On, Off, Text
 or Binary.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ImportsStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ImportsClauseSyntax})">
	<summary>
 Represents an Imports statement, which has one or more imports clauses.
 </summary>
	<param name="importsKeyword">
 The "Imports" keyword.
 </param>
	<param name="importsClauses">
 A list of one or more import clauses. Each clause is either an alias, namespace
 or XML namespace import.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AliasImportsClause(Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.NameSyntax)">
	<summary>
 Represents the clause of an Imports statement that defines an alias for a
 namespace or type.
 </summary>
	<param name="alias">
 The identifier that the alias is being defined for.
 </param>
	<param name="equalsToken">
 The equals sign token.
 </param>
	<param name="name">
 The namespace or type the alias refers to.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MembersImportsClause(Roslyn.Compilers.VisualBasic.InternalSyntax.NameSyntax)">
	<summary>
 Represents the clause of an Imports statement that imports all members of a
 namespace.
 </summary>
	<param name="name">
 The namespace or type being imported.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlNamespaceImportsClause(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlAttributeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Defines a XML namespace for XML expressions.
 </summary>
	<param name="xmlNamespace">
 Identifies the XML namespace alias and URI.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NamespaceBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.NamespaceStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a Namespace statement, its contents and the End Namespace statement.
 </summary>
	<param name="begin">
 The statement that begins the NamespaceBlock.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="members">
 The declarations contained in the namespace statement.
 </param>
	<param name="end">
 The End Namespace statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NamespaceStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.NameSyntax)">
	<summary>
 Represents the beginning statement of a namespace declaration. This node always
 appears as the Begin of a BlockStatement with Kind=NamespaceBlock.
 </summary>
	<param name="namespaceKeyword">
 The "Namespace" keyword.
 </param>
	<param name="name">
 A (possibly dotted) name denoting the namespace being declared.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ModuleBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.TypeStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a declaration of Module, its contents and the End statement that
 ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
	<param name="implements">
 A list of the Implements declarations for the type.
 </param>
	<param name="members">
 The declarations contained in the type or module.
 </param>
	<param name="end">
 The End XXX statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.StructureBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.TypeStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a declaration of a Structure, its contents and the End statement
 that ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
	<param name="implements">
 A list of the Implements declarations for the type.
 </param>
	<param name="members">
 The declarations contained in the type or module.
 </param>
	<param name="end">
 The End XXX statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.InterfaceBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.TypeStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a declaration of a Interface, its contents and the End statement
 that ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
	<param name="implements">
 A list of the Implements declarations for the type.
 </param>
	<param name="members">
 The declarations contained in the type or module.
 </param>
	<param name="end">
 The End XXX statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ClassBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.TypeStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.InheritsStatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsStatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a declaration of a Class its contents and the End statement that
 ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="inherits">
 A list of the Inherits declarations for the type.
 </param>
	<param name="implements">
 A list of the Implements declarations for the type.
 </param>
	<param name="members">
 The declarations contained in the type or module.
 </param>
	<param name="end">
 The End XXX statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EnumBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.EnumStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a declaration of an Enum, its contents and the End Enum statement
 that ends it.
 </summary>
	<param name="begin">
 The statement that begins the type or module.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="members">
 The declarations contained in the enumeration.
 </param>
	<param name="end">
 The End XXX statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.InheritsStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax})">
	<summary>
 Represents an Inherits statement in a Class, Structure or Interface.
 </summary>
	<param name="inheritsKeyword">
 The "Inherits" keyword.
 </param>
	<param name="types">
 A list of the types being inherited.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ImplementsStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax})">
	<summary>
 Represents an Implements statement in a Class or Structure.
 </summary>
	<param name="implementsKeyword">
 The "Implements" keyword.
 </param>
	<param name="types">
 A list of the types being implemented.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ModuleStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax)">
	<summary>
 Represents the beginning statement of a Module declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="keyword">
 The "Module", "Class", "Interface" or "Structure" keyword.
 </param>
	<param name="identifier">
 The name of the type being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.StructureStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax)">
	<summary>
 Represents the beginning statement of a Structure declaration. This node always
 appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="keyword">
 The "Module", "Class", "Interface" or "Structure" keyword.
 </param>
	<param name="identifier">
 The name of the type being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.InterfaceStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax)">
	<summary>
 Represents the beginning statement of a Interface declaration. This node always
 appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="keyword">
 The "Module", "Class", "Interface" or "Structure" keyword.
 </param>
	<param name="identifier">
 The name of the type being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ClassStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax)">
	<summary>
 Represents the beginning statement of a Class declaration. This node always
 appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="keyword">
 The "Module", "Class", "Interface" or "Structure" keyword.
 </param>
	<param name="identifier">
 The name of the type being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic parameters for this type. If no
 generic parameters were present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EnumStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 Represents the beginning statement of an Enum declaration. This node always
 appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="enumKeyword">
 The "Enum" keyword.
 </param>
	<param name="identifier">
 The name of the enum being declared.
 </param>
	<param name="underlyingType">
 Optional "As XXX" clause describing the underlying type of the enumeration. If
 no As clause was specified, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TypeParameterList(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents the type parameter list in a declaration.
 </summary>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="ofKeyword">
 The "Of" keyword.
 </param>
	<param name="parameters">
 A list of the type parameters. There must be at least one type parameter in the
 list.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TypeParameter(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterConstraintClauseSyntax)">
	<summary>
 Represents a type parameter on a generic type declaration.
 </summary>
	<param name="varianceKeyword">
 Represents the "In" or "Out" variance keyword on a type parameter, if present.
 If no variance modifier was present, Nothing is returned.
 </param>
	<param name="identifier">
 The name of the type parameter
 </param>
	<param name="typeParameterConstraintClause">
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TypeParameterSingleConstraintClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ConstraintSyntax)">
	<summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As Constraint".
 </summary>
	<param name="asKeyword">
 The "As" keyword, if any type constraints were supplied. If no type constraints
 were supplied, Nothing is returned.
 </param>
	<param name="constraint">
 A list of the supplied constraints. If no constraints were supplied, Nothing is
 returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TypeParameterMultipleConstraintClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ConstraintSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 One of the type parameter constraints clauses. This represents a constraint
 clause in the form of "As { Constraints }".
 </summary>
	<param name="asKeyword">
 The "As" keyword.
 </param>
	<param name="openBraceToken">
 The "{" token.
 </param>
	<param name="constraints">
 A list of the supplied constraints. If no constraints were supplied, an empty
 list is returned.
 </param>
	<param name="closeBraceToken">
 The "}" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NewConstraint(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
	<param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ClassConstraint(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
	<param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.StructureConstraint(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
	<param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SpecialConstraint(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 One of the special type parameter constraints: New, Class or Structure. Which
 kind of special constraint it is can be obtained from the Kind property and is
 one of: NewConstraint, ReferenceConstraint or ValueConstraint.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 SpecialConstraintSyntax. One of NewConstraint, ClassConstraint,
 StructureConstraint.
 </param>
	<param name="constraintKeyword">
 The "New", "Class" or "Structure" keyword that denotes the kind of special
 constraint.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TypeConstraint(Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax)">
	<summary>
 Represents a type parameter constraint that is a type.
 </summary>
	<param name="type">
 The type describing the constraint.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EnumMemberDeclaration(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.EqualsValueSyntax)">
	<summary>
 Represents a name and value in an EnumDeclarationBlock.
 </summary>
	<param name="initializer">
 An optional value for the enum member.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SubBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.FunctionBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ConstructorBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.OperatorBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.PropertyGetBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.PropertySetBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AddHandlerBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.RemoveHandlerBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.RaiseEventBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MethodBlock(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBaseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a block member declaration: A declaration that has a beginning
 declaration, a body of executable statements and an end statement. Examples
 include methods, constructors, operators, property accessors and custom event
 accessors.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of MethodBlockSyntax.
 One of SubBlock, FunctionBlock, ConstructorBlock, OperatorBlock,
 PropertyGetBlock, PropertySetBlock, AddHandlerBlock, RemoveHandlerBlock,
 RaiseEventBlock.
 </param>
	<param name="begin">
 The declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The End XXX statement that ends the block declaration.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.PropertyBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.PropertyStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBlockSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a block property declaration: A declaration that has a beginning
 declaration, some get or set accessor blocks and an end statement.
 </summary>
	<param name="begin">
 The property declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="accessors">
 The accessor blocks contained in the property, between the Property and the End
 Property statements.
 </param>
	<param name="end">
 The End Property statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EventBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.EventStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.MethodBlockSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a custom event declaration: A declaration that has a beginning event
 declaration, some accessor blocks and an end statement.
 </summary>
	<param name="begin">
 The event declaration that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="accessors">
 The accessor blocks contained in the custom event declaration, between the
 Event statement and the End Event statement.
 </param>
	<param name="end">
 The End Event statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ParameterList(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents the parameter list in a method declaration.
 </summary>
	<param name="openParenToken">
 The "(" token that introduces the parameter list. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="parameters">
 The list of parameters. If no parameter list was present, Nothing is returned.
 </param>
	<param name="closeParenToken">
 The ")" token that concludes the parameter list. If no parameter list was
 present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SubStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.HandlesClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsClauseSyntax)">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
	<param name="handlesClause">
 If present, a Handles clause indicated the events that this method handles.
 </param>
	<param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.FunctionStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.HandlesClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsClauseSyntax)">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
	<param name="handlesClause">
 If present, a Handles clause indicated the events that this method handles.
 </param>
	<param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MethodStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.HandlesClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsClauseSyntax)">
	<summary>
 The statement that declares a Sub or Function. If this method has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 MethodStatementSyntax. One of SubStatement, FunctionStatement.
 </param>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this method.
 If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
	<param name="handlesClause">
 If present, a Handles clause indicated the events that this method handles.
 </param>
	<param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ConstructorStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 A statement that declares a constructor. This statement will be the Begin of a
 BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
 will be the Body of that BlockStatement.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="newKeyword">
 The "New" keyword in the constructor declaration.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DeclareSubStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="declareKeyword">
 The "Declare" keyword.
 </param>
	<param name="charsetKeyword">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="libKeyword">
 The "Lib" keyword.
 </param>
	<param name="libraryName">
 The string literal with the library name.
 </param>
	<param name="aliasKeyword">
 If present, the "Alias" keyword. If not present, returns Nothing.
 </param>
	<param name="aliasName">
 The string literal with the alias. If not present, returns Nothing.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DeclareFunctionStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="declareKeyword">
 The "Declare" keyword.
 </param>
	<param name="charsetKeyword">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="libKeyword">
 The "Lib" keyword.
 </param>
	<param name="libraryName">
 The string literal with the library name.
 </param>
	<param name="aliasKeyword">
 If present, the "Alias" keyword. If not present, returns Nothing.
 </param>
	<param name="aliasName">
 The string literal with the alias. If not present, returns Nothing.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DeclareStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.LiteralExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 A Declare statement that declares an external DLL method.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 DeclareStatementSyntax. One of DeclareSubStatement, DeclareFunctionStatement.
 </param>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="declareKeyword">
 The "Declare" keyword.
 </param>
	<param name="charsetKeyword">
 If present, the keyword that defines the string translation semantics of the
 external method.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the method being declared.
 </param>
	<param name="libKeyword">
 The "Lib" keyword.
 </param>
	<param name="libraryName">
 The string literal with the library name.
 </param>
	<param name="aliasKeyword">
 If present, the "Alias" keyword. If not present, returns Nothing.
 </param>
	<param name="aliasName">
 The string literal with the alias. If not present, returns Nothing.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DelegateSubStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 A statement that declares a delegate type.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="delegateKeyword">
 The "Delegate" keyword.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the delegate being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DelegateFunctionStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 A statement that declares a delegate type.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="delegateKeyword">
 The "Delegate" keyword.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the delegate being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DelegateStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 A statement that declares a delegate type.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 DelegateStatementSyntax. One of DelegateSubStatement,
 DelegateFunctionStatement.
 </param>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="delegateKeyword">
 The "Delegate" keyword.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the delegate being declared.
 </param>
	<param name="typeParameterList">
 If present, a type parameter list with generic type parameters for this
 delegate. If no generic type parameters were present, Nothing is returned.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EventStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsClauseSyntax)">
	<summary>
 A statement that declares an event. If the event being declared is a custom
 event, this statement will be the Begin of a PropertyOrEventBlock, and the
 accessors will be part of the Accessors of that node.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="customKeyword">
 The optional Custom keyword for custom event declarations.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the event being declared.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
	<param name="implementsClause">
 If present, an Implements clause indicates the interface methods that this
 method implements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.OperatorStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 A statement that declares an operator. If this operator has a body, this
 statement will be the Begin of a BlockStatement with
 Kind=MethodDeclarationBlock, and the body of the method will be the Body of
 that BlockStatement.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="operator">
 The operator being defined.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.PropertyStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.EqualsValueSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ImplementsClauseSyntax)">
	<summary>
 Statement that declares a property. If this property has accessors declared,
 this statement will be the Begin of a BlockNode, and the accessors will be the
 Body of that node. Auto properties are property declarations without a
 PropertyBlock.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="identifier">
 The name of the property being declared.
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
	<param name="initializer">
 If present, an "= initial-value" clause describing the initial value of the
 property.
 </param>
	<param name="implementsClause">
 If present, an Implements clause indicated the interface methods that this
 method implements.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.GetAccessorStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SetAccessorStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AddHandlerAccessorStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.RemoveHandlerAccessorStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.RaiseEventHandlerAccessorStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AccessorStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 Represents a Get or Set accessor on a property declaration or an AddHandler,
 RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
 the node determines what kind of accessor this is. This statement is always the
 Begin of a BlockNode, and the body of the accessor is the Body of that node.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 AccessorStatementSyntax. One of GetAccessorStatement, SetAccessorStatement,
 AddHandlerAccessorStatement, RemoveHandlerAccessorStatement,
 RaiseEventHandlerAccessorStatement.
 </param>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ImplementsClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.QualifiedNameSyntax})">
	<summary>
 Represents the "Implements ..." clause on a type member, which describes which
 interface members this member implements.
 </summary>
	<param name="implementsKeyword">
 The "Implements" keyword.
 </param>
	<param name="interfaceMembers">
 The list of interface members being implemented.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.HandlesClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.HandlesClauseItemSyntax})">
	<summary>
 Represents the "Handles ..." clause on a method declaration that describes
 which events this method handles.
 </summary>
	<param name="handlesKeyword">
 The "Handles" keyword.
 </param>
	<param name="events">
 The list of event members being handled.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.KeywordEventContainer(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents event container specified through special keywords "Me", "MyBase" or
 "MyClass"..
 </summary>
	<param name="keyword">
 The container of the event. This can be one of the special keywords: "Me",
 "MyBase" or "MyClass".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.IdentifierEventContainer(Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax)">
	<summary>
 Represents event container that refers to a WithEvents member.
 </summary>
	<param name="identifier">
 The container of the event. It is a simple identifier that refers to a
 WithEvents member of the containing type.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.HandlesClauseItem(Roslyn.Compilers.VisualBasic.InternalSyntax.EventContainerSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierNameSyntax)">
	<summary>
 Represents a single handled event in a "Handles ..." clause.
 </summary>
	<param name="eventContainer">
 The container of the event. This can either be a simple identifier (identifying
 a members of the containing type) or one of the special keywords "Me", "MyBase"
 or "MyClass".
 </param>
	<param name="dotToken">
 The "." token.
 </param>
	<param name="eventMember">
 The event being handled. This must be a simple identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.IncompleteMember(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax)">
	<summary>
 Represents the beginning of a declaration. However, not enough syntax is
 detected to classify this as a field, method, property or event. This is node
 always represents a syntax error.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="missingIdentifier">
 The missing identifier token for this incomplete member. Should only be used to
 have a location for error reporting.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.FieldDeclaration(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.VariableDeclaratorSyntax})">
	<summary>
 Represents the declaration of one or more variables or constants, either as
 local variables or as class/structure members. In the case of a constant, it is
 represented by having "Const" in the Modifiers (although technically "Const" is
 not a modifier, it is represented as one in the parse trees.)
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, an empty list is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned.
 </param>
	<param name="declarators">
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.VariableDeclarator(Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ModifiedIdentifierSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.EqualsValueSyntax)">
	<summary>
 Represents the part of a variable or constant declaration statement that
 associated one or more variable names with a type.
 </summary>
	<param name="names">
 The names of the variables being declared. Each name might have a "?" or "()"
 modifier(s) attached.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type, and possibly includes "New",
 "With" or "From". If no As clause was present, Nothing is returned.
 </param>
	<param name="initializer">
 If present, an "= initial-value" clause describing the initial value of the
 variable or the value of the constant.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SimpleAsClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax)">
	<summary>
 Represents an "As {type-name}" clause that does not have an initializer or
 "New". The type has optional attributes associated with it, although attributes
 are not permitted in all possible places where this node occurs.
 </summary>
	<param name="asKeyword">
 The "As" keyword.
 </param>
	<param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
	<param name="type">
 The type-name part of the As clause.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AsNewClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.NewExpressionSyntax)">
	<summary>
 Represents an "As New {type-name} [arguments] [initializers]" clause in a
 declaration. The type has optional attributes associated with it, although
 attributes are not permitted in many places where this node occurs (they are
 permitted, for example, on automatically implemented properties.)
 </summary>
	<param name="asKeyword">
 The "As" keyword.
 </param>
	<param name="newExpression">
 The New expression
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ObjectMemberInitializer(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.FieldInitializerSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a "With {...} clause used to initialize a new object's members.
 </summary>
	<param name="withKeyword">
 The "With" keyword.
 </param>
	<param name="openBraceToken">
 The "{" token.
 </param>
	<param name="initializers">
 The comma-separated list of field initializers.
 </param>
	<param name="closeBraceToken">
 The "}" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ObjectCollectionInitializer(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionInitializerSyntax)">
	<summary>
 Represents a "From {...} clause used to initialize a new collection object's
 elements.
 </summary>
	<param name="fromKeyword">
 The "From" keyword.
 </param>
	<param name="initializer">
 The initializer including the braces.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.InferredFieldInitializer(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represent a field initializer in a With {...} initializer where the field name
 is inferred from the initializer expression.
 </summary>
	<param name="keyKeyword">
 The optional "Key" keyword.
 </param>
	<param name="expression">
 The value being assigned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NamedFieldInitializer(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierNameSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represent a named field initializer in a With {...} initializer, such as ".x =
 expr".
 </summary>
	<param name="keyKeyword">
 The optional "Key" keyword.
 </param>
	<param name="dotToken">
 The "." token.
 </param>
	<param name="name">
 The name of the field being initialized.
 </param>
	<param name="equalsToken">
 The "=" token.
 </param>
	<param name="expression">
 The value being assigned to the field.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EqualsValue(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an "= initializer" clause in a declaration for a variable,
 pararameter or automatic property.
 </summary>
	<param name="equalsToken">
 The "=" token.
 </param>
	<param name="value">
 The expression used as the initial value.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.Parameter(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.EqualsValueSyntax)">
	<summary>
 Represent a parameter to a method, property, constructor, etc.
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this parameter. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of the modifier tokens "ByVal", "ByRef", "Optional" or "ParamArray" that
 modify this parameter.
 </param>
	<param name="identifier">
 The name of the parameter, including any "?" or "()" modifiers.
 </param>
	<param name="asClause">
 If present, the "As type-name" clause describing the type of the parameter. If
 no As clause is present, Nothing is returned.
 </param>
	<param name="default">
 If present, an initializer with the default value of the parameter. If no
 default value is present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ModifiedIdentifier(Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ArgumentListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode})">
	<summary>
 Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
 used in parameter declarations and variable declarations.
 </summary>
	<param name="identifier">
 The identifier that names the item being declared.
 </param>
	<param name="nullable">
 The "?" token that indicates a nullable type.
 </param>
	<param name="arrayBounds">
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </param>
	<param name="arrayRankSpecifiers">
 A list of array modifiers for the type. If no array modifiers were present, an
 empty list is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ArrayRankSpecifier(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a modifier that describes an array type, without bounds, such as
 "()" or "(,)".
 </summary>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="commaTokens">
 The comma tokens in the array type. There is one less comma than the rank.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AttributeList(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a group of attributes within "&lt;" and "&gt;" brackets.
 </summary>
	<param name="lessThanToken">
 The "&lt;" token.
 </param>
	<param name="attributes">
 A comma separated list of attribute declarations in this attribute list.
 </param>
	<param name="greaterThanToken">
 The "&gt;" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.Attribute(Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeTargetSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ArgumentListSyntax)">
	<summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
	<param name="target">
 Optional attribute target. Assembly|Module :
 </param>
	<param name="name">
 The name of the attribute.
 </param>
	<param name="argumentList">
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AttributeTarget(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a single attribute declaration within an attribute list.
 </summary>
	<param name="attributeModifier">
 The "Assembly" or "Module" attribute modifier, is present. If no attribute
 modifier is present, Nothing is returned.
 </param>
	<param name="colonToken">
 The ":" token, if an attribute modifier is present. If no attribute modifier is
 present, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AttributesStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode})">
	<summary>
 Represents a file-level attribute, in which the attributes have no other
 syntactic element they are attached to.
 </summary>
	<param name="attributeLists">
 The list of attribute lists.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExpressionStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represent an expression in a statement context.
 </summary>
	<param name="questionToken">
 "?" token, if present.
 </param>
	<param name="expression">
 The expression.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.WhileBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.WhileStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a While...End While statement, including the While, body and End
 While.
 </summary>
	<param name="begin">
 The While statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the While...End While. This might be an empty list.
 </param>
	<param name="end">
 The End While statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.UsingBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.UsingStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents an entire Using...End Using statement, including the Using, body and
 End Using statements.
 </summary>
	<param name="begin">
 The UsingStatement that begins the Using...End Using block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the Using...End Using block. This might be an empty
 list.
 </param>
	<param name="end">
 The End Using statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SyncLockBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.SyncLockStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a entire SyncLock...End SyncLock block, including the SyncLock
 statement, the enclosed statements, and the End SyncLock statment.
 </summary>
	<param name="begin">
 The SyncLock statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the SyncLock...End SyncLock statement. This might
 be an empty list.
 </param>
	<param name="end">
 The End SyncLock statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.WithBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.WithStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a With...End With block, include the With statement, the body of the
 block and the End With statement.
 </summary>
	<param name="begin">
 The WithStatement that begins the With...End With block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the With...End With block. This might be an empty
 list.
 </param>
	<param name="end">
 The End With statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.LocalDeclarationStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.VariableDeclaratorSyntax})">
	<summary>
 Represents the declaration of one or more local variables or constants.
 </summary>
	<param name="modifiers">
 The modifier token (Static, Dim or Const) that introduces this local variable
 declaration.
 </param>
	<param name="declarators">
 The list of variable declarator. Each declarator specifies one or more variable
 names along with a type and/or initializer.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.LabelStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents a label statement.
 </summary>
	<param name="labelToken">
 The name of the label. If the label is a line number, returns an IntegerLiteral
 that is the line number, otherwise, returns an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.GoToStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.LabelSyntax)">
	<summary>
 Represents a "GoTo" statement.
 </summary>
	<param name="goToKeyword">
 The "GoTo" keyword.
 </param>
	<param name="label">
 The name of the label. If the label is a line number, wraps an IntegerLiteral
 that is the line number, otherwise, wraps an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.IdentifierLabel(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
	<param name="labelToken">
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NumericLabel(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
	<param name="labelToken">
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NextLabel(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
	<param name="labelToken">
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.Label(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 A label for a GoTo, Resume, or On Error statement. An identifier, line number,
 or next keyword.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of LabelSyntax. One of
 IdentifierLabel, NumericLabel, NextLabel.
 </param>
	<param name="labelToken">
 The label name (identifier), line number (integer literal), or next keyword
 token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.StopStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
	<param name="stopOrEndKeyword">
 The "Stop" or "End" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
	<param name="stopOrEndKeyword">
 The "Stop" or "End" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.StopOrEndStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents a "Stop" or "End" statement. The Kind can be used to determine which
 kind of statement this is.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 StopOrEndStatementSyntax. One of StopStatement, EndStatement.
 </param>
	<param name="stopOrEndKeyword">
 The "Stop" or "End" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExitDoStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExitForStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExitSubStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExitFunctionStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExitOperatorStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExitPropertyStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExitTryStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExitSelectStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExitWhileStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExitStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An exit statement. The kind of block being exited can be found by examining the
 Kind.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of ExitStatementSyntax.
 One of ExitDoStatement, ExitForStatement, ExitSubStatement,
 ExitFunctionStatement, ExitOperatorStatement, ExitPropertyStatement,
 ExitTryStatement, ExitSelectStatement, ExitWhileStatement.
 </param>
	<param name="exitKeyword">
 The "Exit" keyword.
 </param>
	<param name="blockKeyword">
 The keyword describing the block to exit.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ContinueWhileStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
	<param name="continueKeyword">
 The "Continue" keyword.
 </param>
	<param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ContinueDoStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
	<param name="continueKeyword">
 The "Continue" keyword.
 </param>
	<param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ContinueForStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
	<param name="continueKeyword">
 The "Continue" keyword.
 </param>
	<param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ContinueStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents a "Continue (block)" statement. THe kind of block referenced can be
 determined by examining the Kind.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 ContinueStatementSyntax. One of ContinueWhileStatement, ContinueDoStatement,
 ContinueForStatement.
 </param>
	<param name="continueKeyword">
 The "Continue" keyword.
 </param>
	<param name="blockKeyword">
 The "Do", "For" or "While" keyword that identifies the kind of loop being
 continued.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ReturnStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a "Return" statement.
 </summary>
	<param name="returnKeyword">
 The "Return" keyword.
 </param>
	<param name="expression">
 The expression being returned, if present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SingleLineIfStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineIfPartSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SingleLineElsePartSyntax)">
	<summary>
 Represents a line If-Then-Else statement.
 </summary>
	<param name="ifPart">
 The If part of the statement.
 </param>
	<param name="elsePart">
 The Else part of the statement. If there is no Else part, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SingleLineIfPart(Roslyn.Compilers.VisualBasic.InternalSyntax.IfStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax})">
	<summary>
 Represents part of a single line If statement, consisting of a beginning
 if-statement, followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an SingleLineIf.
 </summary>
	<param name="begin">
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </param>
	<param name="statements">
 The statements controlled by this If or Else If. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SingleLineElsePart(Roslyn.Compilers.VisualBasic.InternalSyntax.ElseStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax})">
	<summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
	<param name="begin">
 The Else statement that introduces this part.
 </param>
	<param name="statements">
 The statements controlled by the Else.This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MultiLineIfBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.IfPartSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.ElsePartSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a block If...Then...Else...EndIf Statement. The Kind property can be
 used to determine if it is a block or line If.
 </summary>
	<param name="ifPart">
 The If part of the statement.
 </param>
	<param name="elseIfParts">
 A list of the "ElseIf" parts of the statement. If there are no ElseIf parts,
 then an empty list is returned.
 </param>
	<param name="elsePart">
 The Else part of the statement. If there is no Else part, Nothing is returned.
 </param>
	<param name="end">
 If this is a block if, returns the "End If" statement.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.IfPart(Roslyn.Compilers.VisualBasic.InternalSyntax.IfStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax})">
	<summary>
 Represents part of an If statement, consisting of a beginning statement (If or
 ElseIf), followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an If or ElseIf.
 </summary>
	<param name="begin">
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements controlled by this If or Else If. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ElseIfPart(Roslyn.Compilers.VisualBasic.InternalSyntax.IfStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax})">
	<summary>
 Represents part of an If statement, consisting of a beginning statement (If or
 ElseIf), followed by a body of statement controlled by that beginning
 statement. The Kind property returns if this is an If or ElseIf.
 </summary>
	<param name="begin">
 The statement that introduces this part of the If...Then...Else...End If. This
 must be an IfStatement.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements controlled by this If or Else If. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ElsePart(Roslyn.Compilers.VisualBasic.InternalSyntax.ElseStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax})">
	<summary>
 Represents the Else part of an If statement, consisting of a Else statement,
 followed by a body of statement controlled by that Else.
 </summary>
	<param name="begin">
 The Else statement that introduces this part.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements controlled by the Else. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.IfStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents the If part or ElseIf part of a If...End If block (or line If). This
 statement is always the Begin of a IfPart. The Kind can be examined to
 determine if this is an If or an ElseIf statement.
 </summary>
	<param name="elseKeyword">
 If this ElseIf was written as "Else If", contains the "Else" keyword. Otherwise
 returns Nothing.
 </param>
	<param name="ifOrElseIfKeyword">
 The "If" or "ElseIf" keyword.
 </param>
	<param name="condition">
 The boolean expression that is being tested.
 </param>
	<param name="thenKeyword">
 The "Then" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ElseIfStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents the If part or ElseIf part of a If...End If block (or line If). This
 statement is always the Begin of a IfPart. The Kind can be examined to
 determine if this is an If or an ElseIf statement.
 </summary>
	<param name="elseKeyword">
 If this ElseIf was written as "Else If", contains the "Else" keyword. Otherwise
 returns Nothing.
 </param>
	<param name="ifOrElseIfKeyword">
 The "If" or "ElseIf" keyword.
 </param>
	<param name="condition">
 The boolean expression that is being tested.
 </param>
	<param name="thenKeyword">
 The "Then" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ElseStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents the Else part of a If...End If block (or line If). This statement is
 always the Begin of a ElsePart.
 </summary>
	<param name="elseKeyword">
 The "Else" keyword
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TryBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.TryPartSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.FinallyPartSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents an entire Try...Catch...Finally...End Try statement.
 </summary>
	<param name="tryPart">
 The Try part of the statement.
 </param>
	<param name="catchParts">
 A list of the Catch parts of the statement. If there are no Catch parts, then
 an empty list is returned.
 </param>
	<param name="finallyPart">
 The Finally part of the statement, if present.
 </param>
	<param name="end">
 The "End Try" statement.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TryPart(Roslyn.Compilers.VisualBasic.InternalSyntax.TryStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax})">
	<summary>
 Represents part of an Try...Catch...Finally...End Try statement, consisting of
 a beginning statement (Try, Catch or Finally), followed by a body of statements
 controlled by that beginning statement. The Kind property returns which kind of
 part this is.
 </summary>
	<param name="begin">
 The TryStatement that introduces this part of the Try...Catch...Finally...End
 Try.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements inside the Try part of the Try...Catch...Finally...End Try. This
 might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CatchPart(Roslyn.Compilers.VisualBasic.InternalSyntax.CatchStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax})">
	<summary>
 Represents a Catch part of an Try...Catch...Finally...End Try statement,
 consisting of a Catch statement, followed by a body of statements controlled by
 that Catch statement. The Kind property returns which kind of part this is.
 </summary>
	<param name="begin">
 The CatchStatement that introduces this part.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements controlled by the Catch statement. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.FinallyPart(Roslyn.Compilers.VisualBasic.InternalSyntax.FinallyStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax})">
	<summary>
 Represents the Finally part of an Try...Catch...Finally...End Try statement,
 consisting of a Finally statement, followed by a body of statements controlled
 by the Finally.
 </summary>
	<param name="begin">
 The FinallyStatement that introduces the Finally part of a Try.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements inside the Finally part of the Try...Catch...Finally...End Try.
 This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TryStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents the Try part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a TryPart.
 </summary>
	<param name="tryKeyword">
 The "Try" keyword
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CatchStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierNameSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.CatchFilterClauseSyntax)">
	<summary>
 Represents the Catch part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a CatchPart.
 </summary>
	<param name="catchKeyword">
 The "Catch" keyword.
 </param>
	<param name="identifierName">
 The identifier representing the exception that was caught, if present.
 </param>
	<param name="asClause">
 The As clause that defines the type of exception being caught.
 </param>
	<param name="whenClause">
 The "When" clause, if present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CatchFilterClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents the When/Filter clause of a Catch statement
 </summary>
	<param name="whenKeyword">
 The "When" keyword
 </param>
	<param name="filter">
 The filter expression
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.FinallyStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents the Finally part part of a Try...Catch...Finally...End Try. This
 statement is always the Begin of a FinallyPart.
 </summary>
	<param name="finallyKeyword">
 The "Finally" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ErrorStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents the "Error" statement.
 </summary>
	<param name="errorKeyword">
 The "Error" keyword.
 </param>
	<param name="errorNumber">
 The expression that represents the error number.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.OnErrorGoToZeroStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.LabelSyntax)">
	<summary>
 Represents an OnError Goto statement.
 </summary>
	<param name="onKeyword">
 The "On" keyword
 </param>
	<param name="errorKeyword">
 The "Error" keyword.
 </param>
	<param name="goToKeyword">
 The "GoTo" keyword
 </param>
	<param name="minus">
 An optional minus for On Error Goto -1
 </param>
	<param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.OnErrorGoToMinusOneStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.LabelSyntax)">
	<summary>
 Represents an OnError Goto statement.
 </summary>
	<param name="onKeyword">
 The "On" keyword
 </param>
	<param name="errorKeyword">
 The "Error" keyword.
 </param>
	<param name="goToKeyword">
 The "GoTo" keyword
 </param>
	<param name="minus">
 An optional minus for On Error Goto -1
 </param>
	<param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.OnErrorGoToLabelStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.LabelSyntax)">
	<summary>
 Represents an OnError Goto statement.
 </summary>
	<param name="onKeyword">
 The "On" keyword
 </param>
	<param name="errorKeyword">
 The "Error" keyword.
 </param>
	<param name="goToKeyword">
 The "GoTo" keyword
 </param>
	<param name="minus">
 An optional minus for On Error Goto -1
 </param>
	<param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.OnErrorGoToStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.LabelSyntax)">
	<summary>
 Represents an OnError Goto statement.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 OnErrorGoToStatementSyntax. One of OnErrorGoToZeroStatement,
 OnErrorGoToMinusOneStatement, OnErrorGoToLabelStatement.
 </param>
	<param name="onKeyword">
 The "On" keyword
 </param>
	<param name="errorKeyword">
 The "Error" keyword.
 </param>
	<param name="goToKeyword">
 The "GoTo" keyword
 </param>
	<param name="minus">
 An optional minus for On Error Goto -1
 </param>
	<param name="label">
 The name of the label. If the label is a line number, 0 or -1, wraps an
 IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.OnErrorResumeNextStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an OnError Resume Next statement.
 </summary>
	<param name="onKeyword">
 The "On" keyword
 </param>
	<param name="errorKeyword">
 The "Error" keyword.
 </param>
	<param name="resumeKeyword">
 The "Resume" keyword.
 </param>
	<param name="nextKeyword">
 The "Next"
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ResumeStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.LabelSyntax)">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
	<param name="resumeKeyword">
 The "Resume" keyword.
 </param>
	<param name="label">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ResumeLabelStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.LabelSyntax)">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
	<param name="resumeKeyword">
 The "Resume" keyword.
 </param>
	<param name="label">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ResumeNextStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.LabelSyntax)">
	<summary>
 Represents a "Resume" statement. The Kind property can be used to determine if
 this is a "Resume", "Resume Next" or "Resume label" statement.
 </summary>
	<param name="resumeKeyword">
 The "Resume" keyword.
 </param>
	<param name="label">
 The label. The value of this depends on the Kind. If Kind=Resume, returns
 Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
 wraps an Identifier or IntegerLiteralToken with the label or line number.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SelectBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.SelectStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a Select Case block, including the Select Case that begins it, the
 contains Case blocks and the End Select.
 </summary>
	<param name="begin">
 The Select Case statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="caseBlocks">
 A list of the contained Case blocks.
 </param>
	<param name="end">
 The End Select statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SelectStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a Select Case statement. This statement always occurs as the Begin
 of a SelectBlock.
 </summary>
	<param name="selectKeyword">
 The "Select" keyword.
 </param>
	<param name="caseKeyword">
 The "Case" keyword, if present.
 </param>
	<param name="expression">
 The value that branching is based on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.CaseStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax})">
	<summary>
 Represents a case statement and its subsequent block.
 </summary>
	<param name="begin">
 The statement that begins the case block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the case block. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseElseBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.CaseStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax})">
	<summary>
 Represents a case statement and its subsequent block.
 </summary>
	<param name="begin">
 The statement that begins the case block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the case block. This might be an empty list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.CaseClauseSyntax})">
	<summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
	<param name="caseKeyword">
 The "Case" keyword
 </param>
	<param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a CaseElseClause.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseElseStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.CaseClauseSyntax})">
	<summary>
 Represents a Case or Case Else statement. This statement is always the Begin of
 a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
 Kind=Case.
 </summary>
	<param name="caseKeyword">
 The "Case" keyword
 </param>
	<param name="cases">
 A list of clauses associated with this Case. If Kind=CaseElse, then this list
 has exactly one child, which is a CaseElseClause.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseElseClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 The "Else" part in a Case Else statement.
 </summary>
	<param name="elseKeyword">
 The "Else" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseValueClause(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a single value in a Case.
 </summary>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseRangeClause(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a range "expression To expression" in a Case.
 </summary>
	<param name="lowerBound">
 The lower bound of the range.
 </param>
	<param name="toKeyword">
 The "To" keyword
 </param>
	<param name="upperBound">
 The upper bound of the range.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseEqualsClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
	<param name="isKeyword">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseNotEqualsClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
	<param name="isKeyword">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseLessThanClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
	<param name="isKeyword">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseLessThanOrEqualClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
	<param name="isKeyword">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseGreaterThanOrEqualClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
	<param name="isKeyword">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseGreaterThanClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
	<param name="isKeyword">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CaseRelationalClause(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a relation clause in a Case statement, such as "Is &gt; expression".
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 CaseRelationalClauseSyntax. One of CaseEqualsClause, CaseNotEqualsClause,
 CaseLessThanClause, CaseLessThanOrEqualClause, CaseGreaterThanOrEqualClause,
 CaseGreaterThanClause.
 </param>
	<param name="isKeyword">
 The "Is" keyword, if present.
 </param>
	<param name="operatorToken">
 The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
 "&gt;=".
 </param>
	<param name="value">
 The expression that denotes the value being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SyncLockStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents the "SyncLock" statement. This statement always occurs as the Begin
 of a SyncLockBlock.
 </summary>
	<param name="syncLockKeyword">
 The "SyncLock" keyword.
 </param>
	<param name="expression">
 The expression being synchronized on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DoLoopTopTestBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.DoStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.LoopStatementSyntax)">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
	<param name="begin">
 The Do statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The Loop statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DoLoopBottomTestBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.DoStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.LoopStatementSyntax)">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
	<param name="begin">
 The Do statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The Loop statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DoLoopForeverBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.DoStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.LoopStatementSyntax)">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
	<param name="begin">
 The Do statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The Loop statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DoLoopBlock(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.DoStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.LoopStatementSyntax)">
	<summary>
 Represents a Do-Loop block. The Kind property can be used to determine if this
 is a top-test, bottom-test or infinite loop.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of DoLoopBlockSyntax.
 One of DoLoopTopTestBlock, DoLoopBottomTestBlock, DoLoopForeverBlock.
 </param>
	<param name="begin">
 The Do statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the block statement. This might be an empty list.
 </param>
	<param name="end">
 The Loop statement that ends the block.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DoStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.WhileUntilClauseSyntax)">
	<summary>
 The Do statement that begins a Do-Loop block. This statement always occurs as
 the Begin of a DoLoopBlock.
 </summary>
	<param name="doKeyword">
 The "Do" keyword.
 </param>
	<param name="whileUntilClause">
 The "While expression" or "Until expression" part of the Do statement, if
 present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.LoopStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.WhileUntilClauseSyntax)">
	<summary>
 The Loop statement that ends a Do-Loop block. This statement always occurs as
 the End of a DoLoopBlock.
 </summary>
	<param name="loopKeyword">
 The "Loop" keyword.
 </param>
	<param name="whileUntilClause">
 The "While expression" or "Until expression" part of the Loop statement, if
 present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.WhileClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
	<param name="whileOrUntilKeyword">
 The "While" or "Until" keyword.
 </param>
	<param name="condition">
 The boolean expression after the While or Until.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.UntilClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
	<param name="whileOrUntilKeyword">
 The "While" or "Until" keyword.
 </param>
	<param name="condition">
 The boolean expression after the While or Until.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.WhileUntilClause(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a "While expression" or "Until expression" in a Do or Loop
 statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
 indicate which kind of clause.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 WhileUntilClauseSyntax. One of WhileClause, UntilClause.
 </param>
	<param name="whileOrUntilKeyword">
 The "While" or "Until" keyword.
 </param>
	<param name="condition">
 The boolean expression after the While or Until.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.WhileStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 The While statement that begins a While...End While block. This statement
 always occurs as the Begin of a WhileBlock.
 </summary>
	<param name="whileKeyword">
 The "While" keyword.
 </param>
	<param name="condition">
 The boolean expression that controls the While loop.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ForBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.NextStatementSyntax)">
	<summary>
 Represents a For or For Each block, including the introducting statement, the
 body and the "Next" (which can be omitted if a containing For has a Next with
 multiple variables).
 </summary>
	<param name="begin">
 The For or For Each statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the For or For Each loop. This might be an empty
 list.
 </param>
	<param name="end">
 The Next statement that ends the block. If two For statements are ended by a
 single Next statement, the inner For will not have an EndStatment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ForEachBlock(Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.NextStatementSyntax)">
	<summary>
 Represents a For or For Each block, including the introducting statement, the
 body and the "Next" (which can be omitted if a containing For has a Next with
 multiple variables).
 </summary>
	<param name="begin">
 The For or For Each statement that begins the block.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement.
 </param>
	<param name="statements">
 The statements contained in the For or For Each loop. This might be an empty
 list.
 </param>
	<param name="end">
 The Next statement that ends the block. If two For statements are ended by a
 single Next statement, the inner For will not have an EndStatment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ForStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ForStepClauseSyntax)">
	<summary>
 The For statement that begins a For-Next block. This statement always occurs as
 the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
	<param name="forKeyword">
 The "For" keyword.
 </param>
	<param name="controlVariable">
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </param>
	<param name="equalsToken">
 The "=" token.
 </param>
	<param name="fromValue">
 The expression denoting the initial value of the iteration.
 </param>
	<param name="toKeyword">
 The "To" keyword.
 </param>
	<param name="toValue">
 The expression denoting the final value of the iteration.
 </param>
	<param name="stepClause">
 The optional Step clause.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ForStepClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 The Step clause in a For Statement.
 </summary>
	<param name="stepKeyword">
 The "Step" keyword.
 </param>
	<param name="stepValue">
 The expression denoting the step increment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ForEachStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 The For Each statement that begins a For Each-Next block. This statement always
 occurs as the Begin of a ForBlock, and the body of the For Each-Next is the
 Body of that ForBlock. Most of the time, the End of that ForBlock is the
 corresponding Next statement. However, multiple nested For statements are ended
 by a single Next statement with multiple variables, then the inner For
 statements will have End set to Nothing, and the Next statement is the End of
 the outermost For statement that is being ended.
 </summary>
	<param name="forKeyword">
 The "For" keyword.
 </param>
	<param name="eachKeyword">
 The "Each" keyword.
 </param>
	<param name="controlVariable">
 If the For or For Each statement is of a form that does not declare a new loop
 control variable, this is the expression that denotes the loop control
 variable. If this loop is of a form that does declare a new control variable,
 this is a VariableDeclarator that has the variable being declared.
 </param>
	<param name="inKeyword">
 The "In" keyword.
 </param>
	<param name="expression">
 The expression denoting the collection to iterate over.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NextStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax})">
	<summary>
 The Next statement that ends a For-Next or For Each-Next block. This statement
 always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
 and the body of the For-Next is the Body of that ForBlock. The Begin of that
 ForBlock has the corresponding For or For Each statement.
 </summary>
	<param name="nextKeyword">
 The "Next" keyword.
 </param>
	<param name="controlVariables">
 The variables in the Next statement, if present
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.UsingStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.VariableDeclaratorSyntax})">
	<summary>
 The Using statement that begins a Using block. This statement always occurs as
 the Begin of a UsingBlock, and the body of the Using is the Body of that
 UsingBlock.
 </summary>
	<param name="usingKeyword">
 The "Using" keyword.
 </param>
	<param name="expression">
 If the Using statement is of a form that does not declare a new variable, this
 is the expression used in the using. Otherwise, Nothing is returned.
 </param>
	<param name="variables">
 If the Using statement is of a form that declares one or more new variables,
 this is the list of variable declarations. Otherwise, Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ThrowStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a Throw statement.
 </summary>
	<param name="throwKeyword">
 The "Throw" keyword
 </param>
	<param name="expression">
 The expression denoting the value being thrown.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AssignmentStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MidAssignment(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AddAssignment(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SubtractAssignment(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MultiplyAssignment(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DivideAssignment(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.IntegerDivideAssignment(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.PowerAssignment(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.LeftShiftAssignment(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.RightShiftAssignment(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ConcatenateAssignment(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an assignment or compound assignment statement. Which one can be
 determined by checking the Kind.
 </summary>
	<param name="left">
 The target (left hand side) of the assignment.
 </param>
	<param name="operatorToken">
 The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
 "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
 </param>
	<param name="right">
 The source (right hand side) of the assignment.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CallStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represent an call statement (also known as a invocation statement).
 </summary>
	<param name="callKeyword">
 The "Call" keyword, if present.
 </param>
	<param name="invocation">
 The expression denoting the call. This could be an Invocation or a MemberAccess
 (in the case where no parentheses were supplied.)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AddHandlerStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
	<param name="addHandlerOrRemoveHandlerKeyword">
 The "AddHandler" or "RemoveHandler" keyword.
 </param>
	<param name="eventExpression">
 The event being accessed.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.RemoveHandlerStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
	<param name="addHandlerOrRemoveHandlerKeyword">
 The "AddHandler" or "RemoveHandler" keyword.
 </param>
	<param name="eventExpression">
 The event being accessed.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AddRemoveHandlerStatement(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents an AddHandler or RemoveHandler statement. The Kind property
 determines which one.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 AddRemoveHandlerStatementSyntax. One of AddHandlerStatement,
 RemoveHandlerStatement.
 </param>
	<param name="addHandlerOrRemoveHandlerKeyword">
 The "AddHandler" or "RemoveHandler" keyword.
 </param>
	<param name="eventExpression">
 The event being accessed.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="delegateExpression">
 The delegate being added or removed.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.RaiseEventStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierNameSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ArgumentListSyntax)">
	<summary>
 Represent a RaiseEvent statement.
 </summary>
	<param name="raiseEventKeyword">
 The "RaiseEvent" keyword
 </param>
	<param name="name">
 The name of the event being raised.
 </param>
	<param name="argumentList">
 The argument list, if present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.WithStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a "With" statement. This statement always occurs as the
 BeginStatement of a WithBlock, and the body of the With is the Body of that
 WithBlock.
 </summary>
	<param name="withKeyword">
 The "With" keyword.
 </param>
	<param name="expression">
 The expression that is the operand of the With statement.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ReDimStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.InvocationExpressionSyntax})">
	<summary>
 Represents a ReDim statement.
 </summary>
	<param name="reDimKeyword">
 The "ReDim" keyword.
 </param>
	<param name="preserveKeyword">
 Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
 Kind=RedimPreserve.
 </param>
	<param name="clauses">
 The list of ReDim clauses. Each clause is a Invocation node with an argument
 list denoting the new bounds for the array.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ReDimPreserveStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.InvocationExpressionSyntax})">
	<summary>
 Represents a ReDim statement.
 </summary>
	<param name="reDimKeyword">
 The "ReDim" keyword.
 </param>
	<param name="preserveKeyword">
 Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
 Kind=RedimPreserve.
 </param>
	<param name="clauses">
 The list of ReDim clauses. Each clause is a Invocation node with an argument
 list denoting the new bounds for the array.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EraseStatement(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax})">
	<summary>
 Represents an "Erase" statement.
 </summary>
	<param name="eraseKeyword">
 The "Erase" keyword.
 </param>
	<param name="expressions">
 A list of expressions denoting the arrays to erase.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CharacterLiteralExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TrueLiteralExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.FalseLiteralExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NumericLiteralExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DateLiteralExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.StringLiteralExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NothingLiteralExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.LiteralExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken)">
	<summary>
 Represents a literal. The kind of literal is determined by the Kind property:
 IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
 FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
 determined by casting the associated Token to the correct type and getting the
 value from the token.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 LiteralExpressionSyntax. One of CharacterLiteralExpression,
 TrueLiteralExpression, FalseLiteralExpression, NumericLiteralExpression,
 DateLiteralExpression, StringLiteralExpression, NothingLiteralExpression.
 </param>
	<param name="token">
 The token that represents the literal. The Kind property determines what type
 this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
 Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
 ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
 FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
 Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
 Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
 Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
 NothingKeyword)
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ParenthesizedExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a parenthesized expression.
 </summary>
	<param name="openParenToken">
 The "(" token
 </param>
	<param name="expression">
 The expression inside the parentheses.
 </param>
	<param name="closeParenToken">
 The ")" token
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MeExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Identifies the special instance "Me"
 </summary>
	<param name="keyword">
 The "Me", "MyClass" or "MyBase" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MyBaseExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Identifies the special instance "MyBase"
 </summary>
	<param name="keyword">
 The "Me", "MyClass" or "MyBase" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MyClassExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Identifies the special instance "MyClass"
 </summary>
	<param name="keyword">
 The "Me", "MyClass" or "MyBase" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.GetTypeExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a GetType expression.
 </summary>
	<param name="getTypeKeyword">
 The "GetType" keyword.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="type">
 The type to get the Type object for. This can be an open generic type.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TypeOfIsExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax)">
	<summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
	<param name="typeOfKeyword">
 The "TypeOf" keyword.
 </param>
	<param name="expression">
 The expression being tested.
 </param>
	<param name="operatorToken">
 The "Is" or "IsNot" keyword.
 </param>
	<param name="type">
 The name of the type being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TypeOfIsNotExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax)">
	<summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
	<param name="typeOfKeyword">
 The "TypeOf" keyword.
 </param>
	<param name="expression">
 The expression being tested.
 </param>
	<param name="operatorToken">
 The "Is" or "IsNot" keyword.
 </param>
	<param name="type">
 The name of the type being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TypeOfExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax)">
	<summary>
 Represents a TypeOf...Is or IsNot expression.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 TypeOfExpressionSyntax. One of TypeOfIsExpression, TypeOfIsNotExpression.
 </param>
	<param name="typeOfKeyword">
 The "TypeOf" keyword.
 </param>
	<param name="expression">
 The expression being tested.
 </param>
	<param name="operatorToken">
 The "Is" or "IsNot" keyword.
 </param>
	<param name="type">
 The name of the type being tested against.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.GetXmlNamespaceExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlPrefixNameSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a GetXmlNamespace expression.
 </summary>
	<param name="getXmlNamespaceKeyword">
 The "GetXmlNamespace" keyword.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="name">
 The Xml namespace name being referenced.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MemberAccessExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleNameSyntax)">
	<summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
	<param name="expression">
 The expression on the left-hand-side of the "." or "!" token.
 </param>
	<param name="operatorToken">
 The "." or "!" token.
 </param>
	<param name="name">
 The identifier after the "." or "!" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DictionaryAccessExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleNameSyntax)">
	<summary>
 Represents member access (.name) or dictionary access (!name). The Kind
 property determines which kind of access.
 </summary>
	<param name="expression">
 The expression on the left-hand-side of the "." or "!" token.
 </param>
	<param name="operatorToken">
 The "." or "!" token.
 </param>
	<param name="name">
 The identifier after the "." or "!" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlElementAccessExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNodeSyntax)">
	<summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
	<param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
	<param name="token1">
 The initial dot "." part of the separator.
 </param>
	<param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
	<param name="token3">
 The third "." in a "..." separator.
 </param>
	<param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlDescendantAccessExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNodeSyntax)">
	<summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
	<param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
	<param name="token1">
 The initial dot "." part of the separator.
 </param>
	<param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
	<param name="token3">
 The third "." in a "..." separator.
 </param>
	<param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlAttributeAccessExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNodeSyntax)">
	<summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
	<param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
	<param name="token1">
 The initial dot "." part of the separator.
 </param>
	<param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
	<param name="token3">
 The third "." in a "..." separator.
 </param>
	<param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlMemberAccessExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNodeSyntax)">
	<summary>
 Represents an XML member element access (node.&lt;Element&gt;), attribute
 access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
 Kind property determines which kind of access.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 XmlMemberAccessExpressionSyntax. One of XmlElementAccessExpression,
 XmlDescendantAccessExpression, XmlAttributeAccessExpression.
 </param>
	<param name="base">
 The expression on the left-hand-side of the ".", ".@" or "..." .
 </param>
	<param name="token1">
 The initial dot "." part of the separator.
 </param>
	<param name="token2">
 The "@" part of .@ or the second "." of "...".
 </param>
	<param name="token3">
 The third "." in a "..." separator.
 </param>
	<param name="name">
 The identifier after the ".", ".@" or "..."
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.InvocationExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ArgumentListSyntax)">
	<summary>
 Represents an invocation expression consisting of an invocation target and an
 optional argument list or an array, parameterized property or object default
 property index.
 </summary>
	<param name="expression">
 The target of the call or index expression.
 </param>
	<param name="argumentList">
 The argument list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ObjectCreationExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ArgumentListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectCreationInitializerSyntax)">
	<summary>
 Represents a New expression that creates a new non-array object, possibly with
 a "With" or "From" clause.
 </summary>
	<param name="newKeyword">
 The "New" keyword.
 </param>
	<param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
	<param name="type">
 The type of the object being initialized.
 </param>
	<param name="argumentList">
 The argument list, if present. If no argument list was supplied, Nothing is
 returned.
 </param>
	<param name="initializer">
 An optional From or With clause to initialize the new object.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AnonymousObjectCreationExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.ObjectMemberInitializerSyntax)">
	<summary>
 Represents a New expression that create an object of anonymous type.
 </summary>
	<param name="newKeyword">
 The "New" keyword.
 </param>
	<param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
	<param name="initializer">
 The With clause to initialize the new object.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ArrayCreationExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ArgumentListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionInitializerSyntax)">
	<summary>
 Represents an expression that creates a new array.
 </summary>
	<param name="newKeyword">
 The "New" keyword.
 </param>
	<param name="attributeLists">
 A list of all attribute lists on the type. If no attributes were specified, an
 empty list is returned.
 </param>
	<param name="type">
 The element type of the array being created.
 </param>
	<param name="arrayBounds">
 The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
 </param>
	<param name="rankSpecifiers">
 A list of array modifiers such as "()" or "(,)". If no array modifiers were
 present, an empty list is returned.
 </param>
	<param name="initializer">
 The initializer including the braces.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CollectionInitializer(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents an expression that creates a new array without naming the element
 type.
 </summary>
	<param name="openBraceToken">
 The "{" token.
 </param>
	<param name="initializers">
 The list of initializers between the braces.
 </param>
	<param name="closeBraceToken">
 The "}" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CTypeExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<param name="keyword">
 The "CType", "DirectCast" or "TryCast" keyword.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="expression">
 The expression being cast.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="type">
 The type the expression is being cast to.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DirectCastExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<param name="keyword">
 The "CType", "DirectCast" or "TryCast" keyword.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="expression">
 The expression being cast.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="type">
 The type the expression is being cast to.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TryCastExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<param name="keyword">
 The "CType", "DirectCast" or "TryCast" keyword.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="expression">
 The expression being cast.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="type">
 The type the expression is being cast to.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.PredefinedCastExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a cast to a pre-defined type using a pre-defined cast expression,
 such as CInt or CLng.
 </summary>
	<param name="keyword">
 The keyword that was used in the cast operation.
 </param>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="expression">
 The expression being cast.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AddExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SubtractExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MultiplyExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DivideExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.IntegerDivideExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.PowerExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.LeftShiftExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.RightShiftExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ConcatenateExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ModuloExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EqualsExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NotEqualsExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.LessThanExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.LessThanOrEqualExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.GreaterThanOrEqualExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.GreaterThanExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.IsExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.IsNotExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.LikeExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.OrExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XorExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AndExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.OrElseExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AndAlsoExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.BinaryExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a binary operator. The Kind property classifies the operators into
 similar kind of operators (arithmetic, relational, logical or string); the
 exact operation being performed is determined by the Operator property.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 BinaryExpressionSyntax. One of AddExpression, SubtractExpression,
 MultiplyExpression, DivideExpression, IntegerDivideExpression, PowerExpression,
 LeftShiftExpression, RightShiftExpression, ConcatenateExpression,
 ModuloExpression, EqualsExpression, NotEqualsExpression, LessThanExpression,
 LessThanOrEqualExpression, GreaterThanOrEqualExpression, GreaterThanExpression,
 IsExpression, IsNotExpression, LikeExpression, OrExpression, XorExpression,
 AndExpression, OrElseExpression, AndAlsoExpression.
 </param>
	<param name="left">
 The left operand.
 </param>
	<param name="right">
 The right operand.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.PlusExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
	<param name="operatorToken">
 The token that is the operator.
 </param>
	<param name="operand">
 The expression being operated on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NegateExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
	<param name="operatorToken">
 The token that is the operator.
 </param>
	<param name="operand">
 The expression being operated on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NotExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
	<param name="operatorToken">
 The token that is the operator.
 </param>
	<param name="operand">
 The expression being operated on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AddressOfExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
	<param name="operatorToken">
 The token that is the operator.
 </param>
	<param name="operand">
 The expression being operated on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.UnaryExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Describes a unary operator: Plus, Negate, Not or AddressOf.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 UnaryExpressionSyntax. One of PlusExpression, NegateExpression, NotExpression,
 AddressOfExpression.
 </param>
	<param name="operatorToken">
 The token that is the operator.
 </param>
	<param name="operand">
 The expression being operated on.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.BinaryConditionalExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
	<param name="ifKeyword">
 The "If" keyword
 </param>
	<param name="openParenToken">
 The "(" token
 </param>
	<param name="firstExpression">
 The first expression inside the parentheses.
 </param>
	<param name="commaToken">
 The "," token.
 </param>
	<param name="secondExpression">
 The second expression inside the parentheses.
 </param>
	<param name="closeParenToken">
 The ")" token
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TernaryConditionalExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a conditional expression, If(condition, true-expr, false-expr) or
 If(expr, nothing-expr).
 </summary>
	<param name="ifKeyword">
 The "If" keyword
 </param>
	<param name="openParenToken">
 The "(" token
 </param>
	<param name="condition">
 The first expression inside the parentheses.
 </param>
	<param name="firstCommaToken">
 The "," token.
 </param>
	<param name="whenTrue">
 The second expression inside the parentheses.
 </param>
	<param name="secondCommaToken">
 The "," token.
 </param>
	<param name="whenFalse">
 The second expression inside the parentheses.
 </param>
	<param name="closeParenToken">
 The ")" token
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SingleLineFunctionLambdaExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Represents a single line lambda expression.
 </summary>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </param>
	<param name="body">
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SingleLineSubLambdaExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Represents a single line lambda expression.
 </summary>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </param>
	<param name="body">
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SingleLineLambdaExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Represents a single line lambda expression.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 SingleLineLambdaExpressionSyntax. One of SingleLineFunctionLambdaExpression,
 SingleLineSubLambdaExpression.
 </param>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </param>
	<param name="body">
 The body of the lambda. Depending on the kind of lambda, this is either a
 Statement (single-line Sub lambda) or Expression (single-line Function).
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MultiLineFunctionLambdaExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a multi-line lambda expression.
 </summary>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </param>
	<param name="statements">
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </param>
	<param name="end">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MultiLineSubLambdaExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a multi-line lambda expression.
 </summary>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </param>
	<param name="statements">
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </param>
	<param name="end">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MultiLineLambdaExpression(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.LambdaHeaderSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.StatementSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.EndBlockStatementSyntax)">
	<summary>
 Represents a multi-line lambda expression.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 MultiLineLambdaExpressionSyntax. One of MultiLineFunctionLambdaExpression,
 MultiLineSubLambdaExpression.
 </param>
	<param name="begin">
 The header part of the lambda that includes the "Sub" or "Function" keyword,
 the argument list and return type.
 </param>
	<param name="beginTerminator">
 The statement terminator token that ended the Begin statement. Optional only
 for single line lambdas.
 </param>
	<param name="statements">
 The body of the lambda. Depending on the kind of lambda, this is either a
 StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
 Expression (single-line Function). This might be an empty list.
 </param>
	<param name="end">
 Returns the "End Sub" or "End Function" statement if this is a multi-line
 lambda.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SubLambdaHeader(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 Represents the header part of a lambda expression
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.FunctionLambdaHeader(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 Represents the header part of a lambda expression
 </summary>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.LambdaHeader(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ParameterListSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AsClauseSyntax)">
	<summary>
 Represents the header part of a lambda expression
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of LambdaHeaderSyntax.
 One of SubLambdaHeader, FunctionLambdaHeader.
 </param>
	<param name="attributeLists">
 A list of all attribute lists on this declaration. If no attributes were
 specified, Nothing is returned.
 </param>
	<param name="modifiers">
 A list of all the modifier tokens that were present on this declaration. If no
 modifiers were specified, an empty list is returned. A bitfield version of all
 the modifiers ORed together, which is in many cases easier to use, can be
 obtained with the Modifiers property.
 </param>
	<param name="keyword">
 The keyword that introduces this method declaration. One of "Sub", "Function",
 "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
 "RaiseEvent".
 </param>
	<param name="parameterList">
 The method's parameter list including the parentheses. If no parameter list was
 present, Nothing is returned.
 </param>
	<param name="asClause">
 The "As" clause that describes the return type. If no As clause was present,
 Nothing is returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ArgumentList(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ArgumentSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a parenthesized argument list.
 </summary>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="arguments">
 The list of arguments. This may be empty. Ommitted argument are represented by
 an OmittedArgumentSyntax node.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.OmittedArgument(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents an omitted argument in an argument list. An omitted argument is not
 considered a syntax error but a valid case when no argument is required.
 </summary>
	<param name="empty">
 An empty token because all non terminals must have a token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SimpleArgument(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a simple argument that is just an expression.
 </summary>
	<param name="expression">
 The expression that is the argument.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NamedArgument(Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierNameSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a named argument, such as "Value:=7".
 </summary>
	<param name="identifierName">
 The name used to identify the named argument.
 </param>
	<param name="colonEqualsToken">
 The ":=" token.
 </param>
	<param name="expression">
 The expression that is the named argument.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.RangeArgument(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a range argument, such as "0 to 5", used in array bounds. The
 "Value" property represents the upper bound of the range.
 </summary>
	<param name="lowerBound">
 The lower bound of the range. This is typically the integer constant zero.
 </param>
	<param name="toKeyword">
 The "To" keyword.
 </param>
	<param name="upperBound">
 The upper bound of the range.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.QueryExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode})">
	<summary>
 This class represents a query expression. A query expression is composed of one
 or more query operators in a row. The first query operator must be a From or
 Aggregate.
 </summary>
	<param name="clauses">
 A list of all the query operators in this query expression. This list always
 contains at least one operator.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CollectionRangeVariable(Roslyn.Compilers.VisualBasic.InternalSyntax.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Describes a single variable of the form "x [As Type] In expression" for use in
 query expressions.
 </summary>
	<param name="identifier">
 The name of the range variable being defined.
 </param>
	<param name="asClause">
 Describes the type of the variable being defined.
 </param>
	<param name="inKeyword">
 The "In" keyword.
 </param>
	<param name="expression">
 The expression that serves as the source of items for the range variable.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExpressionRangeVariable(Roslyn.Compilers.VisualBasic.InternalSyntax.VariableNameEqualsSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Describes a single variable of the form "[x [As Type] =] expression" for use in
 query expressions.
 </summary>
	<param name="nameEquals">
 The optional name and type of the expression range variable. If ommitted, the
 name of the expression range variable is inferred from the expression.
 </param>
	<param name="expression">
 The expression used to initialize the expression variable.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AggregationRangeVariable(Roslyn.Compilers.VisualBasic.InternalSyntax.VariableNameEqualsSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.AggregationSyntax)">
	<summary>
 Describes a single variable of the form "[x [As Type] =] aggregation-function"
 for use in the Into clause of Aggregate or Group By or Group Join query
 operators.
 </summary>
	<param name="nameEquals">
 The optional name and type of the expression range variable. If ommitted, the
 name of the expression range variable is inferred from the aggregation
 expression.
 </param>
	<param name="aggregation">
 The name of the aggregation function. The "Group" aggregation function is
 represented by the identifier "Group".
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.VariableNameEquals(Roslyn.Compilers.VisualBasic.InternalSyntax.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleAsClauseSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents the name and optional type of an expression range variable.
 </summary>
	<param name="identifier">
 The name of the variable being defined.
 </param>
	<param name="asClause">
 Describes the type of the variable being defined.
 </param>
	<param name="equalsToken">
 The "=" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.FunctionAggregation(Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents an invocation of an Aggregation function in the aggregation range
 variable declaration of a Group By, Group Join or Aggregate query operator.
 </summary>
	<param name="functionName">
 The name of the aggregation function.
 </param>
	<param name="openParenToken">
 The "(" token if present.
 </param>
	<param name="argument">
 The argument to the aggregation function.
 </param>
	<param name="closeParenToken">
 The ")" token, if present.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.GroupAggregation(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents the use of "Group" as the aggregation function in the in the
 aggregation range variable declaration of a Group By or Group Join query
 operator.
 </summary>
	<param name="groupKeyword">
 The "Group" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.FromClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionRangeVariableSyntax})">
	<summary>
 Represents a "From" query operator. If this is the beginning of a query, the
 Source will be Nothing. Otherwise, the Source will be the part of the query to
 the left of the From.
 </summary>
	<param name="fromKeyword">
 The "From" keyword.
 </param>
	<param name="variables">
 The list of collection variables declared by this From operator.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.LetClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionRangeVariableSyntax})">
	<summary>
 Represents a "Let" query operator.
 </summary>
	<param name="letKeyword">
 The "Let" keyword.
 </param>
	<param name="variables">
 The list of expression range variable being defined by the Let operator.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AggregateClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.AggregationRangeVariableSyntax})">
	<summary>
 Represents an Aggregate query operator.
 </summary>
	<param name="aggregateKeyword">
 The "Aggregate" keyword.
 </param>
	<param name="variables">
 The list of collection range variables declared by this Aggregate operator.
 </param>
	<param name="additionalQueryOperators">
 A list of additional query operators. It may be empty.
 </param>
	<param name="intoKeyword">
 The "Into" keyword.
 </param>
	<param name="aggregationVariables">
 The list of new variables being defined by the aggregation.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DistinctClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents the "Distinct" query operator.
 </summary>
	<param name="distinctKeyword">
 The "Distinct" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.WhereClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a "Where" query operator.
 </summary>
	<param name="whereKeyword">
 The "Where" keyword.
 </param>
	<param name="condition">
 The boolean expression used for filtering.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SkipWhileClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="whileKeyword">
 The "While" keyword.
 </param>
	<param name="condition">
 The boolean expression used for partitioning.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TakeWhileClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="whileKeyword">
 The "While" keyword.
 </param>
	<param name="condition">
 The boolean expression used for partitioning.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.PartitionWhileClause(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a "Skip While" or "Take While" query operator. The Kind property
 tells which.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 PartitionWhileClauseSyntax. One of SkipWhileClause, TakeWhileClause.
 </param>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="whileKeyword">
 The "While" keyword.
 </param>
	<param name="condition">
 The boolean expression used for partitioning.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SkipClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TakeClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.PartitionClause(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a "Skip" or "Take" query operator. The Kind property tells which.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of
 PartitionClauseSyntax. One of SkipClause, TakeClause.
 </param>
	<param name="skipOrTakeKeyword">
 The "Skip" or "Take" keyword.
 </param>
	<param name="count">
 Represents the expression with the number of items to take or skip.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.GroupByClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.AggregationRangeVariableSyntax})">
	<summary>
 Represents the "Group By" query operator.
 </summary>
	<param name="groupKeyword">
 The "Group" keyword.
 </param>
	<param name="items">
 The optional list of variables being grouped; the contents of the Group clause.
 If none were specified, an empty list is returned.
 </param>
	<param name="byKeyword">
 The "By" keyword.
 </param>
	<param name="keys">
 The key values being used for grouping.
 </param>
	<param name="aggregationVariables">
 The list of new variables that calculate aggregations.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.JoinClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.JoinConditionSyntax})">
	<summary>
 Represents a Join query operator.
 </summary>
	<param name="joinKeyword">
 The "Join" keyword.
 </param>
	<param name="joinedVariables">
 Defines the collection range variables being joined to.
 </param>
	<param name="additionalJoins">
 An additional Join or Group Join query operator.
 </param>
	<param name="onKeyword">
 The "On" keyword.
 </param>
	<param name="joinConditions">
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.JoinCondition(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents the "expression Equals expression" condition in a Join.
 </summary>
	<param name="left">
 The left expression in the Join condition.
 </param>
	<param name="equalsKeyword">
 The "Equals" keyword.
 </param>
	<param name="right">
 The right expression in the Join condition.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.GroupJoinClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.JoinConditionSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.AggregationRangeVariableSyntax})">
	<summary>
 Represents the "Group Join" query operator.
 </summary>
	<param name="groupKeyword">
 The "Group" keyword.
 </param>
	<param name="joinKeyword">
 The "Join" keyword.
 </param>
	<param name="joinedVariables">
 Defines the collection range variables being joined to.
 </param>
	<param name="additionalJoins">
 An additional Join or Group Join query operator.
 </param>
	<param name="onKeyword">
 The "On" keyword.
 </param>
	<param name="joinConditions">
 The conditions indicating what expressions to compare during the join. Each
 condition is a JoinCondition, and the separators are "And" keywords.
 </param>
	<param name="intoKeyword">
 The "Into" keyword.
 </param>
	<param name="aggregationVariables">
 The list of new variables that calculate aggregations.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.OrderByClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.OrderingSyntax})">
	<summary>
 Represents the "Order By" query operator.
 </summary>
	<param name="orderKeyword">
 The "Order" keyword
 </param>
	<param name="byKeyword">
 The "By" keyword.
 </param>
	<param name="orderings">
 The list of OrderExpression's to sort by.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.AscendingOrdering(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
	<param name="expression">
 The expression to sort by.
 </param>
	<param name="ascendingOrDescendingKeyword">
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DescendingOrdering(Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
	<param name="expression">
 The expression to sort by.
 </param>
	<param name="ascendingOrDescendingKeyword">
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.Ordering(Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 An expression to order by, plus an optional ordering. The Kind indicates
 whether to order in ascending or descending order.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of OrderingSyntax. One
 of AscendingOrdering, DescendingOrdering.
 </param>
	<param name="expression">
 The expression to sort by.
 </param>
	<param name="ascendingOrDescendingKeyword">
 The "Ascending" or "Descending" keyword, if present. To determine whether to
 sort in ascending or descending order, checking the Kind property is easier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SelectClause(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionRangeVariableSyntax})">
	<summary>
 Represents the "Select" query operator.
 </summary>
	<param name="selectKeyword">
 The "Select" keyword.
 </param>
	<param name="variables">
 The list of expression range variables being defined by the Select query
 operator.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlDocument(Roslyn.Compilers.VisualBasic.InternalSyntax.XmlDeclarationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode})">
	<summary>
 Represents and XML Document literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlDeclaration(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlDeclarationOptionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlDeclarationOptionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlDeclarationOptionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents the XML declaration prologue in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlDeclarationOption(Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNameTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlStringSyntax)">
	<summary>
 Represents an XML document prologue option - version, encoding, standalone or
 whitespace in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlElement(Roslyn.Compilers.VisualBasic.InternalSyntax.XmlElementStartTagSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.XmlElementEndTagSyntax)">
	<summary>
 Represents an XML element with content in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlText(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode})">
	<summary>
 Represents Xml text.
 </summary>
	<param name="textTokens">
 A list of all the text tokens in the Xml text. This list always contains at
 least one token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlElementStartTag(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents the start tag of an XML element of the form &lt;element&gt;.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlElementEndTag(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNameSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents the end tag of an XML element of the form &lt;/element&gt;.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlEmptyElement(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents an empty XML element of the form &lt;element /&gt;
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlAttribute(Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNodeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNodeSyntax)">
	<summary>
 Represents an XML attribute in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlString(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a string of XML characters embedded as the content of an XML
 element.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlPrefixName(Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNameTokenSyntax)">
	<summary>
 Represents an XML name of the form 'name' appearing in GetXmlNamespace().
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlName(Roslyn.Compilers.VisualBasic.InternalSyntax.XmlPrefixSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNameTokenSyntax)">
	<summary>
 Represents an XML name of the form 'name' or 'namespace:name' appearing in
 source as part of an XML literal or member access expression or an XML
 namespace import clause.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlBracketedName(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNameSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents an XML name of the form &lt;xml-name&gt; appearing in source as part
 of an XML literal or member access expression or an XML namespace import
 clause.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlPrefix(Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNameTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents and XML namespace prefix of the form 'prefix:' as in xml:ns="".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlComment(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents an XML comment of the form &lt;-- Comment --&gt; appearing in an XML
 literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlProcessingInstruction(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.XmlNameTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents an XML processing instruction of the form '&lt;? XMLProcessingTarget
 XMLProcessingValue ?&gt;'.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlCDataSection(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents an XML CDATA section in an XML literal expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlEmbeddedExpression(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents an embedded expression in an XML literal e.g. '&lt;name&gt;&lt;%=
 obj.Name =%&gt;&lt;/name&gt;'.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ArrayType(Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode})">
	<summary>
 Represents an array type, such as "A() or "A(,)", without bounds specified for
 the array.
 </summary>
	<param name="elementType">
 The type of the elements of the array.
 </param>
	<param name="rankSpecifiers">
 Represents the list of "()" or "(,,)" modifiers on the array type.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.NullableType(Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 A type name that represents a nullable type, such as "Integer?".
 </summary>
	<param name="elementType">
 The kind of type that is this type is a nullable of. Cannot be an array type or
 a nullable type.
 </param>
	<param name="questionMarkToken">
 The "?" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.PredefinedType(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an occurrence of a Visual Basic built-in type such as Integer or
 String in source code.
 </summary>
	<param name="keyword">
 The keyword that was used to describe the built-in type.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.IdentifierName(Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax)">
	<summary>
 Represents a type name consisting of a single identifier (which might include
 brackets or a type character).
 </summary>
	<param name="identifier">
 The identifier in the name.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.GenericName(Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.TypeArgumentListSyntax)">
	<summary>
 Represents a simple type name with one or more generic arguments, such as "X(Of
 Y, Z).
 </summary>
	<param name="identifier">
 The identifier in the name.
 </param>
	<param name="typeArgumentList">
 The generic argument list.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.QualifiedName(Roslyn.Compilers.VisualBasic.InternalSyntax.NameSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleNameSyntax)">
	<summary>
 Represents a qualified type name, for example X.Y or X(Of Z).Y.
 </summary>
	<param name="left">
 The part of the name that appears to the left of the dot. This can itself be
 any name.
 </param>
	<param name="dotToken">
 The "." token that separates the names.
 </param>
	<param name="right">
 The part of the name that appears to the right of the dot. This must be a
 simple identifier.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.GlobalName(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents a name in the global namespace.
 </summary>
	<param name="globalKeyword">
 The "Global" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.TypeArgumentList(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.TypeSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a parenthesized list of generic type arguments.
 </summary>
	<param name="openParenToken">
 The "(" token.
 </param>
	<param name="ofKeyword">
 The "Of" keyword.
 </param>
	<param name="arguments">
 A list of all the type arguments.
 </param>
	<param name="closeParenToken">
 The ")" token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlNameToken(System.String,Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Represents an Xml NCName per Namespaces in XML 1.0
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlTextLiteralToken(System.String,System.String,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlEntityLiteralToken(System.String,System.String,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DocumentationCommentLineBreakToken(System.String,System.String,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.XmlTextToken(Roslyn.Compilers.VisualBasic.SyntaxKind,System.String,System.String,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Represents character data in Xml content also known as PCData or in an Xml
 attribute value. All text is here for now even text that does not need
 normalization such as comment, pi and cdata text.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of XmlTextTokenSyntax.
 One of XmlTextLiteralToken, XmlEntityLiteralToken,
 DocumentationCommentLineBreakToken.
 </param>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DecimalLiteralToken(System.String,Roslyn.Compilers.VisualBasic.TypeCharacter,System.Decimal,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Represents a Decimal literal token.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DateLiteralToken(System.String,System.DateTime,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Represents an Date literal token.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.StringLiteralToken(System.String,System.String,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Represents an string literal token.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CharacterLiteralToken(System.String,System.Char,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Represents an string literal token.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SkippedTokensTrivia(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode})">
	<summary>
 Represents tokens that were skipped by the parser as part of error recovery,
 and thus are not part of any syntactic structure.
 </summary>
	<param name="tokens">
 The list of tokens that were skipped by the parser.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DocumentationCommentTrivia(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode})">
	<summary>
 Represents a documentation comment e.g. ''' &lt;Summary&gt; apearing in source.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DirectiveTrivia(Roslyn.Compilers.VisualBasic.InternalSyntax.DirectiveStatementSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents a preprocessor directive
 </summary>
	<param name="terminator">
 The statement terminator token that ended the Directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.WhitespaceTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndOfLineTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ColonTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.CommentTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.LineContinuationTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ImplicitLineContinuationTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DocumentationCommentExteriorTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.DisabledTextTrivia(System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.SyntaxTrivia(Roslyn.Compilers.VisualBasic.SyntaxKind,System.String)">
	<summary>
 Trivia nodes represents parts of the program text that are not parts of the
 syntactic grammar, such as spaces, newlines, comments, preprocessors
 directives, and disabled code.
 </summary>
	<param name="kind">
 A <cref c="SyntaxKind"/> representing the specific kind of SyntaxTrivia. One of
 WhitespaceTrivia, EndOfLineTrivia, ColonTrivia, CommentTrivia,
 LineContinuationTrivia, ImplicitLineContinuationTrivia,
 DocumentationCommentExteriorTrivia, DisabledTextTrivia.
 </param>
	<param name="text">
 The actual text of this token.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ConstDirective(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax)">
	<summary>
 Represents a #Const pre-processing constant declaration appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
	<param name="constKeyword">
 The "Const" keyword.
 </param>
	<param name="name">
 The name of the pre-processing constant being defined.
 </param>
	<param name="equalsToken">
 The "=" token.
 </param>
	<param name="value">
 An expression representing the value of the pre-processing constant being
 defined.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.IfDirective(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ElseIfDirective(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.ExpressionSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents the beginning of an #If pre-processing directive appearing in
 source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ElseDirective(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an #Else pre-processing directive appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndIfDirective(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an #End If pre-processing directive appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.RegionDirective(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.StringLiteralTokenSyntax)">
	<summary>
 Represents the beginning of a #Region directive appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
	<param name="regionKeyword">
 The "Region" keyword.
 </param>
	<param name="name">
 The label of the code region being defined.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndRegionDirective(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an #End Region directive appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
	<param name="endKeyword">
 The "End" keyword.
 </param>
	<param name="regionKeyword">
 The "Region" keyword.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExternalSourceDirective(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.StringLiteralTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.IntegerLiteralTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents the beginning of a #ExternalSource pre-processing directive
 appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndExternalSourceDirective(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax)">
	<summary>
 Represents an #End ExternalSource pre-processing directive appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ExternalChecksumDirective(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.StringLiteralTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.StringLiteralTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.StringLiteralTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents an #ExternalChecksum pre-processing directive appearing in source.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.ReferenceDirective(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.StringLiteralTokenSyntax)">
	<summary>
 Represents an #r directive appearing in scripts.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.BadDirective(Roslyn.Compilers.VisualBasic.InternalSyntax.PunctuationSyntax)">
	<summary>
 Represents an unrecognized pre-processing directive. This occurs when the
 parser encounters a hash '#' token at the beginning of a physical line but does
 recognize the text that follows as a valid Visual Basic pre-processing
 directive.
 </summary>
	<param name="hashToken">
 The "#" token in a preprocessor directive.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.GetText(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Return keyword or punctuation text based on SyntaxKind
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GeneratedExtensionSyntaxFacts.GetText(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Return keyword or punctuation text based on SyntaxKind
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeUnification.CanUnify(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Determine whether there is any substitution of type parameters that will
 make two types identical.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeUnification.CanUnifyHelper(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSubstitution@)">
	<summary>
 Determine whether there is any substitution of type parameters that will
 make two types identical.
 </summary>
	<param name="containingGenericType">The generic containing type.</param>
	<param name="t1">LHS</param>
	<param name="t2">RHS</param>
	<param name="substitution">
 Substitutions performed so far (or null for none).
 Keys are type parameters, values are types (possibly type parameters).
 Will be updated with new subsitutions by the callee.
 Irrelevant if false is returned.
 </param>
	<returns>True if there exists a type map such that Map(LHS) == Map(RHS).</returns>
	<remarks>
 Derived from C# Dev10's BSYMMGR::UnifyTypes.
 Two types will not unify if they have different custom modifiers.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeUnification.AddSubstitution(Roslyn.Compilers.VisualBasic.TypeSubstitution@,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.TypeParameterSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Add a type parameter -&gt; type argument substitution to a TypeSubstitution object, returning a new TypeSubstitution object
 ByRef.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeUnification.Contains(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeParameterSymbol)">
	<summary>
 Return true if the given type contains the specified type parameter.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ObjectDisplay.FormatLiteral(System.String,System.Boolean,System.Char,System.Boolean)">
	<summary>
 Formats string literal.
 </summary>
	<param name="value">Literal value.</param>
	<param name="quote">True to double-quote the value. Also enables pretty-printing of non-printable chracters using ChrW function and vb* constants.</param>
	<param name="nonPrintableSubstitute">If specified non-printable characters are replaced by this character.</param>
	<param name="useHexadecimalNumbers">Use hexadecimal numbers as arguments to ChrW functions.</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.Iterator`1.GeneratorFunc`1">
	<summary>
 special func to create generators. the value is returned as a ByRef argument 
 while result used to indicate when iterating finishes.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Iterator`1.Enumerator`1">
	<summary>
 Enumerator wrapper for a generator lambda.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Iterator`1">
	<summary>
 Poor man's Iterator
 wraps a generator factory into an IEnumerable.
 generator is a lambda with a state (machine) that will produce sequence of values when called repeatedly.
 returning False from generator indicates that sequence is finished.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.FindToken(System.Int32,System.Func{Roslyn.Compilers.VisualBasic.SyntaxTrivia,System.Boolean})">
	<summary>
 Finds a token according to the following rules:
 1)	If position matches the End of the node's FullSpan and the node is CompilationUnit, then EoF is returned. 
 
 2)	If node.FullSpan.Contains(position) the token that contains given position is returned.
     If stepInto is not Nothing, then structured trivia that satisfies the condition will also be visited during the search.
 
 3)	Otherwise an IndexOutOfRange is thrown
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.FindToken(System.Int32,System.Boolean)">
	<summary>
 Finds a token according to the following rules:
 1)	If position matches the End of the node's FullSpan and the node is CompilationUnit, then EoF is returned. 
 
 2)	If node.FullSpan.Contains(position) then the token that contains given position is returned.
 
 3)	Otherwise an IndexOutOfRange is thrown
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DescendantTrivia(System.Func{Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean},System.Boolean)">
	<summary>
 A list of all trivia for all descendant tokens.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DescendantTrivia(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean},System.Boolean)">
	<summary>
 A list of all trivia for all descendant tokens.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DescendantTokens(System.Func{Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean},System.Boolean)">
	<summary>
 Gets a list of descendant tokens under this node.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DescendantTokens(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean},System.Boolean)">
	<summary>
 Gets a list of descendant tokens under this node with a full span that intersects the specified span.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxTrivia.Language">
	<summary>
 The language name this trivia is syntax of.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxTrivia.ContainsAnnotations">
	<summary>
 Determines whether this trivia or any of its sub structure has annotations.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTrivia.HasAnnotations(System.Type)">
	<summary>
 Determines whether this trivia has an annotation of the specified type.
 The Type must be a strict sub type of SyntaxAnnotation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTrivia.HasAnnotation(Roslyn.Compilers.SyntaxAnnotation)">
	<summary>
 Determines whether this trivia has the specific annotation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTrivia.GetAnnotations(System.Type)">
	<summary>
 Gets all annotations of the specified type on this trivia.
 The type must be a strict sub type of SyntaxAnnotation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTrivia.ToString">
	<summary> 
 Returns the string representation of this trivia. If this trivia is structured trivia then the returned string
 will not include any leading or trailing trivia present on the StructuredTriviaSyntax node of this trivia.
 </summary>
	<returns>The string representation of this trivia.</returns>
	<remarks>The length of the returned string is always the same as Span.Length</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTrivia.ToFullString">
	<summary> 
 Returns the full string representation of this trivia. If this trivia is structured trivia then the returned string will
 include any leading or trailing trivia present on the StructuredTriviaSyntax node of this trivia.
 </summary>
	<returns>The full string representation of this trivia.</returns>
	<remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTrivia.WriteTo(System.IO.TextWriter)">
	<summary>
 Writes the full text of this trivia to the specified TextWriter
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTrivia.WithAdditionalAnnotations(Roslyn.Compilers.SyntaxAnnotation[])">
	<summary>
 Adds this annotation to a given syntax token, creating a new syntax token of the same type with the
 annotation on it.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTrivia.CopyAnnotationsTo(Roslyn.Compilers.VisualBasic.SyntaxTrivia)">
	<summary>
 Copies all SyntaxAnnotations, if any, from this SyntaxTrivia instance and attaches them to a new instance based on <paramref name="trivia"/>.
 </summary>
	<remarks>
 If no annotations are copied, just returns <paramref name="trivia"/>.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTrivia.GetLocation">
	<summary>
 Gets the location of this trivia.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTrivia.GetDiagnostics">
	<summary>
 Gets a list of all the diagnostics associated with this trivia.
 This method does not filter diagnostics based on compiler options like nowarn, warnaserror etc.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxTree.Options">
	<summary>
 The options used by the parser to produce the syntax tree.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.CloneNodeAsRoot``1(``0)">
	<summary>
 Produces a clone of a SyntaxNode which will have current syntax tree as its parent.
 
 Caller must guarantee that if the same instance of SyntaxNode makes multiple calls 
 to this function, only one result is observable.
 </summary>
	<typeparam name="T">Type of the syntax node.</typeparam>
	<param name="node">The original syntax node.</param>
	<returns>A clone of the original syntax node that has current SyntaxTree as its parent.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.GetRoot(System.Threading.CancellationToken)">
	<summary>
 Gets the root node of the syntax tree. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.GetRootAsync(System.Threading.CancellationToken)">
	<summary>
 Gets the root node of the syntax tree asynchronously.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.TryGetRoot(Roslyn.Compilers.VisualBasic.CompilationUnitSyntax@)">
	<summary>
 Gets the root node of the syntax tree if it is available.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.WithChangedText(Roslyn.Compilers.IText)">
	<summary>
 Create a new syntax based off this tree using a new source text. 
 
 If the new source text is a minor change from the current source text an incremental parse will occur
 reusing most of the current syntax tree internal data.  Otherwise, a full parse will using the new
 source text.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.GetReference(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Gets a SyntaxReference for a specified syntax node. SyntaxReferences can be used to regain access to a
 syntax node without keeping the entire tree and source text in memory.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.ParseText(Roslyn.Compilers.IText,System.String,Roslyn.Compilers.VisualBasic.ParseOptions,System.Threading.CancellationToken)">
	<summary>
 Produce a syntax tree by parsing the source text.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.ParseFile(System.String,Roslyn.Compilers.VisualBasic.ParseOptions,System.Threading.CancellationToken)">
	<summary>
 Produce a syntax tree by parsing the source file.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.GetDiagnostics(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Gets a list of all the diagnostics in the sub tree that has the specified node as its root.
 This method does not filter diagnostics based on compiler options like nowarn, warnaserror etc.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.GetDiagnostics(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Gets a list of all the diagnostics associated with the token and any related trivia.
 This method does not filter diagnostics based on compiler options like nowarn, warnaserror etc.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.GetDiagnostics(Roslyn.Compilers.VisualBasic.SyntaxTrivia)">
	<summary>
 Gets a list of all the diagnostics associated with the trivia.
 This method does not filter diagnostics based on compiler options like nowarn, warnaserror etc.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.GetDiagnostics(Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken)">
	<summary>
 Gets a list of all the diagnostics in either the sub tree that has the specified node as its root or
 associated with the token and its related trivia. 
 This method does not filter diagnostics based on compiler options like nowarn, warnaserror etc.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.GetDiagnostics(System.Threading.CancellationToken)">
	<summary>
 Gets a list of all the diagnostics in the syntax tree.
 This method does not filter diagnostics based on compiler options like nowarn, warnaserror etc.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.GetLineSpan(Roslyn.Compilers.TextSpan,System.Boolean,System.Threading.CancellationToken)">
	<summary>
 Gets a FileLinePositionSpan for a TextSpan. FileLinePositionSpans are used primarily for diagnostics and
 source locations.
 </summary>
	<param name="usePreprocessorDirectives">An indicator that determines whether preprocessor #line directives
 are used to alter the resulting line span.</param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.GetLocation(Roslyn.Compilers.TextSpan)">
	<summary>
 Gets a location for the specified text span.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.IsEquivalentTo(Roslyn.Compilers.VisualBasic.SyntaxTree,System.Boolean)">
	<summary>
 Determines if two trees are the same, disregarding trivia differences.
 </summary>
	<param name="tree">The tree to compare against.</param>
	<param name="topLevel"> If true then the trees are equivalent if the contained nodes and tokens declaring
 metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
 or initializer expressions, otherwise all nodes and tokens must be equivalent. 
 </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyntaxTree">
	<summary>
 The parsed representation of a Visual Basic source document.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTokenList.ToString">
	<summary>
 Returns the string representation of the tokens in this list, not including 
 the first token's leading trivia and the last token's trailing trivia.
 </summary>
	<returns>
 The string representation of the tokens in this list, not including 
 the first token's leading trivia and the last token's trailing trivia.
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTokenList.ToFullString">
	<summary>
 Returns the full string representation of the tokens in this list including 
 the first token's leading trivia and the last token's trailing trivia.
 </summary>
	<returns>
 The full string representation of the tokens in this list including 
 the first token's leading trivia and the last token's trailing trivia.
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTokenList.GetGreenNodeAt(System.Int32)">
	<summary>
 get the green node at the given slot
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxToken.Language">
	<summary>
 The language name this token is syntax of.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxToken.ContainsAnnotations">
	<summary>
 Determines whether this token or any of its trivia has annotations.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxToken.HasAnnotations(System.Type)">
	<summary>
 Determines whether this token has an annotation of the specified type.
 The type must be a strict sub type of SyntaxAnnotation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxToken.HasAnnotation(Roslyn.Compilers.SyntaxAnnotation)">
	<summary>
 Determines whether this token as the specific annotation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxToken.GetAnnotations(System.Type)">
	<summary>
 Gets all annotations on this token of the specified type.
 The type must be a strict sub type of SyntaxAnnotation.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxToken.HasStructuredTrivia">
	<summary>
 True if any trivia of this token is structured.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxToken.ToString">
	<summary>
 Returns the string representation of this token, not including its leading and trailing trivia.
 </summary>
	<returns>The string representation of this token, not including its leading and trailing trivia.</returns>
	<remarks>The length of the returned string is always the same as Span.Length</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxToken.ToFullString">
	<summary>
 Returns the full string representation of this token including its leading and trailing trivia.
 </summary>
	<returns>The full string representation of this token including its leading and trailing trivia.</returns>
	<remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxToken.WriteTo(System.IO.TextWriter)">
	<summary>
 Writes the full text of this token to the specified TextWriter
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxToken.GetAllTrivia">
	<summary>
 Gets a list of both leading and trailing trivia for the token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxToken.GetSyntaxErrors(Roslyn.Compilers.VisualBasic.SyntaxTree)">
	<summary>
 Get all syntax errors associated with this node, or any child nodes, grand-child nodes, etc. The errors
 are not in order.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxToken.WithAdditionalAnnotations(Roslyn.Compilers.SyntaxAnnotation[])">
	<summary>
 Adds this annotation to a given syntax token, creating a new syntax token of the same type with the
 annotation on it.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxToken.CopyAnnotationsTo(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Copies all SyntaxAnnotations, if any, from this SyntaxToken instance and attaches them to a new instance based on <paramref name="token"/>.
 </summary>
	<remarks>
 If no annotations are copied, just returns <paramref name="token"/>.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxToken.GetLocation">
	<summary>
 Gets the location of this token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxToken.GetDiagnostics">
	<summary>
 Gets a list of all the diagnostics associated with this token and any related trivia.
 This method does not filter diagnostics based on compiler options like nowarn, warnaserror etc.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyntaxReference">
	<summary>
 A SyntaxReference allows one to get a reference to a syntax node that can be
 re-obtained later.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SingleLineLambdaExpressionSyntax.Statements">
	<summary>
 Single line subs only have a single statement.  However, when binding it is convenient to have a statement list.  For example,
 dim statements are not valid in a single line lambda.  However, it is nice to be able to provide semantic info about the local.
 The only way to create locals is to have a statement list. This method is friend because the statement list should not be part
 of the public api.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNodeOrTokenList.ToString">
	<summary>
 Returns the string representation of the items in this list, not including the first item's leading trivia 
 and the last item's trailing trivia.
 </summary>
	<returns>
 The string representation of the items in this list, not including the first item's leading trivia 
 and the last item's trailing trivia.
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNodeOrTokenList.ToFullString">
	<summary>
 Returns the full string representation of the items in this list including the first item's leading trivia 
 and the last item's trailing trivia.
 </summary>
	<returns>
 The full string representation of the items in this list including the first item's leading trivia 
 and the last item's trailing trivia.
 </returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken.Language">
	<summary>
 The language name this node or token is syntax of.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken.GetFirstChildIndexSpanningPosition(Roslyn.Compilers.VisualBasic.SyntaxNode,System.Int32)">
	<summary>
 binary search of nodes to find the slot.  Consider unifying this with that
 implementation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken.ToString">
	<summary>
 Returns the string representation of this node or token, not including its leading and trailing
 trivia.
 </summary>
	<returns>The string representation of this node or token, not including its leading and trailing
 trivia.</returns>
	<remarks>The length of the returned string is always the same as Span.Length</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken.ToFullString">
	<summary>
 Returns the full string representation of this node or token including its leading and trailing trivia.
 </summary>
	<returns>The full string representation of this node or token including its leading and trailing
 trivia.</returns>
	<remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken.ContainsAnnotations">
	<summary>
 Determines whether this node or token (or any sub node, token or trivia) has annotations
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken.HasAnnotations(System.Type)">
	<summary>
 Determines if this node or token has any annotation of the specified type attached.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken.HasAnnotation(Roslyn.Compilers.SyntaxAnnotation)">
	<summary>
 Determines whether this node has the specific annotation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken.GetAnnotations(System.Type)">
	<summary>
 Gets all annotations of the specified type attached to this node or token.
 The type must be a strict sub type of SyntaxAnnotation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken.GetLocation">
	<summary>
 Gets the location of this node or token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken.GetDiagnostics">
	<summary>
 Gets a list of all the diagnostics in either the sub tree that has this node as its root or
 associated with this token and its related trivia. 
 This method does not filter diagnostics based on compiler options like nowarn, warnaserror etc.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParseLeadingTrivia(System.String,System.Int32)">
	<summary>
Parse the input for leading trivia.
 </summary>
	<param name="text">The input string</param>
	<param name="offset">The starting offset in the string</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParseTrailingTrivia(System.String,System.Int32)">
	<summary>
 Parse the input for trailing trivia.
 </summary>
	<param name="text">The input string</param>
	<param name="offset">The starting offset in the string</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParseToken(System.String,System.Int32,System.Boolean)">
	<summary>
 Parse one token.
 </summary>
	<param name="text">The input string</param>
	<param name="offset">The starting offset in the string</param>
	<param name="startStatement">Scan using rules for the start of a statement</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParseTokens(System.String,System.Int32,System.Int32,Roslyn.Compilers.VisualBasic.ParseOptions)">
	<summary>
 Parse tokens in the input.
 </summary>
	<param name="text">The input string</param>
	<param name="offset">The starting offset in the string</param>
	<param name="initialTokenPosition">The position of the first token</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParseName(System.String,System.Int32)">
	<summary>
 Parse a name.
 </summary>
	<param name="text">The input string</param>
	<param name="offset">The starting offset in the string</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParseTypeName(System.String,System.Int32)">
	<summary>
 Parse a type name.
 </summary>
	<param name="text">The input string</param>
	<param name="offset">The starting offset in the string</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParseExpression(System.String,System.Int32)">
	<summary>
 Parse an expression.
 </summary>
	<param name="text">The input string</param>
	<param name="offset">The starting offset in the string</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParseExecutableStatement(System.String,System.Int32)">
	<summary>
 Parse an executable statement.
 </summary>
	<param name="text">The input string</param>
	<param name="offset">The starting offset in the string</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParseCompilationUnit(System.String,System.Int32,Roslyn.Compilers.VisualBasic.ParseOptions)">
	<summary>
 Parse a compilation unit (a single source file).
 </summary>
	<param name="text">The input string</param>
	<param name="offset">The starting offset in the string</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParseParameterList(System.String,System.Int32)">
	<summary>
 Parse a parameter list.
 </summary>
	<param name="text">The input string</param>
	<param name="offset">The starting offset in the string</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.ParseArgumentList(System.String,System.Int32)">
	<summary>
 Parse an argument list.
 </summary>
	<param name="text">The input string</param>
	<param name="offset">The starting offset in the string</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MakeIText(System.String,System.Int32)">
	<summary>
 Helper method for wrapping a string and offset in an IText.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MissingIdentifier">
	<summary>
 Create a missing identifier.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MissingIdentifier(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Create a missing contextual keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MissingKeyword(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Create a missing keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MissingPunctuation(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Create a missing punctutation mark.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MissingStringLiteral">
	<summary>
 Create a missing string literal.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MissingCharacterLiteralToken">
	<summary>
 Create a missing character literal.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MissingIntegerLiteralToken">
	<summary>
 Create a missing integer literal.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.MissingToken(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Creates a copy of a token.
 <para name="err"></para>
		<para name="trivia"></para>
	</summary>
	<returns>The new token</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.#ctor(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,System.Int32,Roslyn.Compilers.VisualBasic.SyntaxTree)">
	<summary>
 Used by structured trivia which has no parent node, so need to know syntax tree explicitly
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.CloneNodeAsRoot``1(``0,Roslyn.Compilers.VisualBasic.SyntaxTree)">
	<summary>
 Creates a clone of a red node that can be used as a root of given syntaxTree.
 New node has no parents, position == 0, and syntaxTree as specified.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.SyntaxTree">
	<summary>
 Returns SyntaxTree that owns the node or null if node does not belong to a SyntaxTree
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.Green">
	<summary>
 Return the green node this node wraps. Never null.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.Position">
	<summary>
 The start location of this node.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.EndLocation">
	<summary>
 The start location of this node.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.Kind">
	<summary>
 The kind of this node.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.Language">
	<summary>
 The language name this node is syntax of.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.Parent">
	<summary>
 The parent of this node.
 </summary>
	<value>The parent node of this node, or Nothing if this node is the root.</value>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.ToString">
	<summary>
 Returns the string representation of this node, not including its leading and trailing trivia.
 </summary>
	<returns>The string representation of this node, not including its leading and trailing trivia.</returns>
	<remarks>The length of the returned string is always the same as Span.Length</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.ToFullString">
	<summary>
 Returns full string representation of this node including its leading and trailing trivia.
 </summary>
	<returns>The full string representation of this node including its leading and trailing trivia.</returns>
	<remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.WriteTo(System.IO.TextWriter)">
	<summary>
 Writes the full text of this node to the specified TextWriter
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.SerializeTo(System.IO.Stream,System.Threading.CancellationToken)">
	<summary>
 Serialize this node to a byte stream.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DeserializeFrom(System.IO.Stream,System.Threading.CancellationToken)">
	<summary>
 Deserialize a syntax node from a byte stream.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.IsStructuredTrivia">
	<summary>
 Returns if this node is a trivia node, representing whitespace, comments, disabled
 code, etc. Trivia nodes do not themselves have trivia, although they can have children which have trivia.
 </summary>
	<value>True if node is a trivia, false if a non-terminal or token node.</value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.HasStructuredTrivia">
	<summary>
 Determines whether a descendant trivia of this node is structured.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.IsDirective">
	<summary>
 Returns True if this node represents a directive.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.Span">
	<summary>
 Get the span of this node, not including preceding trivia on this node or children. If this is a token, gets
 the span not including its trivia. If this is a non-terminal, gets the span not including the preceding
 trivia of the first token, and not including the following trivia of the last token.
 </summary>
	<value>The span of the node, not including preceding or following trivia.</value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.FullSpan">
	<summary>
 Get the span of this node, including preceding trivia on this node or children. If this 
 is a token, gets the span including its trivia. If this is a non-terminal, gets this 
 full span of all children.
 </summary>
	<value>The span of the node, including preceding or following trivia.</value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.FullWidth">
	<summary>
 The width of this item, in characters. Includes any associated trivia (whitespace/comments).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.IsMissing">
	<summary>
 Returns true if this node was missing; i.e., was synthesized by the parser. A missing node
 has an empty Span and FullSpan, but the location of the Span still shows where it was expected
 to be in the source.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.GetLeadingTrivia">
	<summary>
 Get the preceding trivia nodes of this node. If this node is a token, returns the preceding trivia
 associated with this node. If this is a non-terminal, returns the preceding trivia of the first token
 of this node. 
 </summary>
	<returns>A list of a the preceding trivia.</returns>
	<remarks>If this node is a non-terminal, the parents of the trivia will be the first token of this 
 non-terminal; NOT this node.</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.GetTrailingTrivia">
	<summary>
 Get the following trivia nodes of this node. If this node is a token, returns the following trivia
 associated with this node. If this is a non-terminal, returns the following trivia of the last token
 of this node. 
 </summary>
	<returns>A list of a the following trivia.</returns>
	<remarks>If this node is a non-terminal, the parents of the trivia will be the first token of this 
 non-terminal; NOT this node.</remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.HasLeadingTrivia">
	<summary>
 Returns 'true' if this node has any leading trivia.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.HasTrailingTrivia">
	<summary>
 Returns 'true' if this node has any trailing trivia.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.ContainsDiagnostics">
	<summary>
 Does this node, or any nodes beneath it, have syntax errors? Checking this property is much faster
 than actually getting the list of errors with GetSyntaxErrors()
 </summary>
	<returns>True if there is a syntax error associated with the node, or with any children, grandchildren, etc.</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxNode.ContainsAnnotations">
	<summary>
 Does this node, or any nodes beneath it, have syntax annotations?
 </summary>
	<returns>True if there is a syntax annotation associated with the node, or with any children, grandchildren, etc.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.GetChildPosition(System.Int32)">
	<summary>
 This function calculates the offset of a child at given position.
 Often that there are some children to the left of the given index that
 Already have know their offsets so we first check if that is the case.
 In a worst case the cost is O(n), but it is not generally an issue 
 because number of children in regular nodes and lists is typically small.
 In a case where the number of children could often be large (separated lists) 
 this function is overridden with more efficient implementations.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.GetSyntaxErrors(Roslyn.Compilers.VisualBasic.SyntaxTree)">
	<summary>
 Get all syntax errors associated with this node, or any child nodes, grand-child nodes, etc. The errors
 are not in order.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.PushNodesWithErrors(System.Collections.Generic.Stack{Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken},Roslyn.Compilers.VisualBasic.ChildSyntaxList)">
	<summary>
 Push any nodes that have errors in the given collection onto a stack
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.CreateSyntaxError(Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken,Roslyn.Compilers.DiagnosticInfo)">
	<summary>
 Given a error info from this node, create the corresponding syntax error with the right span.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.EquivalentTo(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Compares two trees for structural equivalence.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.AddError(Roslyn.Compilers.DiagnosticInfo)">
	<summary>
 Add an error to the given node, creating a new node that is the same except it has no parent,
 and has the given error attached to it. The error span is the entire span of this node.
 </summary>
	<param name="err">The error to attach to this node</param>
	<returns>A new node, with no parent, that has this error added to it.</returns>
	<remarks>Since nodes are immutable, the only way to create nodes with errors attached is to create a node without an error,
 then add an error with this method to create another node.</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.ChildNodes">
	<summary>
 Gets a list of the child nodes in document order. This list does not contain tokens.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.ChildNodesAndTokens">
	<summary>
 Gets the list of child nodes and tokens of this node in document order, where each element
 is a SyntaxNodeOrToken instance.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.Ancestors(System.Boolean)">
	<summary>
 Gets a list of ancestor nodes that have type TNode and satisfies the predicate.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.AncestorsAndSelf(System.Boolean)">
	<summary>
 Gets a list of ancestor nodes (including this node) that have type TNode and satisfies the predicate.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DescendantNodes(System.Func{Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean},System.Boolean)">
	<summary>
 Gets a list of descendant nodes in prefix document order.
 </summary>
	<param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
	<param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DescendantNodes(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean},System.Boolean)">
	<summary>
 Gets a list of descendant nodes in prefix document order.
 </summary>
	<param name="span">The span the node's full span must intersect.</param>
	<param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
	<param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DescendantNodesAndSelf(System.Func{Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean},System.Boolean)">
	<summary>
 Gets a list of descendant nodes (including this node) in prefix document order.
 </summary>
	<param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
	<param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DescendantNodesAndSelf(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean},System.Boolean)">
	<summary>
 Gets a list of descendant nodes (including this node) in prefix document order.
 </summary>
	<param name="span">The span the node's full span must intersect.</param>
	<param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
	<param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DescendantNodesAndTokens(System.Func{Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean},System.Boolean)">
	<summary>
 Gets a list of descendant nodes and tokens in prefix document order.
 </summary>
	<param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
	<param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DescendantNodesAndTokens(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean},System.Boolean)">
	<summary>
 Gets a list of the descendant nodes and tokens in prefix document order.
 </summary>
	<param name="span">The span the node's full span must intersect.</param>
	<param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
	<param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DescendantNodesAndTokensAndSelf(System.Func{Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean},System.Boolean)">
	<summary>
 Gets a list of descendant nodes and tokens (including this node) in prefix document order.
 </summary>
	<param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
	<param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.DescendantNodesAndTokensAndSelf(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean},System.Boolean)">
	<summary>
 Gets a list of the descendant nodes and tokens (including this node) in prefix document order.
 </summary>
	<param name="span">The span the node's full span must intersect.</param>
	<param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
	<param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.WithAdditionalAnnotationsCore(Roslyn.Compilers.SyntaxAnnotation[])">
	<summary>
 Adds this annotation to a given syntax token, creating a new syntax token of the same type with the
 annotation on it.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.GetAnnotatedNodesAndTokens(System.Type)">
	<summary>
 Gets all nodes and tokens with an annotation of the specified type.
 The type must be a strict sub type of SyntaxAnnotation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.GetAnnotatedNodesAndTokens(Roslyn.Compilers.SyntaxAnnotation)">
	<summary>
 Gets all nodes and tokens with the specific annotation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.GetAnnotatedTrivia(System.Type)">
	<summary>
 Gets all trivia with an annotation of the specified type.
 The type must be a strict sub type of SyntaxAnnotation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.GetAnnotatedTrivia(Roslyn.Compilers.SyntaxAnnotation)">
	<summary>
 Gets all trivia with the specific annotation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.GetLocation">
	<summary>
 Gets the location of this node.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.GetReference">
	<summary>
 Gets a SyntaxReference for this syntax node. SyntaxReferences can be used to regain access to a
 syntax node without keeping the entire tree and source text in memory.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNode.GetDiagnostics">
	<summary>
 Gets a list of all the diagnostics in the sub tree that has this node as its root.
 This method does not filter diagnostics based on compiler options like nowarn, warnaserror etc.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxList.GetRedListElement(Roslyn.Compilers.VisualBasic.SyntaxNode@,System.Int32)">
	<summary>
 This works the same as GetRedOnly, but intended to be used in lists
 The only difference is that the public parent of the node is not the list, 
 but the list's parent. (element's grand parent).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.GetStandAloneExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary> 
 Names on the right of qualified names and member access expressions are not stand-alone expressions.
 This method returns the appropriate parent of name syntax nodes that are on right of these constructs.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(System.Int32)">
	<summary> Creates a token with kind IntegerLiteralToken from a 4-byte signed integer value. </summary>
	<param name="value">The 4-byte signed integer value to be represented by the returned token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(System.String,System.Int32)">
	<summary> Creates a token with kind IntegerLiteralToken from the text and corresponding 4-byte signed integer value. </summary>
	<param name="text">The raw text of the literal.</param>
	<param name="value">The 4-byte signed integer value to be represented by the returned token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(Roslyn.Compilers.VisualBasic.SyntaxTriviaList,System.String,System.Int32,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary> Creates a token with kind IntegerLiteralToken from the text and corresponding 4-byte signed integer value. </summary>
	<param name="leading">A list of trivia immediately preceding the token.</param>
	<param name="text">The raw text of the literal.</param>
	<param name="value">The 4-byte signed integer value to be represented by the returned token.</param>
	<param name="trailing">A list of trivia immediately following the token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(System.UInt32)">
	<summary> Creates a token with kind IntegerLiteralToken from a 4-byte unsigned integer
 value. </summary>
	<param name="value">The 4-byte unsigned integer value to be represented by the returned token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(System.String,System.UInt32)">
	<summary> Creates a token with kind IntegerLiteralToken from the text and corresponding 4-byte unsigned integer value. </summary>
	<param name="text">The raw text of the literal.</param>
	<param name="value">The 4-byte unsigned integer value to be represented by the returned token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(Roslyn.Compilers.VisualBasic.SyntaxTriviaList,System.String,System.UInt32,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary> Creates a token with kind IntegerLiteralToken from the text and corresponding 4-byte unsigned integer value. </summary>
	<param name="leading">A list of trivia immediately preceding the token.</param>
	<param name="text">The raw text of the literal.</param>
	<param name="value">The 4-byte unsigned integer value to be represented by the returned token.</param>
	<param name="trailing">A list of trivia immediately following the token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(System.Int64)">
	<summary> Creates a token with kind IntegerLiteralToken from an 8-byte signed integer value. </summary>
	<param name="value">The 8-byte signed integer value to be represented by the returned token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(System.String,System.Int64)">
	<summary> Creates a token with kind IntegerLiteralToken from the text and corresponding 8-byte signed integer value. </summary>
	<param name="text">The raw text of the literal.</param>
	<param name="value">The 8-byte signed integer value to be represented by the returned token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(Roslyn.Compilers.VisualBasic.SyntaxTriviaList,System.String,System.Int64,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary> Creates a token with kind IntegerLiteralToken from the text and corresponding 8-byte signed integer value. </summary>
	<param name="leading">A list of trivia immediately preceding the token.</param>
	<param name="text">The raw text of the literal.</param>
	<param name="value">The 8-byte signed integer value to be represented by the returned token.</param>
	<param name="trailing">A list of trivia immediately following the token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(System.UInt64)">
	<summary> Creates a token with kind IntegerLiteralToken from an 8-byte unsigned integer value. </summary>
	<param name="value">The 8-byte unsigned integer value to be represented by the returned token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(System.String,System.UInt64)">
	<summary> Creates a token with kind IntegerLiteralToken from the text and corresponding 8-byte unsigned integer value. </summary>
	<param name="text">The raw text of the literal.</param>
	<param name="value">The 8-byte unsigned integer value to be represented by the returned token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(Roslyn.Compilers.VisualBasic.SyntaxTriviaList,System.String,System.UInt64,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary> Creates a token with kind IntegerLiteralToken from the text and corresponding 8-byte unsigned integer value. </summary>
	<param name="leading">A list of trivia immediately preceding the token.</param>
	<param name="text">The raw text of the literal.</param>
	<param name="value">The 8-byte unsigned integer value to be represented by the returned token.</param>
	<param name="trailing">A list of trivia immediately following the token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(System.Single)">
	<summary> Creates a token with kind FloatingLiteralToken from a 4-byte floating point value. </summary>
	<param name="value">The 4-byte floating point value to be represented by the returned token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(System.String,System.Single)">
	<summary> Creates a token with kind FloatingLiteralToken from the text and corresponding 4-byte floating point value. </summary>
	<param name="text">The raw text of the literal.</param>
	<param name="value">The 4-byte floating point value to be represented by the returned token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(Roslyn.Compilers.VisualBasic.SyntaxTriviaList,System.String,System.Single,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary> Creates a token with kind FloatingLiteralToken from the text and corresponding 4-byte floating point value. </summary>
	<param name="leading">A list of trivia immediately preceding the token.</param>
	<param name="text">The raw text of the literal.</param>
	<param name="value">The 4-byte floating point value to be represented by the returned token.</param>
	<param name="trailing">A list of trivia immediately following the token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(System.Double)">
	<summary> Creates a token with kind FloatingLiteralToken from an 8-byte floating point value. </summary>
	<param name="value">The 8-byte floating point value to be represented by the returned token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(System.String,System.Double)">
	<summary> Creates a token with kind FloatingLiteralToken from the text and corresponding 8-byte floating point value. </summary>
	<param name="text">The raw text of the literal.</param>
	<param name="value">The 8-byte floating point value to be represented by the returned token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(Roslyn.Compilers.VisualBasic.SyntaxTriviaList,System.String,System.Double,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary> Creates a token with kind FloatingLiteralToken from the text and corresponding 8-byte floating point value. </summary>
	<param name="leading">A list of trivia immediately preceding the token.</param>
	<param name="text">The raw text of the literal.</param>
	<param name="value">The 8-byte floating point value to be represented by the returned token.</param>
	<param name="trailing">A list of trivia immediately following the token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(System.Decimal)">
	<summary> Creates a token with kind DecimalLiteralToken from a decimal value. </summary>
	<param name="value">The decimal value to be represented by the returned token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(System.String,System.Decimal)">
	<summary> Creates a token with kind DecimalLiteralToken from the text and corresponding decimal value. </summary>
	<param name="text">The raw text of the literal.</param>
	<param name="value">The decimal value to be represented by the returned token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(Roslyn.Compilers.VisualBasic.SyntaxTriviaList,System.String,System.Decimal,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary> Creates a token with kind DecimalLiteralToken from the text and corresponding decimal value. </summary>
	<param name="leading">A list of trivia immediately preceding the token.</param>
	<param name="text">The raw text of the literal.</param>
	<param name="value">The decimal value to be represented by the returned token.</param>
	<param name="trailing">A list of trivia immediately following the token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(System.String)">
	<summary> Creates a token with kind StringLiteralToken from a string value. </summary>
	<param name="value">The string value to be represented by the returned token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(System.String,System.String)">
	<summary> Creates a token with kind StringLiteralToken from the text and corresponding string value. </summary>
	<param name="text">The raw text of the literal, including quotes and escape sequences.</param>
	<param name="value">The string value to be represented by the returned token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(Roslyn.Compilers.VisualBasic.SyntaxTriviaList,System.String,System.String,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary> Creates a token with kind StringLiteralToken from the text and corresponding string value. </summary>
	<param name="leading">A list of trivia immediately preceding the token.</param>
	<param name="text">The raw text of the literal, including quotes and escape sequences.</param>
	<param name="value">The string value to be represented by the returned token.</param>
	<param name="trailing">A list of trivia immediately following the token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(System.Char)">
	<summary> Creates a token with kind CharacterLiteralToken from a character value. </summary>
	<param name="value">The character value to be represented by the returned token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(System.String,System.Char)">
	<summary> Creates a token with kind CharacterLiteralToken from the text and corresponding character value. </summary>
	<param name="text">The raw text of the literal, including quotes and escape sequences.</param>
	<param name="value">The character value to be represented by the returned token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.Literal(Roslyn.Compilers.VisualBasic.SyntaxTriviaList,System.String,System.Char,Roslyn.Compilers.VisualBasic.SyntaxTriviaList)">
	<summary> Creates a token with kind CharacterLiteralToken from the text and corresponding character value. </summary>
	<param name="leading">A list of trivia immediately preceding the token.</param>
	<param name="text">The raw text of the literal, including quotes and escape sequences.</param>
	<param name="value">The character value to be represented by the returned token.</param>
	<param name="trailing">A list of trivia immediately following the token.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AreEquivalent(Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.VisualBasic.SyntaxTree,System.Boolean)">
	<summary>
 Determines if two trees are the same, disregarding trivia differences.
 </summary>
	<param name="oldTree">The original tree.</param>
	<param name="newTree">The new tree.</param>
	<param name="topLevel"> If true then the trees are equivalent if the contained nodes and tokens declaring
 metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
 or initializer expressions, otherwise all nodes and tokens must be equivalent. 
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Syntax.AreEquivalent(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean)">
	<summary>
 Determines if two syntax nodes are the same, disregarding trivia differences.
 </summary>
	<param name="oldNode">The old node.</param>
	<param name="newNode">The new node.</param>
	<param name="topLevel"> If true then the nodes are equivalent if the contained nodes and tokens declaring
 metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
 or initializer expressions, otherwise all nodes and tokens must be equivalent. 
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SeparatedSyntaxList`1.GetSeparator(System.Int32)">
	<summary>
 Gets the separator at the given index in this list.
 </summary>
	<param name="index">The index.</param><returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SeparatedSyntaxList`1.Insert(System.Int32,Roslyn.Compilers.VisualBasic.SyntaxKind,System.Boolean,`0[])">
	<summary> Insert one or more nodes in the list at the specified index.  If 
 includeTrailingSeparator is true and the items are inserted at the end of the list, then
 an additional seperator will be placed after all the items at the end.
 </summary>
	<returns>A new list with the nodes inserted.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SeparatedSyntaxList`1.ToString">
	<summary>
 Returns the string representation of the nodes in this list including separators but not including 
 the first node's leading trivia and the last node or token's trailing trivia.
 </summary>
	<returns>
 The string representation of the nodes in this list including separators but not including 
 the first node's leading trivia and the last node or token's trailing trivia.
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SeparatedSyntaxList`1.ToFullString">
	<summary>
 Returns the full string representation of the nodes in this list including separators, 
 the first node's leading trivia, and the last node or token's trailing trivia.
 </summary>
	<returns>
 The full string representation of the nodes in this list including separators including separators,
 the first node's leading trivia, and the last node or token's trailing trivia.
 </returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyntaxRewriter">
	<summary>
 Represents a <see cref="T:Roslyn.Compilers.VisualBasic.SyntaxVisitor`1"/> which descends an entire <see cref="T:Roslyn.Compilers.VisualBasic.SyntaxNode"/> graph and
 may replace or remove visited SyntaxNodes in depth-first order.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.VisualBasicLineDirectiveMap">
	<summary>
 Adds VB specific parts to the line directive map
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyntaxWalker">
	<summary>
 Represents a <see cref="T:Roslyn.Compilers.VisualBasic.SyntaxVisitor"/> that descends an entire <see cref="T:Roslyn.Compilers.VisualBasic.SyntaxNode"/> graph
 visiting each SyntaxNode and its child SyntaxNodes and <see cref="T:Roslyn.Compilers.VisualBasic.SyntaxToken"/>s in depth-first order.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyntaxVisitor">
	<summary>
 Represents a <see cref="T:Roslyn.Compilers.VisualBasic.SyntaxNode"/> visitor that visits only the single SyntaxNode
 passed into its <see cref="M:Roslyn.Compilers.VisualBasic.SyntaxVisitor.Visit(Roslyn.Compilers.VisualBasic.SyntaxNode)"/> method.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyntaxVisitor`1">
	<summary>
 Represents a <see cref="T:Roslyn.Compilers.VisualBasic.SyntaxNode"/> visitor that visits only the single SyntaxNode
 passed into its <see cref="M:Roslyn.Compilers.VisualBasic.SyntaxVisitor`1.Visit(Roslyn.Compilers.VisualBasic.SyntaxNode)"/> method and produces 
 a value of the type specified by the <typeparamref name="TResult"/> parameter.
 </summary>
	<typeparam name="TResult">
 The type of the return value this visitor's Visit method.
 </typeparam>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTriviaList.ToString">
	<summary>
 Returns the string representation of the trivia in this list, not including 
 the first trivia's leading sub-trivia or the last trivia's trailing sub-trivia
 if they are structured.
 </summary>
	<returns>
 The string representation of the trivia in this list, not including 
 the first trivia's leading sub-trivia or the last trivia's trailing sub-trivia
 if they are structured.
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTriviaList.ToFullString">
	<summary>
 Returns the full string representation of the trivia in this list including 
 the first trivia's leading sub-trivia and the last trivia's trailing sub-trivia
 even if they are structured.
 </summary>
	<returns>
 The full string representation of the trivia in this list including 
 the first trivia's leading sub-trivia and the last trivia's trailing sub-trivia
 even if they are structured.
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTriviaList.GetGreenNodeAt(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,System.Int32)">
	<summary>
 get the green node at the given slot
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.ParsedSyntaxTree.#ctor(Roslyn.Compilers.IText,System.String,Roslyn.Compilers.VisualBasic.CompilationUnitSyntax,Roslyn.Compilers.VisualBasic.ParseOptions,System.Int32)">
	<summary>
 Used to create new tree incrementally.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.ParsedSyntaxTree.GetReference(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Get a reference to the given node.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.ParsedSyntaxTree.WithChange(Roslyn.Compilers.IText,Roslyn.Compilers.TextChangeRange[])">
	<summary>
 Apply a text change to this syntax tree, returning a new syntax tree with the
 changes applied to it.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTree.ParsedSyntaxTree.ToString">
	<summary>
 Returns a <see cref="T:System.String"/> that represents the source code of this parsed tree.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyntaxTree.ParsedSyntaxTree">
	<summary>
 A SyntaxTree is a tree of nodes that represents an entire file of VB
 code, and is parsed by the parser.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNodeExtensions.ContainingWithStatement(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Find enclosing WithStatement if it exists.
 </summary>
	<param name="node"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNodeExtensions.ExtractAnonymousTypeMemberName(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.XmlNameSyntax@)">
	<summary>
 Simplified version of ExtractAnonymousTypeMemberName implemented on inner tokens.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNodeExtensions.AllAreMissing(System.Collections.Generic.IEnumerable{Roslyn.Compilers.VisualBasic.SyntaxNode},Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Returns true if all arguments are of the specified kind and they are also missing.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNodeExtensions.AllAreMissingIdentifierName(System.Collections.Generic.IEnumerable{Roslyn.Compilers.VisualBasic.SyntaxNode})">
	<summary>
 Returns true if all arguments are missing.
 </summary>
	<param name="arguments"></param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxNodeExtensions.QueryClauseKeywordOrRangeVariableIdentifier(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Given a syntax node of query clause returns its leading keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxList`1.ToString">
	<summary>
 Returns the string representation of the nodes in this list, not including 
 the first node's leading trivia and the last node's trailing trivia.
 </summary>
	<returns>
 The string representation of the nodes in this list, not including 
 the first node's leading trivia and the last node's trailing trivia.
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxList`1.ToFullString">
	<summary>
 Returns the full string representation of the nodes in this list including 
 the first node's leading trivia and the last node's trailing trivia.
 </summary>
	<returns>
 The full string representation of the nodes in this list including 
 the first node's leading trivia and the last node's trailing trivia.
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFactsExtensions.IsKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Determine if the token instance represents a reserved or contextual keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFactsExtensions.IsReservedKeyword(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Determine if the kind represents a reserved keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFactsExtensions.IsReservedKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Determine if the token instance represents a reserved keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFactsExtensions.IsContextualKeyword(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Determine if the kind represents a contextual keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFactsExtensions.IsContextualKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Determine if the token instance represents a contextual keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFactsExtensions.IsPreprocessorKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Determine if the token instance represents a preprocessor keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFactsExtensions.IsPreprocessorKeyword(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Determine if the token instance represents a preprocessor keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFactsExtensions.IsPredefinedType(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Helper to check whether the token is a predefined type
 </summary>
	<returns>True if it is a predefined type</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFactsExtensions.IsPredefinedTypeOrVariant(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Helper to check whether the token is a predefined type OR Variant keyword
 </summary>
	<returns>True if it is a predefined type OR Variant keyword</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFactsExtensions.IsInvoked(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Returns true if the node is the object of an invocation expression
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFactsExtensions.IsAddressOfOperand(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Returns true if the node is the operand of an AddressOf expression
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFactsExtensions.IsInvocationOrAddressOfOperand(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Returns true if the node is the operand of an AddressOf expression, or the object
 of an invocation. This is used for special binding rules around the return value variable 
 inside Functions and Property Get accessors.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFactsExtensions.InLambdaInterior(Roslyn.Compilers.VisualBasic.SyntaxNode,System.Int32)">
	<summary>
 Determines if possibleLambda is a lambda expression and position is in the interior.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFactsExtensions.IsNamedArgumentName(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Is the node the name of a named argument of an invocation or object creation expression, 
 but not an attribute.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFactsExtensions.GetBlockName(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Return keyword or punctuation text based on SyntaxKind
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFormatter.#ctor(System.String,System.Boolean,System.Boolean)">
	<summary>
 Creates a Syntax Formatter visitor
 </summary>
	<param name="indentWhitespace">The whitespace to indent with</param>
	<param name="useElasticTrivia">Whether to use elastic trivia or not</param>
	<param name="useDefaultCasing">Whether to rewrite keywords in default casing or not</param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFormatter.GetIndentationDepth(Roslyn.Compilers.VisualBasic.SyntaxToken,System.Int32)">
	<summary>
 indentation depth is the declaration depth for statements within the block. for start/end statements
 of these blocks (e.g. the if statement), it is a level less
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxExtensions.IsPartOfStructuredTrivia(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Determines if the node is a descendant of a structured trivia.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxExtensions.IsPartOfStructuredTrivia(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Determines if the token is a descendant of a structured trivia.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxExtensions.IsPartOfStructuredTrivia(Roslyn.Compilers.VisualBasic.SyntaxTrivia)">
	<summary>
 Determines if the trivia is a descendant of a structured trivia.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxExtensions.IsPartOfStructuredTrivia(Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken)">
	<summary>
 Determines if the node or token is a descendant of a structured trivia.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxExtensions.Type(Roslyn.Compilers.VisualBasic.NewExpressionSyntax)">
	<summary>
 Returns the TypeSyntax of the given NewExpressionSyntax if specified.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxExtensions.Type(Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Returns the TypeSyntax of the given AsClauseSyntax if specified.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxExtensions.Attributes(Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Returns the AttributeBlockSyntax of the given AsClauseSyntax if specified.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken.CollectConstituentTokensAndDiagnostics(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxListBuilder{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken},System.Collections.Generic.IList{Roslyn.Compilers.DiagnosticInfo})">
	<summary>
 Add this token to the token list builder.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken.IsKeyword">
	<summary>
 Helper to check whether the token is a keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken.IsBinaryOperator">
	<summary>
 Helpers to check whether the token is a binary operator
 </summary>
	<returns>True if it is a binary operator</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken.IsEndOfLine">
	<summary>
 Check whether the token is a statement terminator
 </summary>
	<returns>True if it is statement terminator</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken.IsEndOfParse">
	<summary>
 Check whether token is end of text
 </summary>
	<value></value>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken.AddLeadingTrivia``1(``0,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode})">
	<summary>
 Create a new token with the trivia prepended to the existing preceding trivia
 </summary>
	<typeparam name="T"></typeparam>
	<param name="token"></param>
	<param name="newTrivia"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken.AddTrailingTrivia``1(``0,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode})">
	<summary>
 Create a new token with the trivia appended to the existing following trivia
 </summary>
	<typeparam name="T"></typeparam>
	<param name="token"></param>
	<param name="newTrivia"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.Identifier(System.String,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Create an identifier node without brackets or type character.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.Identifier(System.String,Roslyn.Compilers.VisualBasic.SyntaxKind,System.Boolean,System.String,Roslyn.Compilers.VisualBasic.TypeCharacter,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Create an identifier node with brackets or type character.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.Identifier(System.String)">
	<summary>
 Create an identifier node without brackets or type character or trivia.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MissingIdentifier">
	<summary>
 Create a missing identifier.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MissingIdentifier(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Create a missing contextual keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MissingKeyword(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Create a missing keyword.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MissingPunctuation(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Create a missing punctutation mark.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MissingStringLiteral">
	<summary>
 Create a missing string literal.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MissingCharacterLiteralToken">
	<summary>
 Create a missing character literal.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MissingIntegerLiteralToken">
	<summary>
 Create a missing integer literal.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.MissingToken(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Creates a copy of a token.
 <para name="err"></para>
		<para name="trivia"></para>
	</summary>
	<returns>The new token</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndOfFileToken(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxTrivia)">
	<summary>
 Create an end-of-text token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Syntax.EndOfFileToken">
	<summary>
 Create an end-of-text token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IntegerLiteralTokenSyntax`1.Value">
	<summary>
 The value of the token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IntegerLiteralTokenSyntax.Base">
	<summary>
 Whether the token was specified in base 10, 16, or 8.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IntegerLiteralTokenSyntax.TypeSuffix">
	<summary>
 The type suffix or type character that was on the literal, if any. If no suffix
 was present, TypeCharacter.None is returned.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.IntegerLiteralTokenSyntax">
	<summary>
 Represents an integer literal token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FloatingLiteralTokenSyntax`1.Value">
	<summary>
 The value of the token.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.FloatingLiteralTokenSyntax`1">
	<summary>
 Represents an floating literal token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.FloatingLiteralTokenSyntax.TypeSuffix">
	<summary>
 The type suffix or type character that was on the literal, if any. If no suffix
 was present, TypeCharacter.None is returned.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.FloatingLiteralTokenSyntax">
	<summary>
 Represents an floating literal token.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode.FullWidth">
	<summary>
 The width of this item, in characters. Includes any associated trivia (whitespace/comments).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode.WriteTo(System.IO.TextWriter)">
	<summary>
 Append the full text of this node including children and trivia to the given stringbuilder.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode.CollectConstituentTokensAndDiagnostics(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxListBuilder{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxToken},System.Collections.Generic.IList{Roslyn.Compilers.DiagnosticInfo})">
	<summary>
 Add all the tokens in this node and children to the build token list builder. While doing this, add any
 diagnostics not on tokens to the given diagnostic info list.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode.ToString">
	<summary>
 Returns the string representation of this node, not including its leading and trailing trivia.
 </summary>
	<returns>The string representation of this node, not including its leading and trailing trivia.</returns>
	<remarks>The length of the returned string is always the same as Span.Length</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode.ToFullString">
	<summary>
 Returns full string representation of this node including its leading and trailing trivia.
 </summary>
	<returns>The full string representation of this node including its leading and trailing trivia.</returns>
	<remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode.AddError(Roslyn.Compilers.DiagnosticInfo)">
	<summary>
 Add an error to the given node, creating a new node that is the same except it has no parent,
 and has the given error attached to it. The error span is the entire span of this node.
 </summary>
	<param name="err">The error to attach to this node</param>
	<returns>A new node, with no parent, that has this error added to it.</returns>
	<remarks>Since nodes are immutable, the only way to create nodes with errors attached is to create a node without an error,
 then add an error with this method to create another node.</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode.GetSyntaxErrors">
	<summary>
 Get all syntax errors associated with this node, or any child nodes, grand-child nodes, etc. The errors
 are not in order.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleIdentifierSyntax.PossibleKeywordKind">
	<summary>
 Contextual Nodekind
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleIdentifierSyntax.IsBracketed">
	<summary>
 If true, the identifier was enclosed in brackets, such as "[End]".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleIdentifierSyntax.IdentifierText">
	<summary>
 The text of the identifier, not including the brackets or type character.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.SimpleIdentifierSyntax.TypeCharacter">
	<summary>
 The type character suffix, if present. Returns TypeCharacter.None if no type
 character was present. The only allowed values are None, Integer, Long,
 Decimal, Single, Double, and String.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.SeparatedSyntaxList`1.GetSeparator(System.Int32)">
	<summary>
 Gets the separator at the given index in this list.
 </summary>
	<param name="index">The index.</param><returns></returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax.PossibleKeywordKind">
	<summary>
 Contextual Nodekind
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax.IsBracketed">
	<summary>
 If true, the identifier was enclosed in brackets, such as "[End]".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax.IdentifierText">
	<summary>
 The text of the identifier, not including the brackets or type character.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax.TypeCharacter">
	<summary>
 The type character suffix, if present. Returns TypeCharacter.None if no type
 character was present. The only allowed values are None, Integer, Long,
 Decimal, Single, Double, and String.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax">
	<summary>
 Represents an identifier token. This might include brackets around the name,
 and a type character.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ComplexIdentifierSyntax.PossibleKeywordKind">
	<summary>
 Contextual Nodekind
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ComplexIdentifierSyntax.IsBracketed">
	<summary>
 If true, the identifier was enclosed in brackets, such as "[End]".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ComplexIdentifierSyntax.IdentifierText">
	<summary>
 The text of the identifier, not including the brackets or type character.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.InternalSyntax.ComplexIdentifierSyntax.TypeCharacter">
	<summary>
 The type character suffix, if present. Returns TypeCharacter.None if no type
 character was present. The only allowed values are None, Integer, Long,
 Decimal, Single, Double, and String.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Determine if the token instance represents a reserved or contextual keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsReservedKeyword(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Determine if the kind represents a reserved keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsReservedKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Determine if the token instance represents a reserved keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsContextualKeyword(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Determine if the kind represents a contextual keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsContextualKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Determine if the token instance represents a contextual keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsPreprocessorKeyword(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Determine if the token instance represents a preprocessor keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsTrivia(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Determine if the token instance represents a syntax trivia such as comment, whitespace, etc...
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsInstanceExpression(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Determine if the token instance represents 'Me', 'MyBase' or 'MyClass' keywords
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.GetInstanceExpression(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Return correspondent expression syntax for 'Me', 'MyBase' and 'MyClass' 
 keywords or SyntaxKind.None for other syntax kinds
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsPreprocessorKeyword(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Determine if the token instance represents a preprocessor keyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.GetKeywordKinds">
	<summary>
 Get all reserved and contextual keywords
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.GetReservedKeywordKinds">
	<summary>
 Get all reserved keywords
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.GetContextualKeywordKinds">
	<summary>
 Get contextual keywords
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.GetPunctuationKinds">
	<summary>
 Get punctuations
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.GetPreprocessorKeywordKinds">
	<summary>
 Get preprocessor keywords
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsPredefinedType(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Helper to check whether the token is a predefined type
 </summary>
	<returns>True if it is a predefined type</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsPredefinedTypeOrVariant(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Helper to check whether the token is a predefined type OR Variant keyword
 </summary>
	<returns>True if it is a predefined type OR Variant keyword</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsInvoked(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Returns true if the node is the object of an invocation expression
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsAddressOfOperand(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Returns true if the node is the operand of an AddressOf expression
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsInvocationOrAddressOfOperand(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Returns true if the node is the operand of an AddressOf expression, or the object
 of an invocation. This is used for special binding rules around the return value variable 
 inside Functions and Property Get accessors.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.InLambdaInterior(Roslyn.Compilers.VisualBasic.SyntaxNode,System.Int32)">
	<summary>
 Determines if possibleLambda is a lambda expression and position is in the interior.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.BeginOfBlockStatementIfAny(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 If "node" is a block statement return the Begin statement  of "node", otherwise return "node".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsAttributeName(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Checks if the SyntaxNode is an attribute name. To be an attribute name, the syntax
 must be parented by an Attribute and the node itself must be equal to the Attribute.Name
 property.
 </summary>
	<param name="node"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.IsNamedArgumentName(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Is the node the name of a named argument of an invocation or object creation expression, 
 but not an attribute.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.GetBlockName(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Return keyword or punctuation text based on SyntaxKind
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.AllowsTrailingImplicitLineContinuation(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Indicates whether a newline may validly follow the specified SyntaxToken without requiring an explicit line continuation sequence ' _' or terminating the containing statement.
 </summary>
	<param name="token">The token to test. This token must be parented by a SyntaxNode.</param>
	<returns>True if implicit line continuation is allowed after token.</returns>
	<remarks>
		<para>Refer to "Statements in Visual Basic", 2010 version, http://msdn.microsoft.com/en-us/library/865x40k4(v=vs.100).aspx 
 for examples.</para>
		<para>Implicit line continuation may be used in Visual Basic: </para>
		<list>
			<item>After a comma (,).</item>
			<item>After a less-than sign (&lt;) or before a greater-than sign (&gt;) when you specify an attribute.</item>
			<item>After an open parenthesis (() or before a closing parenthesis ()).</item>
			<item>After an open curly brace ({) or before a closing curly brace (}).</item>
			<item>After an open embedded expression (&lt;%=) or before the close of an embedded expression (%&gt;) within an XML literal.</item>
			<item>
				<para>Before and after query operators (Aggregate, Distinct, From, Group By, Group Join, Join, Let, 
 Order By, Select, Skip, Skip While, Take, Take While, Where, In, Into, On, Ascending, and Descending).</para>
				<para>You cannot break a line between the keywords of query operators that are made up of multiple keywords 
 (Order By, Group Join, Take While, and Skip While).</para>
			</item>
			<item>After the concatenation operator (&amp;).</item>
			<item>After assignment operators (=, &amp;=, :=, +=, -=, *=, /=, \=, ^=, &lt;&lt;=, &gt;&gt;=).</item>
			<item>After binary operators (+, -, /, *, Mod, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=, ^, &gt;&gt;, &lt;&lt;, And, AndAlso, Or, OrElse, Like, Xor) within an expression.</item>
			<item>After the Is and IsNot operators.</item>
			<item>After a less-than sign (&lt;) or before a greater-than sign (&gt;) when you specify an attribute.</item>
			<item>
				<para>Also after a greater-than sign (&gt;) when you specify an attribute.</para>
				<para>However, you must include a line-continuation character (_) when you specify assembly-level or module-level attributes.</para>
			</item>
			<item>
				<para>After a member qualifier character (.) and before the member name.</para>
				<para>However, you must include a line-continuation character (_) following a member qualifier character when you are using the With statement or 
 supplying values in the initialization list for a type.</para>
			</item>
			<item>
				<para>After an XML axis property qualifier (. or ...).</para>
				<para>However, you must include a line-continuation character (_) when you specify a member qualifier when you are using the With keyword.</para>
			</item>
			<item>After the From keyword in a collection initializer.</item>
			<item>After the With keyword in a member initializer.</item>
			<item>After the In keyword in a For Each statement.</item>
		</list>
	</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxFacts.AllowsLeadingImplicitLineContinuation(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Indicates whether a newline may validly precede the specified SyntaxToken without requiring an explicit line continuation sequence ' _' or terminating the containing statement.
 </summary>
	<param name="token">The token to test. This token must be parented by a SyntaxNode.</param>
	<returns>True if implicit line continuation is allowed after token.</returns>
	<remarks>
		<para>Refer to "Statements in Visual Basic", 2010 version, http://msdn.microsoft.com/en-us/library/865x40k4(v=vs.100).aspx 
 for examples.</para>
		<para>Implicit line continuation may be used in Visual Basic: </para>
		<list>
			<item>After a comma (,).</item>
			<item>After a less-than sign (&lt;) or before a greater-than sign (&gt;) when you specify an attribute.</item>
			<item>After an open parenthesis (() or before a closing parenthesis ()).</item>
			<item>After an open curly brace ({) or before a closing curly brace (}).</item>
			<item>After an open embedded expression (&lt;%=) or before the close of an embedded expression (%&gt;) within an XML literal.</item>
			<item>
				<para>Before and after query operators (Aggregate, Distinct, From, Group By, Group Join, Join, Let, 
 Order By, Select, Skip, Skip While, Take, Take While, Where, In, Into, On, Ascending, and Descending).</para>
				<para>You cannot break a line between the keywords of query operators that are made up of multiple keywords 
 (Order By, Group Join, Take While, and Skip While).</para>
			</item>
			<item>After the concatenation operator (&amp;).</item>
			<item>After assignment operators (=, &amp;=, :=, +=, -=, *=, /=, \=, ^=, &lt;&lt;=, &gt;&gt;=).</item>
			<item>After binary operators (+, -, /, *, Mod, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=, ^, &gt;&gt;, &lt;&lt;, And, AndAlso, Or, OrElse, Like, Xor) within an expression.</item>
			<item>After the Is and IsNot operators.</item>
			<item>After a less-than sign (&lt;) or before a greater-than sign (&gt;) when you specify an attribute.</item>
			<item>
				<para>Also after a greater-than sign (&gt;) when you specify an attribute.</para>
				<para>However, you must include a line-continuation character (_) when you specify assembly-level or module-level attributes.</para>
			</item>
			<item>
				<para>After a member qualifier character (.) and before the member name.</para>
				<para>However, you must include a line-continuation character (_) following a member qualifier character when you are using the With statement or 
 supplying values in the initialization list for a type.</para>
			</item>
			<item>
				<para>After an XML axis property qualifier (. or ...).</para>
				<para>However, you must include a line-continuation character (_) when you specify a member qualifier when you are using the With keyword.</para>
			</item>
			<item>After the From keyword in a collection initializer.</item>
			<item>After the With keyword in a member initializer.</item>
			<item>After the In keyword in a For Each statement.</item>
		</list>
	</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CompilationUnitSyntax.GetReferenceDirectives">
	<summary> 
 Returns #r directives specified in the compilation. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ChildSyntaxList.Occupancy(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 How many actual nodes is represented by a node (note that some nodes are lists).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax.Rank">
	<summary>
 Returns the ranks of this array rank specifier.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_LazyWellKnownTypes">
	<summary>
 An array of cached well known types available for use in this Compilation.
 Lazily filled by GetWellKnownType method.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_LazyWellKnownTypeMembers">
	<summary>
 Lazy cache of well known members.
 Not yet known value is represented by ErrorTypeSymbol.UnknownResultType
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.SynthesizeAttribute(Roslyn.Compilers.WellKnownMember,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.Common.CommonTypedConstant},Roslyn.Compilers.ReadOnlyArray{System.Collections.Generic.KeyValuePair{System.String,Roslyn.Compilers.Common.CommonTypedConstant}})">
	<summary> 
 Synthesizes a custom attribute.  
 Returns null if the <paramref name="constructor"/>  symbol is missing and the attribute is synthesized only if present.
  </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.GetWellKnownTypeMember(Roslyn.Compilers.WellKnownMember)">
	<summary>
 Lookup member declaration in well known type used by this Compilation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OptionsValidator.ParseImports(System.Collections.Generic.IEnumerable{System.String},Roslyn.Compilers.DiagnosticBag@)">
	<summary>
 Parse the project level imports, adding errors to the errorBag as necessary
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OptionsValidator.IsValidNamespaceName(System.String)">
	<summary>
 Validate and parse the root namespace. If the root namespace string is a valid namespace name, the parsed
 version is returned. Otherwise Nothing is returned.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OptionsValidator.IsValidRootNamespaceComponent(System.String,System.Boolean)">
	<summary>
 Check if a string is a valid component of the root namespace. We use the usual
 VB identifier rules, but don't check for keywords (this is the same as previous versions).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.OptionsValidator">
	<summary>
 This class is used to validate the compiler options.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeSymbol.BaseType">
	<summary>
 Gets the BaseType of this type. If the base type could not be determined, then 
 an instance of ErrorType is returned. If this kind of type does not have a base type
 (for example, interfaces), Nothing is returned. Also the special class System.Object
 always has a BaseType of Nothing.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeSymbol.Interfaces">
	<summary>
 Gets the set of interfaces that this type directly implements. This set does not
 include interfaces that are base interfaces of directly implemented interfaces.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeSymbol.AllInterfaces">
	<summary>
 The list of all interfaces of which this type is a declared subtype, excluding this type
 itself. This includes all declared base interfaces, all declared base interfaces of base
 types, and all declared base interfaces of those results (recursively).  Each result
 appears exactly once in the list. This list is topologically sorted by the inheritance
 relationship: if interface type A extends interface type B, then A precedes B in the
 list. This is not quite the same as "all interfaces of which this type is a proper
 subtype" because it does not take into account variance: AllInterfaces for
 IEnumerable(Of String) will not include IEnumerble(Of Object).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbol.MakeAllInterfaces">
 Produce all implemented interfaces in topologically sorted order. We use
 TypeSymbol.Interfaces as the source of edge data, which has had cycles and infinitely
 long dependency cycles removed. Consequently, it is possible (and we do) use the
 simplest version of Tarjan's topological sorting algorithm.

</member><member name="P:Roslyn.Compilers.VisualBasic.TypeSymbol.InterfacesAndTheirBaseInterfaces">
	<summary>
 Gets the set of interfaces that this type directly implements, plus the base interfaces
 of all such types.
 </summary>
	<remarks>
 CONSIDER: it probably isn't truly necessary to cache this.  If space gets tight, consider
 alternative approaches (recompute every time, cache on the side, only store on some types,
 etc).
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeSymbol.IsReferenceType">
	<summary>
 Returns true if this type is known to be a reference type. It is never the case
 that IsReferenceType and IsValueType both return true. However, for an unconstrained
 type parameter, IsReferenceType and IsValueType will both return false.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeSymbol.IsValueType">
	<summary>
 Returns true if this type is known to be a value type. It is never the case
 that IsReferenceType and IsValueType both return true. However, for an unconstrained
 type parameter, IsReferenceType and IsValueType will both return false.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeSymbol.IsAnonymousType">
	<summary>
 Is this a symbol for an anonymous type (including delegate).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeSymbol.TypeKind">
	<summary>
 Gets the kind of this type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeSymbol.SpecialType">
	<summary>
 Gets corresponding special TypeId of this type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeSymbol.PrimitiveTypeCode">
	<summary>
 Gets corresponding primitive type code for this type declaration.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbol.InternalSubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbol.LookupMetadataType(Roslyn.Compilers.Internal.MetadataTypeName@)">
	<summary>
 Lookup an immediately nested type referenced from metadata, names should be
 compared case-sensitively.
 </summary>
	<param name="emittedTypeName">
 Type name.
 </param>
	<returns>
 Symbol for the type, or MissingMetadataSymbol if the type isn't found.
 </returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbol.GetUseSiteErrorInfo">
	<summary>
 Returns error info for an error, if any, that should be reported at the use site of the symbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbol.GetUseSiteErrorInfo(System.Collections.Generic.HashSet{Roslyn.Compilers.VisualBasic.TypeSymbol}@)">
	<summary>
 Has the same purpose as the one above, but carries a hash set of types that are being checked or have been checked
 already in order to avoid duplicate work and, more importantly, avoid infinite loops due to cyclic type references.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeSymbol.HighestPriorityUseSiteError">
	<summary>
 Return error code that has highest priority while calculating use site error for this symbol. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbol.FindImplementationForInterfaceMember(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Returns the corresponding symbol in this type or a base type that implements 
 interfaceMember (either implicitly or explicitly), or null if no such symbol 
 exists (which might be either because this type doesn't implement the container 
 of interfaceMember, or this type doesn't supply a member that successfully 
 implements interfaceMember).
 </summary>
	<param name="interfaceMember">
 Must be a non-null interface property, method, or event.
 </param>
	<returns>The implementing member.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbol.ComputeImplementationForInterfaceMember(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Compute the implementation for an interface member in this type, or Nothing if none.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeSymbol">
	<summary>
 A TypeSymbol is a base class for all the symbols that represent a type
 in Visual Basic.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeSubstitution._pairs">
	<summary>
 A map between type parameters of _targetGenericDefinition and corresponding type arguments.
 Represented by an array of Key-Value pairs. Keys are type parameters of _targetGenericDefinition 
 in no particular order. Identity substitutions are omitted. 
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeSubstitution._targetGenericDefinition">
	<summary>
 Definition of a symbol which this instance of TypeSubstitution primarily targets.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeSubstitution._parent">
	<summary>
 An instance of TypeSubstitution describing substitution for containing type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeSubstitution.PairsIncludingParent">
	<summary>
 Get all the pairs of substitutions, including from the parent substitutations. The substutitions
 are in order from outside-in (parent substutitions before child substitutions).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.ThrowIfSubstitutingToAlphaRenamedTypeParameter">
	<summary>
 Verify TypeSubstitution to make sure it dosn't map any 
 type parameter to an alpha-renamed type parameter.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.GetSubstitutionForGenericDefinition(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Return TypeSubstitution instance that targets particular generic definition.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.GetSubstitutionForGenericDefinitionOrContainers(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Return TypeSubstitution instance that targets particular
 generic definition or one of its containers.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.IsValidToApplyTo(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Does substitution target either genericDefinition or 
 one of its containers?
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.Concat(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.TypeSubstitution,Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Combine two substitutions into one by concatinating. 
 
 They may not directly or indirectly (through Parent) target the same generic definition.
 sub2 is expected to target types lower in the containership hierarchy.
 Either or both can be Nothing. 
 
 targetGenericDefinition specifies target generic definition for the result. 
 If sub2 is not Nothing, it must target targetGenericDefinition.
 If sub2 is Nothing, sub1 will be "extended" with identity substitutions to target 
 targetGenericDefinition.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.Create(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.TypeParameterSymbol[],Roslyn.Compilers.VisualBasic.TypeSymbol[],System.Boolean)">
	<summary>
 Create a substitution. If the substitution is the identity substitution, Nothing is returned.
 </summary>
	<param name="targetGenericDefinition">Generic definition the result should target.</param>
	<param name="params">
 Type parameter definitions. Duplicates aren't allowed. Type parameters of containing type
 must precede type parameters of a nested type.  
 </param>
	<param name="args">Corresponding type arguments.</param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.Create(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeParameterSymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol},System.Boolean)">
	<summary>
 Create a substitution. If the substitution is the identity substitution, Nothing is returned.
 </summary>
	<param name="targetGenericDefinition">Generic definition the result should target.</param>
	<param name="params">
 Type parameter definitions. Duplicates aren't allowed. Type parameters of containing type
 must precede type parameters of a nested type.  
 </param>
	<param name="args">Corresponding type arguments.</param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.Concat(Roslyn.Compilers.VisualBasic.TypeSubstitution,Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.ReadOnlyArray{System.Collections.Generic.KeyValuePair{Roslyn.Compilers.VisualBasic.TypeParameterSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol}})">
	<summary>
 Private helper to make sure identity substitutions are injected for types between 
 targetGenericDefinition and parent.TargetGenericDefinition.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.CreateForAlphaRename(Roslyn.Compilers.VisualBasic.TypeSubstitution,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeParameterSymbol})">
	<summary>
 Create substitution to handle alpha-renaming of type parameters. 
 It maps type parameter definition to corresponding alpha-renamed type parameter.
 </summary>
	<param name="alphaRenamedTypeParameters">Alpha-renamed type parameters.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.CreateAdditionalMethodTypeParameterSubstitution(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol})">
	<summary>
 Create TypeSubstitution that can be used to substitute method's type parameters
 in types involved in method's signature. 
 
 Unlike for other contruction methods in this class, targetMethod doesn't have to be 
 original definition, it is allowed to be specialized unconstructed generic method.
 
 An item in typeArguments can be an alpha-renamed type parameter, but it must belong
 to the targetMethod and can only appear at its ordinal position to represent the lack
 of substitution for it.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.AdjustForConstruct(Roslyn.Compilers.VisualBasic.TypeSubstitution,Roslyn.Compilers.VisualBasic.TypeSubstitution,Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Adjust substitution for construction.
 This has the following effects:
     1) The passed in additionalSubstitution is used on each type argument.
     2) If any parameters in the given additionalSubstitution are not present in oldConstructSubstitution, they are added.
     3) Parent substitution in oldConstructSubstitution is replaced with adjustedParent. 
 
 oldConstructSubstitution can be cancelled out by additionalSubstitution. In this case, 
 if the adjustedParent is Nothing, Nothing is returned.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.PrivateAdjustForConstruct(Roslyn.Compilers.ArrayBuilder{System.Collections.Generic.KeyValuePair{Roslyn.Compilers.VisualBasic.TypeParameterSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol}},Roslyn.Compilers.VisualBasic.TypeSubstitution,Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 This has the following effects:
     1) The passed in additionalSubstitution is used on each type argument.
     2) If any parameters in the given additionalSubstitution are not present in oldConstructSubstitution, they are added.
 
 Result is placed into pairs. Identity substitutions are omitted.
 
 Returns True if the set of pairs have changed, False otherwise.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSubstitution.Create(Roslyn.Compilers.VisualBasic.TypeSubstitution,Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol},System.Boolean)">
	<summary>
 Create substitution for targetGenericDefinition based on its type 
 arguments (matched to type parameters by position) and TypeSubstitution
 for direct or indirect container.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeSubstitution">
	<summary>
 Immutable. Thread-safe.
 
 Represents a type substitution, with substitutions of types for a set of type parameters.
 Each TypeSubstitution object has three pieces of information:
    - OriginalDefinition of generic symbol the substitution is targeting.
    - An array of pairs that provide a mapping from symbol's type parameters to type arguments.
      identity substitutions are omitted.
    - TypeSubstitution object for containing type to provide mapping for its type
      parameters, if any. 
 
 The identity substitution (for the whole type hierarchy) is represented by Nothing. That said,
 top level parent of non-Nothing instance of TypeSubstitution is guaranteed to be non-identity 
 substitution. The instance may still be an identity substitution just for target generic definition,
 which will be represented by an empty mapping array. 
 
 The chain of TypeSubstitution objects is guaranteed to not skip any type in the containership hierarchy,
 even types with zero arity contained in generic type will have corresponding TypeSubstitution object with
 empty mapping array.
 
 Example:
     Class A(Of T,S)
          Class B
              Class C(Of U)
              End Class
          End Class
     End Class 
 
 TypeSubstitution for A(Of Integer, S).B.C(Of Byte) is C{U-&gt;Byte}=&gt;B{}=&gt;A{T-&gt;Integer}
 TypeSubstitution for A(Of T, S).B.C(Of Byte) is C{U-&gt;Byte}
 TypeSubstitution for A(Of Integer, S).B is B{}=&gt;A{T-&gt;Integer}
 TypeSubstitution for A(Of Integer, S).B.C(Of U) is C{}=&gt;B{}=&gt;A{T-&gt;Integer}
 
 CONSIDER:
     An array of KeyValuePair(Of TypeParameterSymbol, TypeSymbol)objects is used to represent type 
     parameter substitution mostly due to historical reasons. It might be more convenient and more 
     efficient to use ordinal based array of TypeSymbol objects instead.

 There is a Construct method that can be called on original definition with TypeSubstitution object as
 an argument. The advantage of that method is the ability to substitute type parameters of several types  
 in the containership hierarchy in one call. What type the TypeSubstitution parameter targets makes a 
 difference.
 
 For example:
      C.Construct(C{}=&gt;B{}=&gt;A{T-&gt;Integer}) == A(Of Integer, S).B.C(Of U)
      C.Construct(B{}=&gt;A{T-&gt;Integer}) == A(Of Integer, S).B.C(Of )
      B.Construct(B{}=&gt;A{T-&gt;Integer}) == A(Of Integer, S).B
 
 See comment for IsValidToApplyTo method as well.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterSymbol.Ordinal">
	<summary>
 Gets the ordinal order of this type parameter. The first type parameter has ordinal zero.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterSymbol.ConstraintTypes">
	<summary>
 Get the types that were directly specified as constraints on this type parameter.
 Duplicates and cycles are removed, although the collection may include redundant
 constraints where one constraint is a base type of another.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterSymbol.HasConstructorConstraint">
	<summary>
 Returns whether the parameterless constructor constraint was specified.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterSymbol.IsMethodTypeParameter">
	<summary>
 True if this a type parameter for a generic method
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterSymbol.DeclaringMethod">
	<summary>
 The method that declares this type parameter 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterSymbol.DeclaringType">
	<summary>
 The type that declares this type parameter
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterSymbol.EnsureAllConstraintsAreResolved">
	<summary>
 Called by ConstraintTypes and Interfaces
 to allow derived classes to ensure constraints within the containing
 type or method are resolved in a consistent order, regardless of the
 order the callers query individual type parameters.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterSymbol.EnsureAllConstraintsAreResolved(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeParameterSymbol})">
	<summary>
 Helper method to force type parameter constraints to be resolved.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterSymbol.GetConstraints(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.TypeParameterConstraint})">
	<summary>
 Get all constraints, with optional source location for each. This method
 is provided for constraint checking only, and should only be invoked
 for SourceTypeParameterSymbol or ErrorTypeParameterSymbol directly.
 There is currently no need to invoke this method for PETypeParameterSymbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterSymbol.ResolveConstraints(Roslyn.Utilities.ConsList{Roslyn.Compilers.VisualBasic.TypeParameterSymbol})">
	<summary>
 Resolve constraints, binding and checking for conflicts as necessary. This is an
 internal method for resolving dependent sets of constraints and handling cycles.
 It will be called indirectly for core implementations (SourceTypeParameterSymbol and
 PETypeParameterSymbol) as a result of accessing constraint properties on this class.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterSymbol.InternalSubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeParameterSymbol.ReducedFromDefinition">
	<summary>
 If this is a type parameter of a reduced extension method, gets the type parameter definition that
 this type parameter was reduced from. Otherwise, returns Nothing.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeParameterSymbol.InternalSubstituteTypeParametersDistinct(Roslyn.Compilers.VisualBasic.TypeSubstitution,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol})">
	<summary>
 Return an array of substituted type parameters with duplicates removed.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeParameterSymbol">
	<summary>
 Represents a type parameter in a generic type or generic method.
 TODO: Should document how the BaseType and Interfaces members behave.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolVisitor`2.Visit(Roslyn.Compilers.VisualBasic.Symbol,`0)">
	<summary>
 Call the correct VisitXXX method in this class based on the particular type of symbol that is passed in.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SymbolVisitor`2">
	<summary>
 Virtual dispatch based on a symbol's particular class. 
 </summary>
	<typeparam name="TResult">Result type</typeparam>
	<typeparam name="TArgument">Additional argument type</typeparam>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolExtensions.GetKindText(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 String such as 'class', 'interface' etc that can be used in error messages.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolExtensions.GetPropertyKindText(Roslyn.Compilers.VisualBasic.PropertySymbol)">
	<summary>
 String "ReadOnly", "WriteOnly", or "" describing the kind of property.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolExtensions.MatchesAnyName(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeParameterSymbol},System.String)">
	<summary>
 Checks if there is a name match with any type parameter.
 </summary>
	<param name="this"></param>
	<param name="name"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolExtensions.IsOverloadable(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Returns true if this symbols can overload another of the same kind.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolExtensions.IsOverloadable(Roslyn.Compilers.VisualBasic.PropertySymbol)">
	<summary>
 Returns true if this property can overload another.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolExtensions.IsOverloads(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Helper that tells if symbol has Overloads (hidebysig) on it
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolExtensions.IsShadows(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Member that does not have Overloads, is considered Shadows (hidebyname)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolExtensions.IsInstanceMember(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Is the symbol an instance member (i.e. access requires a receiver)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolExtensions.RequiresImplementation(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Is this a member of a interface that requires implementation?
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolExtensions.IsPropertyAndNotWithEvents(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Returns True for "regular" properties (those that are not WithEvents.
 Typically used for OHI diagnostics where WithEvents properties are treated as variables.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolExtensions.OverriddenMember(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Return the overridden symbol for either a method or property.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolExtensions.GetDocumentationCommentID(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Returns the Documentation Comment ID for the symbol.
 </summary>
	<exception cref="T:System.InvalidOperationException">Thrown if the symbol does not support
 documentation comments.</exception>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolExtensions.GetArity(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary> 
 Return the arity of a member. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolExtensions.IsUserDefinedOperator(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Is symbol a user-defined operator method.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolExtensions.IsHiddenByEmbeddedAttribute(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Does symbol or its containing type have Microsoft.VisualBasic.Embedded() attribute
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeData.AttributeClass">
	<summary>
 The attribute class.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeData.AttributeConstructor">
	<summary>
 The constructor on the attribute class.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeData.ConstructorArguments">
	<summary>
 Constructor arguments on the attribute.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeData.NamedArguments">
	<summary>
 Named (property value) arguments on the attribute. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeData.IsConditionallyOmitted">
	<summary>
 Attribute is conditionally omitted if it is a source attribute and both the following are true:
 (a) It has at least one applied conditional attribute AND
 (b) None of conditional symbols are true at the attribute source location.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributeData.IsTargetAttribute(System.String,System.String,System.Boolean)">
	<summary>
 Compares the namespace and type name with the attribute's namespace and type name.  Returns true if they are the same.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributeData.IsTargetEarlyAttribute(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.AttributeSyntax,Roslyn.Compilers.AttributeDescription)">
	<summary>
 Checks if an applied attribute with the given attributeType matches the namespace name and type name of the given early attribute's description
 and the attribute description has a signature with parameter count equal to the given attribute syntax's argument list count.
 NOTE: We don't allow early decoded attributes to have optional parameters.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributeData.ToString">
	<summary>
 Returns the System.String that represents the current AttributeData.
 </summary>
	<returns>A System.String that represents the current AttributeData.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributeData.DecodePermissionSetAttribute(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Compilation,Roslyn.Compilers.Common.DecodeWellKnownAttributeArguments{Roslyn.Compilers.VisualBasic.AttributeSyntax,Roslyn.Compilers.VisualBasic.AttributeData,Roslyn.Compilers.VisualBasic.AttributeLocation}@)">
	<summary>
 Decodes PermissionSetAttribute applied in source to determine if it needs any fixup during codegen.
 </summary>
	<remarks>
 PermissionSetAttribute needs fixup when it contains an assignment to the 'File' property as a single named attribute argument.
 Fixup performed is ported from SecurityAttributes::FixUpPermissionSetAttribute at ndp\clr\src\vm\securityattributes.cpp.
 It involves following steps:
  1) Verifying that the specified file name resolves to a valid path.
  2) Reading the contents of the file into a byte array.
  3) Convert each byte in the file content into two bytes containing hexa-decimal characters.
  4) Replacing the 'File = fileName' named argument with 'Hex = hexFileContent' argument, where hexFileContent is the converted output from step 3) above.

 Step 1) is performed in this method, i.e. during binding.
 Remaining steps are performed during serialization as we want to avoid retaining the entire file contents throughout the binding/codegen pass.
 See <see cref="T:Roslyn.Compilers.CodeGen.PermissionSetAttributeWithFileReference"/> for remaining fixup steps.
 </remarks>
	<returns>String containing the resolved file path if PermissionSetAttribute needs fixup during codegen, null otherwise.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributeData.ShouldEmitAttribute(Roslyn.Compilers.VisualBasic.Symbol,System.Boolean)">
	<summary>
  This method determines if an applied attribute must be emitted. 
 Some attributes appear in symbol model to reflect the source code, but should not be emitted.
  </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AttributeData">
	<summary>
 A Symbol attribute represents a .NET attribute applied to a symbol.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.Name">
	<summary>
 Gets the name of this symbol.
 </summary>
	<returns>Returns the name of this symbol. Symbols without a name return the empty string;
 Nothing is never returned.</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.MetadataName">
	<summary>
 Gets the name of a symbol as it appears in metadata. Most of the time, this
 is the same as the Name property, with the following exceptions:
 1) The metadata name of generic types includes the "`1", "`2" etc. suffix that
 indicates the number of type parameters (it does not include, however, names of
 containing types or namespaces).
 2) The metadata name of methods that overload or override methods with the same
 case-insensitive name but different case-sensitive names are adjusted so that
 the overrides and overloads always have the same name in a case-sensitive way.
 
 It should be noted that Visual Basic merges namespace declaration from source
 and/or metadata with different casing into a single namespace symbol. Thus, for
 namespace symbols this property may return incorrect information if multiple declarations
 with different casing were found.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.SetMetadataName(System.String)">
	<summary>
 Set the metadata name for this symbol.
 Called from <see cref="M:Roslyn.Compilers.VisualBasic.OverloadingHelper.SetMetadataNameForAllOverloads(System.String,Roslyn.Compilers.VisualBasic.SymbolKind,Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol)"/> for each symbol of the same name in a type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.Kind">
	<summary>
 Gets the kind of this symbol.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.ContainingSymbol">
	<summary>
 Get the symbol that logically contains this symbol. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.ContainingNamespace">
	<summary>
 Gets the nearest enclosing namespace for this namespace or type. For a nested type,
 returns the namespace that contains its container.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.ContainingType">
	<summary>
 Returns the nearest lexically enclosing type, or Nothing if there is none.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.ContainingNamespaceOrType">
	<summary>
 Returns the containing type or namespace, if this symbol is immediately contained by it.
 Otherwise returns Nothing.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.ContainingAssembly">
	<summary>
 Returns the assembly containing this symbol. If this symbol is shared
 across multiple assemblies, or doesn't belong to an assembly, returns Nothing.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.ContainingModule">
	<summary>
 Returns the module containing this symbol. If this symbol is shared
 across multiple modules, or doesn't belong to a module, returns Nothing.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.OriginalDefinition">
	<summary>
 Get the original definition of this symbol. If this symbol is derived from another
 symbol by (say) type substitution, this gets the original symbol, as it was defined
 in source or metadata.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.IsDefinition">
	<summary>
 Returns whether this the original definition of this symbol.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.Locations">
	<summary>
 Gets the locations where this symbol was originally defined, either in source
 or metadata. Some symbols (for example, partial classes) may be defined in more
 than one location.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.DeclaringSyntaxNodes">
	<summary>
 Get the syntax node(s) where this symbol was declared in source. Some symbols (for example,
 partial classes) may be defined in more than one location. This property should return
 one or more syntax nodes only if the symbol was declared in source code and also was
 not implicitly declared (see the IsImplicitlyDeclared property). 
 
 Note that for namespace symbol, the declaring syntax might be declaring a nested namespace.
 For example, the declaring syntax node for N1 in "Namespace N1.N2" is the 
 NamespaceDeclarationSyntax for N1.N2. For the project namespace, the declaring syntax will
 be the CompilationUnitSyntax.
 </summary>
	<returns>
 The syntax node(s) that declared the symbol. If the symbol was declared in metadata
 or was implicitly declared, returns an empty read-only array.
 </returns>
	<remarks>
 To go the opposite direction (from syntax node to symbol), see <see cref="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,System.Threading.CancellationToken)"/>.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.GetDeclaringSyntaxNodeHelper``1(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.Location})">
	<summary> 
 Helper for implementing DeclaringSyntaxNodes for derived classes that store a location but not a  SyntaxNode or SyntaxReference. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.GetDeclaringSyntaxNodeHelper(System.Collections.Generic.IEnumerable{Roslyn.Compilers.VisualBasic.SyntaxReference})">
	<summary> 
 Helper for implementing DeclaringSyntaxNodes for derived classes that store SyntaxReferences. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.DeclaredAccessibility">
	<summary>
 Get this accessibility that was declared on this symbol. For symbols that do
 not have accessibility declared on them, returns NotApplicable.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.IsShared">
	<summary>
 Returns true if this symbol is "shared"; i.e., declared with the "Shared"
 modifier or implicitly always shared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.IsOverridable">
	<summary>
 Returns true if this member is overridable, has an implementation,
 and does not override a base class member; i.e., declared with the "Overridable"
 modifier. Does not return true for members declared as MustOverride or Overrides.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.IsOverrides">
	<summary>
 Returns true if this symbol was declared to override a base class members; i.e., declared
 with the "Overrides" modifier. Still returns true if the members was declared
 to override something, but (erroneously) no member to override exists.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.IsMustOverride">
	<summary>
 Returns true if this symbol was declared as requiring an override; i.e., declared
 with the "MustOverride" modifier. Never returns true for types. 
 Also methods, properties and events declared in interface are considered to have MustOveride.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.IsNotOverridable">
	<summary>
 Returns true if this symbol was declared to override a base class members and was
 also restricted from further overriding; i.e., declared with the "NotOverridable"
 modifier. Never returns true for types.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.IsImplicitlyDeclared">
	<summary>
 Returns true if this symbol was automatically created by the compiler, and does not
 have an explicit corresponding source code declaration.  
 
 This is intended for symbols that are ordinary symbols in the language sense,
 and may be used by code, but that are simply declared implicitly rather than
 with explicit language syntax.
 
 Examples include (this list is not exhaustive):
   the default constructor for a class or struct that is created if one is not provided,
   the BeginInvoke/Invoke/EndInvoke methods for a delegate,
   the generated backing field for an auto property or a field-like event,
   this "this" parameter for non-static methods,
   the "value" parameter for a property setter,
   the parameters on indexer accessor methods (not on the indexer itself),
   methods in anonymous types
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.ImplicitlyDefinedBy(Roslyn.Compilers.VisualBasic.MembersInProgress)">
	<summary>
 Returns the symbol that implicitly defined this symbol, or Nothing if this
 symbol was declared explicitly. Examples of implicit symbols are property
 accessors and the backing field for an automatically implemented property.
 
 NOTE: there are scenarios in which ImplicitlyDefinedBy is called while bound members 
       are not yet published. Ths typically happens if ImplicitlyDefinedBy while binding members.
       In such case, if calee needs to refer to a member of enclosing type it must 
       do that in the context of unpublished members that caller provides 
       (asking encompassing type for members will cause infinite recursion).
 
 NOTE: There could be several threads trying to bind and publish members, only one will succeed.
       Reporting ImplicitlyDefinedBy withing the set of members known to the caller guarantees
       that if particular thread succeeds it will not have information that refers to something
       built by another thread and discarded.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.ShadowsExplicitly">
	<summary> 
 Returns true if 'Shadows' is explicitly specified on the declaration if the symbol is from
 source, or in cases of synthesized symbols, if 'Shadows' is specified on the associated
 source symbol. (For instance, ShadowsExplicitly will be set on the backing fields and
 accessors for properties and events based on the value from the property or event.)
 Returns false in all other cases, in particular, for symbols not from source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.CanBeReferencedByName">
	<summary>
 Returns true if this symbol can be referenced by its name in code. Examples of symbols
 that cannot be referenced by name are:
    constructors, operators, 
    accessor methods for properties and events.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.CanBeReferencedByNameIgnoringIllegalCharacters">
	<summary>
 As an optimization, viability checking in the lookup code should use this property instead
 of CanBeReferencedByName.
 </summary>
	<remarks>
 This property exists purely for performance reasons.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.IsEmbedded">
	<summary>
 Is this a symbol that is generated by the compiler and
 automatically added to the compilation? Note that
 only source symbols may be embedded symbols. 
 
 Namespace symbol is considered to be an embedded symbol
 if at least one of its declarations are embedded symbols.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.IsFromSource">
	<summary>
 True if and only if the symbol is the one original symbol resulting from some
 declaration in the source. The declaration might be implicit, for example a synthesized
 constructor is considered to come from source. Constructed and substituted symbols
 are from source if their original symbol is from source. ErrorTypeSymbols are
 never from source. Array types and pointer types never return true for this property, 
 as they are not "declared" in the source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.IsLambdaMethod">
	<summary>
 Equivalent to MethodKind = MethodKind.LambdaMethod, but can be called on a symbol directly.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.IsQueryLambdaMethod">
	<summary>
 Is this lambda method a query lambda? 
 If it is, IsLambdaMethod == True as well.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.GetDocumentationComment(System.Globalization.CultureInfo,System.Threading.CancellationToken)">
	<summary>
 Fetches the documentation comment for this element with a cancellation token.
 </summary>
	<returns>A DocumentationComment object.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.op_Equality(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Compare two symbol objects to see if they refer to the same symbol. You should always use
 = and &lt;&gt; or the Equals method, to compare two symbols for equality.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.op_Inequality(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Compare two symbol objects to see if they refer to the same symbol. You should always use
 = and &lt;&gt;, or the Equals method, to compare two symbols for equality.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.IFormattable_ToString(System.String,System.IFormatProvider)">
	<summary>
 This is intended primarily for inserting localized descriptions of symbols into
 user-facing error messages.  If you need more fine-grained control of the output, try
 calling Symbol.ToDisplayString directly.
 </summary>
	<remarks>
 Generally speaking, this method should not be called directly.  Instead, they should be
 passed directly to errors/diagnostics.  To use a different format string, update the
 error message (e.g. Change "Problem with {0}" to "Problem with {0:S}" to display the
 short name of a symbol).
 
 We could have subclasses do their own parsing of the format string (to accept other
 formats), but we can probably do everything from here using Symbol.Kind.
 </remarks>
	<param name="format">
     G - general: default (determined by SymbolDisplay.ToDisplayString)
     E - error: format to be used in compiler error messages
     T - test: includes lots of qualification, parameters, modifiers, etc
     S - short: just the (user-facing) name of the symbol
     I - IL: to be used when visualizing IL
 </param>
	<param name="formatProvider">Usually a CultureInfo object.</param>
	<returns>A description of this symbol.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.GetUseSiteErrorInfo">
	<summary>
 Returns error info for an error, if any, that should be reported at the use site of the symbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.DeriveUseSiteErrorInfoFromType(Roslyn.Compilers.VisualBasic.TypeSymbol,System.Collections.Generic.HashSet{Roslyn.Compilers.VisualBasic.TypeSymbol}@)">
	<summary>
 Derive error info from a type symbol.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Symbol.HighestPriorityUseSiteError">
	<summary>
 Return error code that has highest priority while calculating use site error for this symbol. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Symbol">
	<summary>
 The base class for all symbols (namespaces, classes, method, parameters, etc.) that are 
 exposed by the compiler.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SubstitutedNamedType._substitution">
	<summary>
 Type substitution for this symbol, it targets OriginalDefinition of the symbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.EqualsWithNoRegardToTypeArguments``1(``0)">
	<summary>
 Compare SubstitutedNamedTypes with no regard to type arguments.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.SpecializedType._container">
	<summary>
  Symbol for the containing type, either specialized or constructed.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.SpecializedType">
	<summary>
 Base class for symbols representing non-generic or open generic types contained within constructed generic type.
 For example: A(Of Integer).B, A(Of Integer).B.C or A(Of Integer).B.C(Of ).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.SpecializedGenericType._typeParameters">
	<summary>
 Alpha-renamed type parameters, i.e. type parameters with constraints substituted according
 to containing type's TypeSubstitution.
 For example:
     Class A (Of T)
         Class B(Of S As T)
             Dim x As A(Of Integer).B(Of S) 'error BC32044: Type argument 'S' does not inherit from or implement the constraint type 'Integer'.
         End Class
     End Class
  
 Given a type A(Of IComparable).B(Of ), alpha-renamed type parameter S will have type constraint IComparable.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.SpecializedGenericType.InternalSubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.SpecializedGenericType">
	<summary>
 Symbol representing open generic type directly or indirectly contained within constructed
 generic type.
 For example: A(Of Integer).B(Of ) or A(Of Integer).B.C(Of , )
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.SpecializedNonGenericType.InternalSubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.SpecializedNonGenericType">
	<summary>
 Symbol representing non-generic type directly or indirectly contained within constructed
 generic type.
 For example: A(Of Integer).B or A(Of Integer).B.C
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.ConstructedType">
	<summary>
 Base class for symbols representing constructed generic types.
 For example: A(Of Integer), A.B(Of Integer), A(Of Integer).B.C(Of Integer).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.ConstructedInstanceType.InternalSubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.ConstructedInstanceType">
	<summary>
 Symbols representing constructed generic type that isn't contained within another constructed generic type.
 For example: A(Of Integer), A.B(Of Integer), but not A(Of Integer).B.C(Of Integer).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.ConstructedSpecializedGenericType._constructedFrom">
	<summary>
 Symbol for the ConstructedFrom type.
      A(Of Integer).B(Of ) for A(Of Integer).B(Of Integer),
      A(Of Integer).B.C(Of ) for A(Of Integer).B.C(Of Integer)
 
 All types in its containership hierarchy must be either constructed or non-generic, or original definitions.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.ConstructedSpecializedGenericType.InternalSubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.ConstructedSpecializedGenericType">
	<summary>
 Symbols representing constructed generic type that is contained within another constructed generic type.
 For example: A(Of Integer).B(Of Integer), A(Of Integer).B.C(Of Integer).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SubstitutedNamedType.GenerateAllDeclarationErrors(System.Threading.CancellationToken)">
	<summary>
 Force all declaration errors to be generated.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedNamedType">
	<summary>
 A SubstitutedNamedType represents a named type that has had some sort
 of substitution applied to it. I.e., its not a pure instance type, but at least
 one type parameter in this type or a containing type has a substitution made for
 it. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbolExtensions.IsNotInheritable(Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Return true if nothing can inherit or implement this type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbolExtensions.DigThroughArrayType(Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Dig through possibly jugged array type to the ultimate element type
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbolExtensions.IsValidTypeForConstField(Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Determines whether the given type is valid for a const field.
 VB Spec 9.5: The type of a constant may only be a primitive type or Object
 </summary>
	<param name="fieldType">The type of the field.</param><returns>
		<c>true</c> if type is valid for a const field; otherwise, <c>false</c>.
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbolExtensions.VisitType``1(Roslyn.Compilers.VisualBasic.TypeSymbol,System.Func{Roslyn.Compilers.VisualBasic.TypeSymbol,``0,System.Boolean},``0)">
	<summary>
 Visit the given type and, in the case of compound types, visit all "sub type"
 (such as A in A(), or { A(Of T), T, U } in A(Of T).B(Of U)) invoking 'predicate'
 with the type and 'arg' at each sub type. If the predicate returns true for any type,
 traversal stops and that type is returned from this method. Otherwise if traversal
 completes without the predicate returning true for any type, this method returns null.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbolExtensions.IsValidTypeForAttributeArgument(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Compilation)">
	<summary>
 Determines if the type is a valid type for a custom attribute argument
 </summary>
	<param name="type"></param>
	<param name="compilation"></param>
	<returns></returns>
	<remarks>
  The only valid types are 
 1. primitive types except date and decimal, 
 2. object, system.type, public enumerated types
 3. one dimensional arrays of (1) and (2) above
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbolExtensions.MarkCheckedIfNecessary(Roslyn.Compilers.VisualBasic.TypeSymbol,System.Collections.Generic.HashSet{Roslyn.Compilers.VisualBasic.TypeSymbol}@)">
	<summary>
 Add this instance to the set of checked types. Returns True
 if this type was added, False if the type was already in the set.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbolExtensions.CheckTypeArguments(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol},System.Int32)">
	<summary> Checks for validity of type arguments passed to Construct(...) method </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbolExtensions.TransformToCanonicalFormFor(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol},Roslyn.Compilers.VisualBasic.SubstitutedNamedType.SpecializedGenericType)">
	<summary>
 Returns ReadOnlyArray(Of TypeSymbol).Null for identity substitution.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbolExtensions.TransformToCanonicalFormFor(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol},Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol.SpecializedGenericMethod)">
	<summary>
 Returns ReadOnlyArray(Of TypeSymbol).Null for identity substitution.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbolExtensions.ExpressionTargetDelegate(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Compilation)">
	<summary>
 Is this type System.Linq.Expressions.Expression(Of T) for some delegate type T. If so, return the type
 argument, else return nothing.
 The passed-in compilation is used to find the well-known-type System.Linq.Expressions.Expression(Of T).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbolExtensions.DelegateOrExpressionDelegate(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 If the passed in type is a delegate type D, return D.
 If the passed in type is a System.Linq.Expressions.Expression(Of D) for a delegate type D, return D.
 Else return Nothing
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbolExtensions.DelegateOrExpressionDelegate(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder,System.Boolean@)">
	<summary>
 If the passed in type is a delegate type D, return D and set wasExpression to False
 If the passed in type is a System.Linq.Expressions.Expression(Of D) for a delegate type D, return D and set wasExpression to True
 Else return Nothing and set wasExpression to False
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeSymbolExtensions.IsExpressionTree(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 If the passed in type is a System.Linq.Expressions.Expression(Of D) for a delegate type D, return True
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeKind">
	<summary>
 Represents the different kinds of types.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TempLocalSymbol">
	<summary>
 TempLocalSymbol is special kind of LocalSymbol that can be byref.
 
 The semantics of LHS ByRef local is roughly the same as of a ByRef parameter
    EmitAssignment will load value of the local (not address of the local itself) for LHS and then will do indirect assignment.
    To store reference in the local, use BoundReferenceAssignment node.
                                     
 The semantics of RHS ByRef local is roughly the same as of a ByRef parameter
    EmitExpression   will load the value which local is referring to.
    EmitAddress      will load the actual local.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SymbolKind">
	<summary>
 Represents the different kinds of symbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SubstitutedTypeParameterSymbol.m_ContainingSymbol">
	<summary>
 Containing type or method.
 The field is not read-only because it is intialized after construction through
 SetContainingSymbol() method.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SubstitutedTypeParameterSymbol.InternalSubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedTypeParameterSymbol">
	<summary>
 A SubstitutedTypeParameterSymbol represents an alpha-renamed type parameter.
 They are created only for open generic types and methods that are contained within a 
 constructed generic type.
 
 Alpha-renamed type parameters have their constraints substituted according
 to type/method's containing type's TypeSubstitution.
 For example:
     Class A (Of T)
         Class B(Of S As T)
         End Class
     End Class
  
 Given a type A(Of IComparable).B(Of ), alpha-renamed type parameter T will have type constraint IComparable.
 The rest will be exactly as for the original type parameter T. In fact, OriginalDefinition will return symbol for T.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedPropertySymbol">
	<summary>
 Represents a property that has undergone type substitution.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedParameterSymbol.SubstitutedMethodParameterSymbol">
	<summary>
 Represents a method parameter that has undergone type substitution.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedParameterSymbol.SubstitutedPropertyParameterSymbol">
	<summary>
 Represents a property parameter that has undergone type substitution.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedParameterSymbol">
	<summary>
 Represents a parameter that has undergone type substitution.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol.TypeSubstitution">
	<summary>
 If this is a generic method return TypeSubstitution for it. 
 TypeSubstitution for containing type otherwise.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol.EqualsWithNoRegardToTypeArguments``1(``0)">
	<summary>
 Compare with no regard to type arguments.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol.SpecializedMethod">
	<summary>
 Base class for symbols representing non-generic or open generic methods contained within constructed generic type.
 For example: A(Of Integer).B, A(Of Integer).B.C or A(Of Integer).B.C(Of ).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol.SetAssociatedPropertyOrEvent(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Associate the method with a particular property. Returns
 false if the method is already associated with a property.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol.SpecializedNonGenericMethod">
	<summary>
 Symbol representing non-generic method directly or indirectly contained within constructed
 generic type.
 For example: A(Of Integer).B or A(Of Integer).B.C
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol.SpecializedGenericMethod._typeParameters">
	<summary>
 Alpha-renamed type parameters, i.e. type parameters with constraints substituted according
 to containing type's TypeSubstitution.
 For example:
     Class A (Of T)
         Sub B(Of S As T)()
         End Sub
     End Class
  
 Given a method A(Of IComparable).B(Of ), alpha-renamed type parameter S will have type constraint IComparable.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol.SpecializedGenericMethod">
	<summary>
 Symbol representing open generic method directly or indirectly contained within constructed
 generic type.
 For example: A(Of Integer).B(Of ) or A(Of Integer).B.C(Of , )
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol.ConstructedMethod">
	<summary>
 Base class for symbols representing constructed generic methods.
 For example: A(Of Integer), A.B(Of Integer), A(Of Integer).B.C(Of Integer).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol.ConstructedSpecializedGenericMethod._constructedFrom">
	<summary>
 Symbol for the ConstructedFrom method.
      A(Of Integer).B(Of ) for A(Of Integer).B(Of Integer),
      A(Of Integer).B.C(Of ) for A(Of Integer).B.C(Of Integer)
 
 All types in its containership hierarchy must be either constructed or non-generic, or original definitions.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol.ConstructedSpecializedGenericMethod">
	<summary>
 Symbols representing constructed generic method that is contained within constructed generic type.
 For example: A(Of Integer).B(Of Integer), A(Of Integer).B.C(Of Integer).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol.ConstructedNotSpecializedGenericMethod">
	<summary>
 Symbols representing constructed generic method that isn't contained within constructed generic type.
 For example: A.B(Of Integer), but not A(Of Integer).B.C(Of Integer).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedMethodSymbol">
	<summary>
 Represents a method that has undergone type substitution. This is use for a method
 inside a generic type that has undergone type substitution. It also serves as a base class
 for ConstructedMethodSymbol, which is used for a method after type substitution in the method type parameters.  
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SubstitutedFieldSymbol">
	<summary>
 Represents a member variable (field) that has undergone type substitution.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.GetSpecialTypeMember(Roslyn.Compilers.SpecialMember)">
	<summary>
 Lookup member declaration in predefined CorLib type used by this Assembly.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.GetDeclaredSpecialTypeMember(Roslyn.Compilers.SpecialMember)">
	<summary>
 Lookup member declaration in predefined CorLib type in this Assembly. Only valid if this 
 assembly is the Cor Library
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MetadataOrSourceAssemblySymbol.m_LazySpecialTypeMembers">
	<summary>
 Lazy cache of special members.
 Not yet known value is represented by ErrorTypeSymbol.UnknownResultType
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MetadataOrSourceAssemblySymbol.GetDeclaredSpecialTypeMember(Roslyn.Compilers.SpecialMember)">
	<summary>
 Lookup member declaration in predefined CorLib type in this Assembly. Only valid if this 
 assembly is the Cor Library
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SubstitutedErrorType.InternalSubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EmbeddedSymbolManager.VbCoreSyntaxTree">
	<summary>
 Lazily created parsed representation of VB Core content
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.EmbeddedSymbolManager">
	<summary> 
 Manages symbols from automatically embedded syntax trees. 
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.EmbeddedSymbolManager._symbols">
	<summary> Automatically embedded symbols (types, methods and fields) used in the current compilation </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.EmbeddedSymbolManager._sealed">
	<summary>
 Non-0 indicates that the collection of referenced symbols is sealed
 and so no new symbols are supposed to be added.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.EmbeddedSymbolManager._standardModuleAttributeReferenced">
	<summary>
 True if StandardModuleAttribute was used in the current compilation
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EmbeddedSymbolManager.RegisterModuleDeclaration">
	<summary>
 Marks StandardModuleAttributeReference type as being references in the 
 current compilation. This method is to be used when a new type symbol for a 
 module is being created; we cannot pass the actual StandardModuleAttribute 
 type symbol because the symbol table is being constructed and calling 
 Compilation.GetWellKnownType(...) will cause infinite recursion. It does
 not seem reasonable to special case this in symbol creation, so we just 
 mark StandardModuleAttribute attribute as referenced and then add 
 the actual symbol when MarkAllDeferredSymbols(...) is called.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EmbeddedSymbolManager.MarkAllDeferredSymbolsAsReferenced(Roslyn.Compilers.VisualBasic.Compilation)">
	<summary>
 Mark all deferred types as referenced
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EmbeddedSymbolManager.IsAnySymbolReferenced">
	<summary>
 Returns True if any embedded symbols are referenced.
 
 WARNING: the referenced symbols collection may not be sealed yet!!!
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EmbeddedSymbolManager.GetCurrentReferencedSymbolsSnapshot(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.Symbol},Roslyn.Utilities.ConcurrentSet{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 Makes a snapshot of the current set of referenced symbols filtered by, 
 the set of symbols provided; may be called before the referenced symbol 
 collection is sealed.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EmbeddedSymbolManager.MarkSymbolAsReferenced(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Utilities.ConcurrentSet{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 Checks if the embedded symbol provided is in the collection and adds it 
 into collection if not.
 
 See description of AddReferencedSymbolWithDependents for more details of how 
 it actually works.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EmbeddedSymbolManager.IsSymbolReferenced(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Returns True if the embedded symbol is known to be referenced in the current compilation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EmbeddedSymbolManager.SealCollection">
	<summary>
 Seals the collection of referenced symbols, all *new* symbols passed 
 to SpawnSymbolCollection(...) will cause assert and be ignored.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EmbeddedSymbolManager.AddReferencedSymbolWithDependents(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Utilities.ConcurrentSet{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 Checks if the embedded symbol provided is present in the 'allSymbols' and if not 
 adds it into 'allSymbols' as well as to the collection of referenced symbols 
 managed by this manager. Also adds all the 'dependent' symbols, i.e. symbols 
 which must also be marked as referenced if 'symbol' is referenced.
 
 NOTE that when a new embedded symbol is being added to the collection of referenced 
 symbols it should be added along with all the 'dependent' symbols. For example, if 
 we add a method symbol (T1.M1) we should ensure the contaning type symbol (T1) is 
 added too, as well as its constructor (T1..ctor) and maybe attribute(s) (Attr1) set 
 on T1 and their constructors/fields (Attr1..ctor), etc...
 
 All dependent symbols must be added in the current thread not depending on 
 the other concurrent threads and avoiding possible race. Thus, let's suppose we have
 the following dependencies:
 
          T1.M1 -&gt; { T1,  T1..ctor, Attr1, Attr1..ctor, ... }
 
 we cannot just check if T1.M1 exists in the collection of referenced symbols and not 
 add dependant symbols if it does; the reason is that T1.M1 may be added by a concurrent 
 thread, but its dependencies may not be added by that thread yet. So we need to 
 calculate all dependencies and try add all the symbols together.
 
 On the other hand it should be avoided that the method *always* goes through all
 the dependencies for each symbol even though it may be definitely known that the symbol
 is added in one of the previous operatinos by *the same thread*. To serve this purpose 
 the method uses 'allSymbols' collection to actually check whether or not the symbol 
 is added to the collection. This makes possible to reuse the same collection in several 
 consequent calls to AddReferencedSymbolWithDependents from the same thread; for example 
 in case one thread consequently adds lots of symbols, the thread may use the same 
 'allSymbols' instance for efficient symbol filtering.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EmbeddedSymbolExtensions.IsEmbeddedSyntaxTree(Roslyn.Compilers.VisualBasic.SyntaxTree)">
	<summary>
 True if the syntax tree is an embedded syntax tree
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.VarianceAmbiguity.HasVarianceAmbiguity(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Determine if two interfaces that were constructed from the same original definition
 have variance ambiguity.
 
 We have something like left=ICocon(Of Mammal, int32[]), right=ICocon(Of Fish, int32[])
 for some interface ICocon(Of Out T, In U). And we have to decide if left and right 
 might lead to ambiguous member-lookup later on in execution.

 To do this: go through each type parameter T, U...
   * For "Out T", judge whether the arguments Mammal/Fish cause ambiguity or prevent it.
   * For "In T", judge whether the arguments int32[]/int32[] cause ambiguity or prevent it.

 "Causing/preventing ambiguity" is described further below.
 
 Given all that, ambiguity was prevented in any positions, then left/right are fine.
 Otherwise, if ambiguity wasn't caused in any positions, then left/right are fine.
 Otherwise, left/right have an ambiguity.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.VarianceAmbiguity.CheckCorrespondingTypeArguments(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VarianceKind,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean@,System.Boolean@)">
	<summary>
 Check two corresponding type arguments T1 and T2 and determine if the cause or prevent variable ambiguity.
 
 Identical types never cause or prevent ambiguity.
 
 If there could exist a **distinct** third type T3, such that T1 and T2 both convert via the variance
 conversion to T3, then ambiguity is caused. This boils down to:
   * Invariant parameters never cause ambiguity
   * Covariant parameters "Out T": ambiguity is caused when the two type arguments 
     are non-object types not known to be values (T3=Object)
   * Contravariant parameters "In U": ambiguity is caused when both:
       - Neither T1 or T2 is a value type or a sealed (NotInheritable) reference type
       - If T1 and T2 are both class types, one derives from the other. 
         (T3 is some type deriving or implementing both T1 and T2)
 
  Ambiguity is prevented when there T1 and T2 cannot unify to the same type, and there 
  cannot be a (not necessarily distinct) third type T3 that both T1 and T2 convert to via
  the variance conversion.
 
  This boils down to:
   * Invariant parameters: Ambiguity is prevented when:
       - they are non-unifying
   * Covariant parameters "Out T": Ambiguity is prevented when both:
       - they are non-unifying
       - at least one is a value type
   * Contravariant parameters "In U": Ambiguity is prevented when:
       - they are non-unifying AND
          - at least one is known to be a value type OR
          - both are known to be class types and neither derives from the other.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.VarianceAmbiguity">
	<summary>
 Utility functions to check if two implemented interfaces have variance ambiguity.
 
 What is "Variance Ambiguity"? Here's an example:
 Class ReflectionType
   Implements IEnumerable(Of Field)
   Implements IEnumerable(Of Method)
   Public Sub GetEnumeratorF() As IEnumerator(Of Field) Implements IEnumerable(Of Field).GetEnumerator ...
   Public Sub GetEnumeratorM() As IEnumerator(Of Method) Implements IEnumberale(Of Method).GetEnumerator ...
 End Class
 Dim x as new ReflectionType
 Dim y as IEnumerable(Of Member) = x
 Dim z = y.GetEnumerator()

 Note that, through variance, both IEnumerable(Of Field) and IEnumerable(Of Method) have widening
 conversions to IEnumerable(Of Member). So it's ambiguous whether the initialization of "z" would
 invoke GetEnumeratorF or GetEnumeratorM. This function avoids such ambiguity at the declaration
 level, i.e. it reports a warning on the two implements classes inside ReflectionType that they
 may lead to ambiguity.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SyntaxTree.ParsedSyntaxTree.ConditionalSymbolsMap.m_conditionalsMap">
	<summary>
 Conditional symbols map, where each key-value pair indicates:
   Key: Conditional symbol name.
   Value: Stack of all active conditional symbol definitions, i.e. #Const directives, in the source file corresponding to a parsed syntax tree.
          All the defining #Const directives for a conditional symbol are pushed onto this stack in source code order.
          Each stack entry is a tuple {CConst, Integer} where:
            CConst: Constant value of the symbol.
            Integer: Source position of the defining #Const directive.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyntaxTree.ParsedSyntaxTree.ConditionalSymbolsMap">
	<summary>
 Map containing information about all conditional symbol definitions in the source file corresponding to a parsed syntax tree.
 </summary>
	<remarks></remarks>
</member><member name="P:EmbeddedResources.ResourceManager">
	<summary>
  Returns the cached ResourceManager instance used by this class.
</summary>
</member><member name="P:EmbeddedResources.Culture">
	<summary>
  Overrides the current thread's CurrentUICulture property for all
  resource lookups using this strongly typed resource class.
</summary>
</member><member name="P:EmbeddedResources.Embedded">
	<summary>
  Looks up a localized string similar to Option Strict On
Option Infer On
Option Explicit On
Option Compare Binary

Namespace Global.Microsoft.VisualBasic
    &lt;Global.Microsoft.VisualBasic.Embedded()&gt;
    &lt;Global.System.AttributeUsage(Global.System.AttributeTargets.Class Or System.AttributeTargets.Module Or System.AttributeTargets.Assembly, Inherited:=False)&gt;
    &lt;Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)&gt;
    &lt;Global.System.Runtime.CompilerServices.CompilerGenerated()&gt;
    Frie [rest of string was truncated]";.
</summary>
</member><member name="P:EmbeddedResources.InternalXmlHelper">
	<summary>
  Looks up a localized string similar to ' See Compiler::LoadXmlSolutionExtension
Namespace Global.Microsoft.VisualBasic.CompilerServices
    &lt;Global.Microsoft.VisualBasic.Embedded()&gt;
    &lt;Global.System.Diagnostics.DebuggerNonUserCodeAttribute(), _
     Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute(), _
     Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Never)&gt; _
    Friend NotInheritable Class InternalXmlHelper
        &lt;Global.System.ComponentModel.EditorBrowsabl [rest of string was truncated]";.
</summary>
</member><member name="P:EmbeddedResources.VbCoreSourceText">
	<summary>
  Looks up a localized string similar to Option Strict On
Option Infer On
Option Explicit On
Option Compare Binary

Namespace Global.Microsoft.VisualBasic
    Namespace CompilerServices
        &lt;Global.Microsoft.VisualBasic.Embedded()&gt;
        &lt;Global.System.Diagnostics.DebuggerNonUserCode(), Global.System.Runtime.CompilerServices.CompilerGenerated()&gt;
        &lt;Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)&gt;
        Friend Class EmbeddedOperators
            Private Sub New()
       [rest of string was truncated]";.
</summary>
</member><member name="T:EmbeddedResources">
	<summary>
  A strongly-typed resource class, for looking up localized strings, etc.
</summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.UnboundGenericType.Create(Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Given a possibly constructed/specialized generic type, create a symbol
 to represent an unbound generic type for its definition.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.UnboundGenericType.GenerateAllDeclarationErrors(System.Threading.CancellationToken)">
	<summary>
 Force all declaration errors to be generated.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeParameterConstraint">
	<summary>
 A type parameter constraint: a single 'New', 'Class',
 'Structure' constraint or a specific type constraint.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypedConstant.Kind">
	<summary>
 The CommonTypedConstant's kind. Can be one of Primitive, Enum, Type, Array or Error
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypedConstant.Value">
	<summary>
  Returns the value for non array values. For "Primitive" constants this is a boxed value or a string or nothing. For
 "Enum" constants this is a boxed value of the underlying type. For "Type" constants, this is a TypeSymbol
 for the type. For "Array" constants this throws.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypedConstant.Values">
	<summary>
 Returns the value for array constants. Throws for non-arrays.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypedConstant.Type">
	<summary>
 The CommonTypedConstant's type. This is either a TypeSymbol of one of the primitive types, a TypeSymbol of an enum
 type, a TypeSymbol for System.Type or an ArrayTypeSymbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypedConstant.ToString">
	<summary>
 Returns the System.String that represents the current CommonTypedConstant.
 </summary>
	<returns>A System.String that represents the current CommonTypedConstant.</returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypedConstant">
	<summary>
 CommonTypedConstant represents a constant value used as an argument to an Attribute. The Typed constant can represent
 a primitive type, an enum type, a system.type or an array of TypedConstants. 
 
 Kind            _value                              _type
 Primitive       Boxed value, string or nothing      TypeSymbol for the boxed value possibly nothing for nothing literal
 Enum            Boxed value of the underlying type  TypeSymbol for enum
 Type            TypeSymbol or nothing               TypeSymbol for System.Type
 Array           TypeConstant() or nothing           ArrayTypeSymbol
 Error           nothing                             TypeSymbol or ErrorTypeSymbol
 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedSimpleConstructorSymbol.SetParameters(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.ParameterSymbol})">
	<summary>
 Sets the parameters.
 </summary>
	<param name="parameters">The parameters.</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedSimpleConstructorSymbol">
	<summary>
 This class represents a simple implementation of compiler generated constructors
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedRegularMethodBase.Name">
	<summary>
 Gets the symbol name. Returns the empty string if unnamed.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedRegularMethodBase.IsMustOverride">
	<summary>
 Gets a value indicating whether this instance is abstract or not.
 </summary>
	<value>
		<c>true</c> if this instance is abstract; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedRegularMethodBase.IsNotOverridable">
	<summary>
 Gets a value indicating whether this instance is not overridable.
 </summary>
	<value>
		<c>true</c> if this instance is not overridable; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedRegularMethodBase.IsOverloads">
	<summary>
 Gets a value indicating whether this instance is overloads.
 </summary>
	<value>
		<c>true</c> if this instance is overloads; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedRegularMethodBase.IsOverridable">
	<summary>
 Gets a value indicating whether this instance is overridable.
 </summary>
	<value>
		<c>true</c> if this instance is overridable; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedRegularMethodBase.IsOverrides">
	<summary>
 Gets a value indicating whether this instance is overrides.
 </summary>
	<value>
		<c>true</c> if this instance is overrides; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedRegularMethodBase.IsShared">
	<summary>
 Gets a value indicating whether this instance is shared.
 </summary>
	<value>
		<c>true</c> if this instance is shared; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedRegularMethodBase.Locations">
	<summary>
 A potentially empty collection of locations that correspond to this instance.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedRegularMethodBase.MethodKind">
	<summary>
 Gets what kind of method this is. There are several different kinds of things in the
 VB language that are represented as methods. This property allow distinguishing those things
 without having to decode the name of the method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedRegularMethodBase.Parameters">
	<summary>
 The parameters forming part of this signature.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedRegularMethodBase">
	<summary>
 This class represents a base class for compiler generated methods
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedParameterSimpleSymbol.#ctor(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Int32,System.String)">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol"/> class.
 </summary>
	<param name="container">The containing symbol</param>
	<param name="type">The type of this parameter</param>
	<param name="ordinal">The ordinal number of this parameter</param>
	<param name="name">The name of this parameter</param>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSimpleSymbol.ContainingSymbol">
	<summary>
 Gets the containing symbol.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSimpleSymbol.CustomModifiers">
	<summary>
 The list of custom modifiers, if any, associated with the parameter. Evaluate this property only if IsModified is true.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSimpleSymbol.DefaultConstantValue(Roslyn.Compilers.VisualBasic.SymbolsInProgress{Roslyn.Compilers.VisualBasic.ParameterSymbol})">
	<summary>
 A compile time constant value that should be supplied as the corresponding argument value by callers that do not explicitly specify an argument value for this parameter.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSimpleSymbol.HasDefaultValue">
	<summary>
 True if the parameter has a default value that should be supplied as the argument value by a caller for which the argument value has not been explicitly specified.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSimpleSymbol.IsByRef">
	<summary>
 Gets a value indicating whether this instance is by ref.
 </summary>
	<value>
		<c>true</c> if this instance is by ref; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSimpleSymbol.IsOptional">
	<summary>
 True if the argument value must be included in the marshalled arguments passed to a remote callee only if it is different from the default value (if there is one).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSimpleSymbol.IsParamArray">
	<summary>
 Gets a value indicating whether this instance is param array.
 </summary>
	<value>
		<c>true</c> if this instance is param array; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSimpleSymbol.IsImplicitlyDeclared">
	<summary>
 Gets a value indicating whether the symbol was generated by the compiler
 rather than declared explicitly.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSimpleSymbol.Locations">
	<summary>
 A potentially empty collection of locations that correspond to this instance.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSimpleSymbol.Ordinal">
	<summary>
 Gets the ordinal.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSimpleSymbol.Type">
	<summary>
 Gets the type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSimpleSymbol.Name">
	<summary>
 Gets the name.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedParameterSimpleSymbol">
	<summary>
 Base (simplified) class for synthesized parameter symbols of methods that have been synthesized. E.g. the parameters of delegate methods
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol.#ctor(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Int32,System.Boolean,System.String)">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol"/> class.
 </summary>
	<param name="container">The containing symbol</param>
	<param name="type">The type of this parameter</param>
	<param name="ordinal">The ordinal number of this parameter</param>
	<param name="isByRef">Whether the parameter is ByRef or not</param>
	<param name="name">The name of this parameter</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol.#ctor(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Int32,System.Boolean,System.String,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.CustomModifier},System.Boolean,Roslyn.Compilers.ConstantValue)">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol"/> class.
 </summary>
	<param name="container">The containing symbol</param>
	<param name="type">The type of this parameter</param>
	<param name="ordinal">The ordinal number of this parameter</param>
	<param name="isByRef">Whether the parameter is ByRef or not</param>
	<param name="name">The name of this parameter</param>
	<param name="customModifiers">The custom modifiers of this parameter</param>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol.CustomModifiers">
	<summary>
 The list of custom modifiers, if any, associated with the parameter. Evaluate this property only if IsModified is true.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol.IsByRef">
	<summary>
 Gets a value indicating whether this instance is by ref.
 </summary>
	<value>
		<c>true</c> if this instance is by ref; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol.IsOptional">
	<summary>
 True if the argument value must be included in the marshalled arguments passed to a remote callee only if it is different from the default value (if there is one).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol.DefaultConstantValue(Roslyn.Compilers.VisualBasic.SymbolsInProgress{Roslyn.Compilers.VisualBasic.ParameterSymbol})">
	<summary>
 A compile time constant value that should be supplied as the corresponding argument value by callers that do not explicitly specify an argument value for this parameter.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol.HasDefaultValue">
	<summary>
 True if the parameter has a default value that should be supplied as the argument value by a caller for which the argument value has not been explicitly specified.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedParameterSymbol">
	<summary>
 Base class for synthesized parameter symbols of methods that have been synthesized. E.g. the parameters of delegate methods
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedParameterWithLocationSymbol">
	<summary>
 Extends SynthesizedParameterSymbol to also accept a location
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedOverridingWitheventsProperty">
	<summary>
 This class represents synthetic WithEvents property that overrides
 one in one of the base classes.
 </summary>
	<remarks>
 When derived class contains "Handles" methods that refer to a 
 WithEvents property in a base class, derived calss needs to add a 
 synthetic override for the base WithEvent property. 
 We need the override so that we could inject code sequences that 
 remove old handlers and add new handlers when something is assigned 
 to the property.
 <example>
 Public Class Base
     Protected Friend WithEvents w As Base = Me
     Public Event e As System.Action
 
     Sub H1() Handles w.e
     End Sub
 End Class
 
 Public Class Derived
     Inherits Base
 
     Sub H2() Handles w.e
     End Sub
 End Class
 </example>
	</remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedGlobalMethodBase.Name">
	<summary>
 Gets the symbol name. Returns the empty string if unnamed.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedGlobalMethodBase.IsMustOverride">
	<summary>
 Gets a value indicating whether this instance is abstract or not.
 </summary>
	<value>
		<c>true</c> if this instance is abstract; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedGlobalMethodBase.IsNotOverridable">
	<summary>
 Gets a value indicating whether this instance is not overridable.
 </summary>
	<value>
		<c>true</c> if this instance is not overridable; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedGlobalMethodBase.IsOverloads">
	<summary>
 Gets a value indicating whether this instance is overloads.
 </summary>
	<value>
		<c>true</c> if this instance is overloads; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedGlobalMethodBase.IsOverridable">
	<summary>
 Gets a value indicating whether this instance is overridable.
 </summary>
	<value>
		<c>true</c> if this instance is overridable; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedGlobalMethodBase.IsOverrides">
	<summary>
 Gets a value indicating whether this instance is overrides.
 </summary>
	<value>
		<c>true</c> if this instance is overrides; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedGlobalMethodBase.IsShared">
	<summary>
 Gets a value indicating whether this instance is shared.
 </summary>
	<value>
		<c>true</c> if this instance is shared; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedGlobalMethodBase.Locations">
	<summary>
 A potentially empty collection of locations that correspond to this instance.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedGlobalMethodBase.MethodKind">
	<summary>
 Gets what kind of method this is. There are several different kinds of things in the
 VB language that are represented as methods. This property allow distinguishing those things
 without having to decode the name of the method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedGlobalMethodBase.Parameters">
	<summary>
 The parameters forming part of this signature.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedGlobalMethodBase">
	<summary>
 This class represents a base class for compiler generated synthesized method symbols
 that must be emitted in the compiler generated PrivateImplementationDetails class.
 SynthesizedGlobalMethodBase symbols don't have a ContainingType, there are global to
 the containing source module and are Public Shared methods.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.#ctor(System.String,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.SourceMemberFlags,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol"/> class. The parameters are not initialized and need to be set 
 by using the <see cref="M:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.SetParameters(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.ParameterSymbol})"/> method.
 </summary>
	<param name="name">The name of this method.</param>
	<param name="containingSymbol">The containing symbol.</param>
	<param name="flags">The flags for this method.</param>
	<param name="returnType">The return type.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.SetParameters(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.ParameterSymbol})">
	<summary>
 Sets the parameters.
 </summary>
	<param name="parameters">The parameters.</param>
	<remarks>
 Note: This should be called at most once, immediately after the symbol is constructed. The parameters aren't 
 Note: passed to the constructor because they need to have their container set correctly.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.Arity">
	<summary>
 Returns the arity of this method, or the number of type parameters it takes.
 A non-generic method has zero arity.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.AssociatedPropertyOrEvent">
	<summary>
 If this method has MethodKind of MethodKind.PropertyGet or MethodKind.PropertySet,
 returns the property that this method is the getter or setter for.
 If this method has MethodKind of MethodKind.EventAdd or MethodKind.EventRemove,
 returns the event that this method is the adder or remover for.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.CallingConvention">
	<summary>
 Calling convention of the signature.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.ContainingSymbol">
	<summary>
 Gets the <see cref="T:ISymbol"/> for the immediately containing symbol.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.DeclaredAccessibility">
	<summary>
 Gets a <see cref="T:CommonAccessibility"/> indicating the declared accessibility for the symbol.
 Returns NotApplicable if no accessibility is declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.ExplicitInterfaceImplementations">
	<summary>
 Returns interface methods explicitly implemented by this method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.IsExtensionMethod">
	<summary>
 Returns true if this method is an extension method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.IsExternalMethod">
	<summary>
 Gets a value indicating whether this instance is external method.
 </summary>
	<value>
		<c>true</c> if this instance is external method; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.IsMustOverride">
	<summary>
 Gets a value indicating whether this instance is abstract or not.
 </summary>
	<value>
		<c>true</c> if this instance is abstract; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.IsNotOverridable">
	<summary>
 Gets a value indicating whether this instance is not overridable.
 </summary>
	<value>
		<c>true</c> if this instance is not overridable; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.IsOverloads">
	<summary>
 Gets a value indicating whether this instance is overloads.
 </summary>
	<value>
		<c>true</c> if this instance is overloads; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.IsOverridable">
	<summary>
 Gets a value indicating whether this instance is overridable.
 </summary>
	<value>
		<c>true</c> if this instance is overridable; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.IsOverrides">
	<summary>
 Gets a value indicating whether this instance is overrides.
 </summary>
	<value>
		<c>true</c> if this instance is overrides; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.IsShared">
	<summary>
 Gets a value indicating whether this instance is shared.
 </summary>
	<value>
		<c>true</c> if this instance is shared; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.IsSub">
	<summary>
 Gets a value indicating whether this instance is a sub.
 </summary>
	<value>
		<c>true</c> if this instance is sub; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.IsVararg">
	<summary>
 Gets a value indicating whether this instance is vararg.
 </summary>
	<value>
		<c>true</c> if this instance is vararg; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.Locations">
	<summary>
 A potentially empty collection of locations that correspond to this instance.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.MethodKind">
	<summary>
 Gets what kind of method this is. There are several different kinds of things in the
 VB language that are represented as methods. This property allow distinguishing those things
 without having to decode the name of the method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.Parameters">
	<summary>
 The parameters forming part of this signature.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.ReturnType">
	<summary>
 Gets the return type of the method.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.GetReturnTypeAttributes">
	<summary>
 Returns the list of attributes, if any, associated with the return type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.ReturnTypeCustomModifiers">
	<summary>
 Returns the list of custom modifiers, if any, associated with the returned value.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.TypeArguments">
	<summary>
 Returns the type arguments that have been substituted for the type parameters.
 If nothing has been substituted for a given type parameter,
 then the type parameter itself is consider the type argument.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.TypeParameters">
	<summary>
 Get the type parameters on this method. If the method has not generic,
 returns an empty list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.IsImplicitlyDeclared">
	<summary>
 Gets a value indicating whether the symbol was generated by the compiler
 rather than declared explicitly.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol.Name">
	<summary>
 Gets the symbol name. Returns the empty string if unnamed.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedDelegateMethodSymbol">
	<summary>
 This class represent a compiler generated method
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedStringSwitchHashMethod.Parameters">
	<summary>
 The parameters forming part of this signature.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedStringSwitchHashMethod">
	<summary>
 This class represents a simple customizable hash method to hash the string constants
 corresponding to the case clause string constants.
 If we have at least one string type select case statement in a module that needs a
 hash table based jump table, we generate a single public string hash sythesized
 method (SynthesizedStringSwitchHashMethod) that is shared across the module.
 We must emit this function into the compiler generated PrivateImplementationDetails class.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SynthesizedConstructorBase.m_isShared">
	<summary>
 Flag to indicate if this is a shared constructor or an instance constructor.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedConstructorBase.#ctor(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,System.Boolean,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.SynthesizedConstructorBase"/> class.
 </summary>
	<param name="container">The containing type for the synthesized constructor.</param>
	<param name="isShared">if set to <c>true</c> if this is a shared constructor.</param>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorBase.Name">
	<summary>
 Gets the symbol name. Returns the empty string if unnamed.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorBase.DeclaredAccessibility">
	<summary>
 Gets a <see cref="T:CommonAccessibility"/> indicating the declared accessibility for the symbol.
 Returns NotApplicable if no accessibility is declared.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorBase.IsMustOverride">
	<summary>
 Gets a value indicating whether this instance is abstract or not.
 </summary>
	<value>
		<c>true</c> if this instance is abstract; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorBase.IsNotOverridable">
	<summary>
 Gets a value indicating whether this instance is not overridable.
 </summary>
	<value>
		<c>true</c> if this instance is not overridable; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorBase.IsOverloads">
	<summary>
 Gets a value indicating whether this instance is overloads.
 </summary>
	<value>
		<c>true</c> if this instance is overloads; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorBase.IsOverridable">
	<summary>
 Gets a value indicating whether this instance is overridable.
 </summary>
	<value>
		<c>true</c> if this instance is overridable; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorBase.IsOverrides">
	<summary>
 Gets a value indicating whether this instance is overrides.
 </summary>
	<value>
		<c>true</c> if this instance is overrides; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorBase.IsShared">
	<summary>
 Gets a value indicating whether this instance is shared.
 </summary>
	<value>
		<c>true</c> if this instance is shared; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorBase.IsSub">
	<summary>
 Gets a value indicating whether this instance is sub.
 </summary>
	<value>
		<c>true</c> if this instance is sub; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorBase.Locations">
	<summary>
 A potentially empty collection of locations that correspond to this instance.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorBase.MethodKind">
	<summary>
 Gets what kind of method this is. There are several different kinds of things in the
 VB language that are represented as methods. This property allow distinguishing those things
 without having to decode the name of the method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorBase.ReturnType">
	<summary>
 Gets the return type of the method.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedConstructorBase">
	<summary>
 This class represents a base class for compiler generated constructors
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedBackingFieldBase`1">
	<summary>
 Represents a base type for compiler generated backing fields.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedAttributeData.Create(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.WellKnownMember,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.Common.CommonTypedConstant},Roslyn.Compilers.ReadOnlyArray{System.Collections.Generic.KeyValuePair{System.String,Roslyn.Compilers.Common.CommonTypedConstant}})">
	<summary>
 Synthesizes attribtue data for given constructor symbol.
 If the constructor has UseSiteErrors and the attribute is optional returns Nothing.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedAttributeData">
	<summary>
 Class to represent a synthesized attribute
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedEventDelegateSymbol.ImplicitlyDefinedBy(Roslyn.Compilers.VisualBasic.MembersInProgress)">
	<summary>
 This property may be called while containing type is still being constructed.
 Therefore it can take membersInProgress context to ensure that returned symbol
 is relevant to the current type construction.
 (there could be several optimistically concurrent sessions)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedEventDelegateSymbol.GenerateAllDeclarationErrors(System.Threading.CancellationToken)">
	<summary>
 Force all declaration errors to be generated.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedEventDelegateSymbol">
	<summary>
 This class represents a synthesized delegate type derived from an Event declaration
 </summary>
	<remarks>
		<example>
 Class C
   Event Name(a As Integer, b As Integer)
 End Class
 
 defines an event and a delegate type:
 
 Event Name As NamedEventHandler
 Delegate Sub NameEventHandler(a As Integer, b As Integer)
 
 </example>
	</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedSimpleMethodSymbol.SetParameters(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.ParameterSymbol})">
	<summary>
 Sets the parameters.
 </summary>
	<param name="parameters">The parameters.</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedSimpleMethodSymbol">
	<summary>
 This class represents a base class for compiler generated methods
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GeneratedNames.MakeOperatorLocalName(System.String)">
	<summary>
 Generates the name of an operator's function local based on the operator name.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GeneratedNames.MakeTempLambdaLocalName">
	<summary>
 Generates the name of a lambda's function value local.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.GeneratedNames">
	<summary>
 Helper class to generate synthesized names.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.GetAttributes">
	<summary>
 Gets the attributes on this symbol. Returns an empty ReadOnlyArray if there are
 no attributes.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.GetAttributes(Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Gets the attributes of a given attribute class on this symbol. Returns an empty
 ReadOnlyArray if there are no attributes.
 </summary>
	<param name="attributeType">The type of attribute to check for.</param>
	<returns>All attributes of the given type, or an empty ReadOnlyArray if none.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.GetAttributes(System.String,System.String)">
	<summary>
 Gets attributes that match the namespace and type name.
 </summary>
	<param name="namespaceName"></param>
	<param name="typeName"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.GetAttributes(Roslyn.Compilers.AttributeDescription)">
	<summary>
 Get attributes that match the namespace, type name and signature.
 </summary>
	<param name="description">Attribute to match.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.GetAttributes(Roslyn.Compilers.VisualBasic.MethodSymbol)">
	<summary>
 Gets the attributes by attribute constructor method symbol. Returns an empty ReadOnlyArray if there are no
 attributes.
 </summary>
	<param name="attributeConstructor">The attribute constructor to check for.</param>
	<returns>All attributes of the given type, or an empty ReadOnlyArray if none.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.GetSynthesizedAttributes">
	<summary>
 Gets the synthesized attributes for this symbol.
 </summary>
	<returns>Array of synthesized attributes of this symbol</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.GetAttributeTarget">
	<summary>
 Returns the appropriate AttributeTarget for a symbol.  This is used to validate attribute usage when
 applying an attribute to a symbol. For any symbol that does not support the application of custom
 attributes 0 is returned.
 </summary>
	<returns>The attribute target flag for this symbol or 0 if none apply.</returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.EarlyDecodeWellKnownAttribute(Roslyn.Compilers.Common.EarlyDecodeWellKnownAttributeArguments{Roslyn.Compilers.VisualBasic.EarlyWellKnownAttributeBinder,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.AttributeSyntax,Roslyn.Compilers.VisualBasic.AttributeLocation}@)">
	<summary>
 Method to early decode applied well-known attribute which can be queried by the binder.
 This method is called during attribute binding after we have bound the attribute types for all attributes,
 but haven't yet bound the attribute arguments/attribute constructor.
 Early decoding certain well-known attributes enables the binder to use this decoded information on this symbol
 when binding the attribute arguments/attribute constructor without causing attribute binding cycle.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.DecodeWellKnownAttribute(Roslyn.Compilers.Common.DecodeWellKnownAttributeArguments{Roslyn.Compilers.VisualBasic.AttributeSyntax,Roslyn.Compilers.VisualBasic.AttributeData,Roslyn.Compilers.VisualBasic.AttributeLocation}@)">
	<summary>
 This method is called by the binder when it is finished binding a set of attributes on the symbol so that
 the symbol can extract data from the attribute arguments and potentially perform validation specific to
 some well known attributes.
 </summary>
	<remarks>
		<para>
 Symbol types should override this if they want to handle a specific well-known attribute.
 If the attribute is of a type that the symbol does not wish to handle, it should delegate back to
 this (base) method.
 </para>
	</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.PostDecodeWellKnownAttributes(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.AttributeData},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.AttributeSyntax},Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.AttributeLocation,Roslyn.Compilers.WellKnownAttributeData)">
	<summary>
 Called to report attribute related diagnostics after all attributes have been bound and decoded.
 Called even if there are no attributes.
 </summary>
	<remarks>
 This method is called by the binder from <see cref="M:LoadAndValidateAttributes"/> after it has finished binding attributes on the symbol,
 has executed <see cref="M:DecodeWellKnownAttributes"/> for attributes applied on the symbol and has stored the decoded data in the
 lazyCustomAttributesBag on the symbol. Bound attributes haven't been stored on the bag yet.
 
 Post-validation for attributes that is dependant on other attributes can be done here.
 
 This method should not have any side effects on the symbol, i.e. it SHOULD NOT change the symbol state.
 </remarks>
	<param name="boundAttributes">Bound attributes.</param>
	<param name="allAttributeSyntaxNodes">Syntax nodes of attributes in order they are specified in source.</param>
	<param name="diagnostics">Diagnostic bag.</param>
	<param name="symbolPart">Specific part of the symbol to which the attributes apply, or <see cref="F:Roslyn.Compilers.VisualBasic.AttributeLocation.None"/> if the attributes apply to the symbol itself.</param>
	<param name="decodedData">Decoded well known attribute data.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.LoadAndValidateAttributes(Roslyn.Utilities.OneOrMany{Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.AttributeListSyntax}},Roslyn.Compilers.CustomAttributesBag{Roslyn.Compilers.VisualBasic.AttributeData}@,Roslyn.Compilers.VisualBasic.AttributeLocation)">
	<summary>
 This method does the following set of operations in the specified order:
 (1) GetAttributesToBind: Merge the given attributeBlockSyntaxList into a single list of attributes to bind.
 (2) GetAttributes: Bind the attributes (attribute type, arguments and constructor).
 (3) DecodeWellKnownAttributes: Decode and validate bound well-known attributes.
 (4) ValidateAttributes: Perform some additional attribute validations, such as
         1) Duplicate attributes,
         2) Attribute usage target validation, etc.
 (5) Store the bound attributes and decoded well-known attribute data in lazyCustomAttributesBag in a thread safe manner.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.EarlyDecodeWellKnownAttributes(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.Binder},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.NamedTypeSymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.AttributeSyntax},Roslyn.Compilers.VisualBasic.AttributeData[],Roslyn.Compilers.VisualBasic.AttributeLocation)">
	<summary> 
 Method to early decode certain well-known attributes which can be queried by the binder. 
 This method is called during attribute binding after we have bound the attribute types for all attributes, 
 but haven't yet bound the attribute arguments/attribute constructor. 
 Early decoding certain well-known attributes enables the binder to use this decoded information on this symbol 
 when binding the attribute arguments/attribute constructor without causing attribute binding cycle. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.ValidateAttributeUsageAndDecodeWellKnownAttributes(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.Binder},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.AttributeSyntax},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.AttributeData},Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.AttributeLocation)">
	<summary> 
 This method validates attribute usage for each bound attribute and calls <see cref="M:DecodeWellKnownAttribute"/>
 on attributes with valid attribute usage.
 This method is called by the binder when it is finished binding a set of attributes on the symbol so that 
 the symbol can extract data from the attribute arguments and potentially perform validation specific to 
 some well known attributes. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.UnboundLambdaParameterSymbol">
	<summary>
 Represents a Lambda parameter for an UnboundLambda.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedWithEventsBackingFieldSymbol.GetAttributes">
	<summary>
 Gets the attributes applied on this symbol.
 Returns an empty array if there are no attributes.
 </summary>
	<remarks>
 NOTE: This method should always be kept as a NotOverridable method.
 If you want to override attribute binding logic for a sub-class, then override <see cref="M:Roslyn.Compilers.VisualBasic.SynthesizedWithEventsBackingFieldSymbol.GetAttributesBag"/> method.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedWithEventsBackingFieldSymbol">
	<summary>
 Represents a compiler generated backing WithEvents field.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedSubmissionConstructorSymbol.#ctor(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,System.Boolean,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol"/> class.
 </summary>
	<param name="container">The containing type for the synthesized constructor.</param>
	<param name="isShared">if set to <c>true</c> if this is a shared constructor.</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedSubmissionConstructorSymbol">
	<summary>
 This class represents a compiler generated parameterless constructor 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedLambdaSymbol.#ctor(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundLambdaParameterSymbol},Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.SynthesizedLambdaSymbol"/> class.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedLambdaSymbol.IsImplicitlyDeclared">
	<summary>
 Gets a value indicating whether the symbol was generated by the compiler
 rather than declared explicitly.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedLambdaSymbol">
	<summary>
 Represents a synthesized lambda. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedFieldSymbol">
	<summary>
 Represents a compiler generated field of given type and name.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedEventBackingFieldSymbol.IsNotSerialized">
	<summary>
		<see cref="T:System.NonSerializedAttribute"/> applied on an event and determines serializability of its backing field.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedEventBackingFieldSymbol">
	<summary>
 Represents a compiler generated backing field for an event.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedEventAccessorSymbol.ConstructFieldLikeEventAccessorBody(Roslyn.Compilers.VisualBasic.SourceEventSymbol,System.Boolean,Roslyn.Compilers.VisualBasic.Compilation,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Generate a thread-safe accessor for a field-like event.
 
 DelegateType tmp0 = _event; //backing field
 DelegateType tmp1;
 DelegateType tmp2;
 do {
     tmp1 = tmp0;
     tmp2 = (DelegateType)Delegate.Combine(tmp1, value); //Remove for -=
     tmp0 = Interlocked.CompareExchange&lt; DelegateType&gt; (ref _event, tmp2, tmp1);
 } while ((object)tmp0 != (object)tmp1);
 </summary>
	<remarks>
 CONSIDER: Dev10 has fallback logic - if Interlocked.CompareExchange is not available, just call
 Delegate.Combine/Remove and mark the method synchronized (unless it is a struct method).
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedEventAccessorSymbol.GetConstructedCompareExchangeMethod(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Compilation,Roslyn.Compilers.VisualBasic.Location,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Get the MethodSymbol for System.Threading.Interlocked.CompareExchange&lt; T&gt;  for a given T.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedEnumConstantSymbol.GetAttributes">
	<summary>
 Gets the attributes applied on this symbol.
 Returns an empty array if there are no attributes.
 </summary>
	<remarks>
 NOTE: This method should always be kept as a NotOverridable method.
 If you want to override attribute binding logic for a sub-class, then override <see cref="M:Roslyn.Compilers.VisualBasic.SynthesizedEnumConstantSymbol.GetAttributesBag"/> method.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedEnumConstantSymbol">
	<summary>
 A compiler generated field for an enum constant.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedEntryPointSymbol">
	<summary>
 Represents an interactive code entry point that is inserted into the compilation if there is not an existing one.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.#ctor(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,System.Boolean,System.Boolean,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol"/> class.
 </summary>
	<param name="syntaxNode"></param>
	<param name="container">The containing type for the synthesized constructor.</param>
	<param name="isShared">if set to <c>true</c> if this is a shared constructor.</param>
	<param name="isDebuggable">if set to <c>true</c> if this constructor will include debuggable initializers.</param>
	<param name="binder">Binder to be used for error reporting, or Nothing.</param>
	<param name="diagnostics">Diagnostic bag, or Nothing.</param>
</member><member name="P:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol.Parameters">
	<summary>
 The parameters forming part of this signature.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedConstructorSymbol">
	<summary>
 This class represents a compiler generated parameterless constructor 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedPropertyBackingFieldSymbol">
	<summary>
 Represents a compiler generated backing field for an automatically implemented property.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceTypeParameterSymbol.ReportRedundantConstraints">
	<summary>
 True if the redundant type parameter constraints should be reported as
 errors. For overridden methods, this is False since type substitution of type
 arguments for the base/interface may result in redundant constraints.
 </summary>
	<remarks>
 This is a method rather than a property since the
 implementation may be expensive.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceTypeParameterSymbol.CheckConstraintTypeConstraints(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeParameterConstraint},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Check constraints of generic types referenced in constraint types. For instance,
 with "Interface I(Of T As I(Of T))", check T satisfies constraints on I(Of T). Those
 constraints are not checked when binding ConstraintTypes since ConstraintTypes
 has not been set on I(Of T) at that point.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceTypeParameterSymbol.GetLocation(Roslyn.Compilers.VisualBasic.TypeParameterDiagnosticInfo)">
	<summary>
 Return the source location of the error, if any. If there error was
 from a constraint, and that constraint was from source, its location
 is returned. Otherwise if the type parameter was from source, its
 location is returned. If neither is from source, Nothing is returned.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceTypeParameterSymbol">
	<summary>
 Represents a type parameter symbol defined in source.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceTypeParameterOnTypeSymbol">
	<summary>
 Represents a type parameter on a source type (as opposed to a method).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceTypeParameterOnMethodSymbol">
	<summary>
 Represents a type parameter on a source method (as opposed to a type).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceSimpleParameterSymbol">
	<summary>
 Represents a parameters declared in source, that is not optional, does not have a default value, 
 attributes, or is a ParamArray. This is a separate class to save memory, since there are LOTS
 of parameters.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourcePropertySymbol.DeclarationSyntax">
	<summary> 
 Property declaration syntax node. 
 It is either PropertyStatement for normal properties or FieldDeclarationSyntax for WithEvents ones.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourcePropertySymbol.GetAttributes">
	<summary>
 Gets the attributes applied on this symbol.
 Returns an empty array if there are no attributes.
 </summary>
	<remarks>
 NOTE: This method should always be kept as a NotOverridable method.
 If you want to override attribute binding logic for a sub-class, then override <see cref="M:Roslyn.Compilers.VisualBasic.SourcePropertySymbol.GetAttributesBag"/> method.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourcePropertySymbol.OverloadsExplicitly">
	<summary> True if 'Overloads' is explicitly specified in method's declaration </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourcePropertySymbol.OverridesExplicitly">
	<summary> True if 'Overrides' is explicitly specified in method's declaration </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourcePropertySymbol.GetAccessorImplementations(System.Boolean)">
	<summary>
 Helper method for accessors to get the overridden accessor methods. Should only be called by the
 accessor method symbols.
 </summary>
	<param name="getter">True to get implemented getters, False to get implemented setters</param>
	<returns>All the accessors of the given kind implemented by this property.</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourcePropertySymbol.Syntax">
	<summary> 
 Property declaration syntax node. 
 It is either PropertyStatement for normal properties or ModifiedIdentifier for WithEvents ones.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourcePropertySymbol.IsAccessibilityMoreRestrictive(Roslyn.Compilers.VisualBasic.Accessibility,Roslyn.Compilers.VisualBasic.Accessibility)">
	<summary>
 Return true if the accessor accessibility is more restrictive
 than the property accessibility, otherwise false.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourcePropertySymbol.GetAccessorBlockBeginLocation(Roslyn.Compilers.VisualBasic.SourcePropertyAccessorSymbol)">
	<summary>
 Returns the location (span) of the accessor begin block.
 (Used for consistency with the native compiler that
 highlights the entire begin block for certain diagnostics.)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourcePropertySymbol.ReportAccessorAccessibilityError(Roslyn.Compilers.VisualBasic.SourcePropertyAccessorSymbol,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.MethodBlockSyntax,Roslyn.Compilers.VisualBasic.ERRID,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Report an error associated with the accessor accessibility modifier.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourcePropertySymbol.SyntaxTree">
	<summary>
 Gets the syntax tree.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourcePropertyAccessorSymbol.BindParameters(Roslyn.Compilers.VisualBasic.SourcePropertySymbol,Roslyn.Compilers.VisualBasic.SourcePropertyAccessorSymbol,Roslyn.Compilers.VisualBasic.Location,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Bind parameters declared on the accessor and combine with any
 parameters declared on the property. If there are no explicit parameters
 and this is a setter, create a synthesized value parameter.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceParameterSymbolBase.GetSynthesizedAttributes">
	<summary>
 Gets the synthesized attributes for this symbol.
 </summary>
	<returns>Array of synthesized attributes of this symbol</returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceParameterSymbolBase">
	<summary>
 Base class for all parameters that are emitted.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceParameterSymbol.GetMatchingPropertyParameter">
	<summary>
 Is this an accessor parameter that came from the associated property? If so, 
 return it, else return Nothing.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceParameterSymbol.GetAttributes">
	<summary>
 Gets the attributes applied on this symbol.
 Returns an empty array if there are no attributes.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamespaceSymbol.RegisterDeclaredCorTypes">
	<summary>
 Register COR types declared in this namespace, if any, in the COR types cache.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamespaceSymbol.GetSourcePathForDeclaration(System.String)">
	<summary>
 Gets the filename of the first declaration that matches the given namespace name case sensitively.
 </summary>
	<param name="namespaceName">Name of the namespace.</param>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceNamespaceSymbol.TypesToCheckForExtensionMethods">
	<summary>
 Return the set of types that should be checked for presence of extension methods in order to build
 a map of extension methods for the namespace. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceNamespaceSymbol.HasMultipleSpellings">
	<summary>
 Does this namespace have multiple different different case-sensitive spellings
 (i.e., "Namespace FOO" and "Namespace foo". Includes parent namespace(s).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamespaceSymbol.GetDeclarationSpelling(Roslyn.Compilers.VisualBasic.SyntaxTree,System.Int32)">
	<summary>
 Get the fully qualified namespace name using the spelling used in the declaration enclosing the given
 syntax tree and location.
 I.e., if this namespace was declared with:
 Namespace zAp
  Namespace FOO.bar
    'location
  End Namespace
 End Namespace
 Namespace ZAP
  Namespace foo.bar
  End Namespace
 End Namespace
 
 It would return "ProjectNamespace.zAp.FOO.bar".
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.ComClassData.m_SyntheticInterfaces">
	<summary>
 Synthesized ComClass interfaces, can have the following values:
     Null - not yet initialized,
     Empty - there are no synthesized ComClass interfaces.
     one interface - only class interface is synthesized.
     two interfaces - both class interface and event interface are synthesized. Class interface is followed by the event interface.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.ComClassData.GetSynthesizedEventInterface">
	<summary>
 Returns symbol for the event interface or Nothing when event interface is not synthesized.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.ComClassData.PerformComClassAnalysis(Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol)">
	<summary>
 Perform ComClass specific validation and prepare for metadata generation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.ComClassData.GetComVisibleState(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Return False if ComVisibleAttribute(False) is applied to the symbol, True otherwise.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.ComClassData.GetUserSpecifiedDispId(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Returns user defined DispId for a member or ReservedDispId.None if none specified.
 Also reports errors for reserved DispIds.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.ComClassData">
	<summary>
 Encapsulates ComClass specific data and analysis.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.PerformComClassAnalysis">
	<summary>
 Perform ComClass specific validation and prepare for metadata generation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.MembersAndInitializers.#ctor(System.Collections.Generic.Dictionary{System.String,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.Symbol}},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer}},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer}})">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.MembersAndInitializers"/> class.
 </summary>
	<param name="members">The members.</param>
	<param name="staticInitializers">The static initializers.</param>
	<param name="instanceInitializers">The instance initializers.</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.MembersAndInitializers">
	<summary>
  Structure to wrap the different arrays of members.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.m_lazyMembersAndInitializers">
	<summary>
 The different kinds of members of this type
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.m_lazyMembersFlattenedAndSorted">
	<summary>
 An array of members in declaration order.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.m_comClassData">
	<summary>
 Information for ComClass specific analysis and metadata generation, created
 once ComClassAttribute is encountered.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.ComputeTypeFlags(Roslyn.Compilers.VisualBasic.MergedTypeDeclaration,System.Boolean)">
	<summary>
 Compute the type flags from the declaration.
 This function DOES NOT diagnose errors in the modifiers. Given the set of modifiers,
 it produces the flags, even in the case of potentially conflicting modifiers. We have to
 return some answer even in the case of errors.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.BindTypeParameterConstraints(Roslyn.Compilers.VisualBasic.SourceTypeParameterOnTypeSymbol,Roslyn.Compilers.VarianceKind@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeParameterConstraint}@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Bind the constraint declarations for the given type parameter.
 </summary>
	<remarks>
 The caller is expected to handle constraint checking and any caching of results.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.GetDeclaredBaseSafe(Roslyn.Utilities.ConsList{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 'Safe' version of GetDeclaredBase takes into account bases being resolved to make sure 
 we avoid infinite loops in some scenarios. Note that the cycle is being broken not when
 we detect it, but when we detect it on the 'smallest' type of the cycle, this brings stability 
 in multithreaded scenarios while still ensures that we don't loop more than twices.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.FirstDeclarationWithExplicitBases">
	<summary>
 Return the first Class declaration with explicit base classes to use for
 checking base class constraints. Other type declarations (Structures,
 Modules, Interfaces) are ignored since other errors will have been
 reported if those types include bases.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.FirstDeclarationWithExplicitInterfaces">
	<summary>
 Return the first Class, Structure, or Interface declaration with explicit interfaces
 to use for checking interface constraints. Other type declarations (Modules) are
 ignored since other errors will have been reported if those types include interfaces.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.FindPartialMethodDeclarations(Roslyn.Compilers.DiagnosticBag,System.Collections.Generic.Dictionary{System.String,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.Symbol}})">
	<summary> Examines the members collection and builds a set of partial methods if any, otherwise returns nothing </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.ComparePartialMethodSignatures(Roslyn.Compilers.VisualBasic.SourceMethodSymbol,Roslyn.Compilers.VisualBasic.SourceMethodSymbol)">
	<summary>
 Compares two methods to check if the 'candidate' can be an implementation of the 'partialDeclaration'.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.StructureCircularityDetectionDataSet.Pool">
	<summary> 
 Following C# implementation we keep up to 32 data sets so that we do not need to allocate 
 them over and over. In this implementation though, circularity detection in one type can trigger
 circularity detection in other types while it traverses the types tree. The traversal is being 
 performed breadth-first, so the number of data sets used by one thread is not longer than the 
 length of the longest structure-in-structure nesting chain.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.StructureCircularityDetectionDataSet.ProcessedTypes">
	<summary> Set of processed structure types </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.StructureCircularityDetectionDataSet.QueueElement">
	<summary> Queue element structure </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.StructureCircularityDetectionDataSet.Queue">
	<summary> Queue of the types to be processed </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.StructureCircularityDetectionDataSet">
	<summary> 
 Poolable data set to be used in structure circularity detection.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.CheckStructureCircularity(Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Analyzes structure type for circularities. Reports only errors relevant for 'structBeingAnalyzed' type.
 </summary>
	<remarks>
 When VB Dev10 detects circularity it reports the error only once for each cycle. Thus, if the cycle 
 is {S1 --&gt; S2 --&gt; S3 --&gt; S1}, only one error will be reported, which one of S1/S2/S3 will have error
 is non-deterministic (depends on the order of symbols in a hash table).
 
 Moreover, Dev10 analyzes the type graph and reports only one error in case S1 --&gt; S2 --&gt; S1 even if 
 there are two fields referensing S2 from S1.
 
 Example:
    Structure S2
      Dim s1 As S1
    End Structure
 
    Structure S3
      Dim s1 As S1
    End Structure
 
    Structure S1
      Dim s2 As S2  ' ERROR
      Dim s2_ As S2 ' NO ERROR 
      Dim s3 As S3  ' ERROR
    End Structure
 
 Dev10 also reports only one error for all the cycles starting with the same field, which one is reported 
 depends on the declaration order. Current implementation reports all of the cycles for consistency. 
 See testcases MultiplyCyclesInStructure03 and MultiplyCyclesInStructure04 (report different errors in Dev10).
 
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.DetectTypeCircularity_ShouldStepIntoType(Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Simple check of whether or not we should step into the type 'typeToTest' during 
 type graph traversal inside 'DetectStructureCircularity' or 'GetDependenceChain'.
 
 The following rules are in place: 
   (a) we order all symbols according their first source location 
       comparison rules: first, source file names are compared, 
       then SourceSpan.Start is used for symbols inside the same file;
   (b) given this order we enter the loop if only 'typeToTest' is 'less' than 
       'structBeingAnalyzed';
   (c) we also always enter types from other modules
 
 !!! To be ONLY used in 'DetectStructureCircularity'.
 </summary>
	<returns>True if detect type circularity code should step into 'typeToTest' type </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.AnyInitializerToBeInjectedIntoConstructor(System.Collections.Generic.IEnumerable{Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer}},System.Boolean)">
	<summary>
 Returns true if at least one of the elements of this list needs to be injected into a 
 constructor because it's not a const or it is a const and it's type is either decimal 
 or date. Non const fields always require a constructor, so this function should be called to 
 determine if a synthesized constructor is needed that is not listed in members list.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.CheckForOverloadOverridesShadowsClashesInSameType(Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.MembersAndInitializers,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Performs a check for overloads/overrides/shadows conflicts, generates diagnostics.
 </summary>
	<param name="membersAndInitializers"></param>
	<param name="diagBag"></param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.DeclareDefaultConstructorIfNeeded(Roslyn.Compilers.VisualBasic.MembersInProgress,System.Boolean,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer}},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Check to see if we need a default instance|shared constructor, and if so, create it.
 
 NOTE: we only need a shared constructor if there are any initializers to be 
 injected into it, we don't create a constructor otherwise. In this case we also 
 ignore const fields which will still require to be injected, because in this case
 we don't see the constructor to be visible in symbol table.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.CreateSharedConstructorsForConstFieldsIfRequired(Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 In case the passed initializers require a shared constructor, this method returns a new MethodSymbol instance for the 
 shared constructor if there is not already an explicit shared constructor
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.StaticInitializers">
	<summary>
 Gets the static initializers.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.InstanceInitializers">
	<summary>
 Gets the instance initializers.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.GetAttributes">
	<summary>
 Gets the attributes applied on this symbol.
 Returns an empty array if there are no attributes.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.GetEarlyDecodedWellKnownAttributeData">
	<summary>
 Returns data decoded from early bound well-known attributes applied to the symbol or null if there are no applied attributes.
 </summary>
	<remarks>
 Forces binding and decoding of attributes.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.HasGuidAttribute">
	<summary>
 Is System.Runtime.InteropServices.GuidAttribute applied to this type in code.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.HasClassInterfaceAttribute">
	<summary>
 Is System.Runtime.InteropServices.ClassInterfaceAttribute applied to this type in code.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.HasComSourceInterfacesAttribute">
	<summary>
 Is System.Runtime.InteropServices.ComSourceInterfacesAttribute applied to this type in code.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.GenerateAllDeclarationErrors(System.Threading.CancellationToken)">
	<summary>
 Force all declaration errors to be generated.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.VarianceContext">
	<summary>
 Following enum is used just to help give more specific error messages.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.BindAllMemberAttributes(System.Threading.CancellationToken)">
	<summary>
  Ensure all attributes on on members in the named type are bound.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.EnumUnderlyingType">
	<summary>
 For enum types, gets the underlying type. Returns null on all other
 kinds of types.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.GetSynthesizedAttributes">
	<summary>
 Gets the synthesized attributes for this symbol.
 </summary>
	<returns>Array of synthesized attributes of this symbol</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.CheckInterfaceUnificationAndVariance(Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Check for two different diagnostics on the set of implemented interfaces:
   1) It is invalid for a type to directly (vs through a base class) implement two interfaces that
   unify (i.e. are the same for some substitution of type parameters).
 
   2) It is a warning to implement variant interfaces twice with type arguments that could cause
   ambiguity during method dispatch.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.ReportInterfaceUnificationError(Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Interface1 and Interface2 conflict for some type arguments. Report the correct error in the correct location.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.ReportVarianceAmbiguityWarning(Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Interface1 and Interface2 have variable ambiguity. Report the warning in the correct location.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.AddInitializer(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer}@,Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer)">
	<summary>
 Adds a field initializer for the field to list of field initializers
 </summary>
	<param name="initializers">All initializers.</param>
	<param name="fieldInitializer">The field initializer to add to the list of initializers.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.AddInitializers(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer}}@,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer})">
	<summary>
 Adds an array of initializers to the member collections structure
 </summary>
	<param name="allInitializers">All initializers.</param>
	<param name="siblings">The siblings.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.CheckForOverloadsErrors(Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Reports the overloads error for this type.
 </summary>
	<param name="diagnostics">The diagnostics.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.CheckForOperatorOverloadingErrors(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.Symbol},System.Int32,System.Collections.Generic.Dictionary{System.String,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.Symbol}}.Enumerator,System.Collections.Generic.HashSet{Roslyn.Compilers.VisualBasic.MethodSymbol}@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Returns True if memberList(memberIndex) is an operator.
 Also performs operator overloading validation and reports appropriate errors.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.IsConflictingOperatorOverloading(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.SymbolComparisonResults,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.Symbol},System.Int32,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 See if any member in [memberList] starting with [memberIndex] conflict with [method],
 report appropriate error and return true. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol.GetEmittedNamespaceName">
	<summary>
 Should return full emitted namespace name for a top level type if the name 
 might be different in case from containing namespace symbol full name, Nothing overwise.
 
 Although namespaces unify based on case-insensitive name, VB uses the casing the namespace
 declaration surround the class definition for the name emitted to metadata. 
 
 Namespace FOO
    Class X
    End Class
 ENd Namespace
 Namespace foo
    Class Y
    End Class
 ENd Namespace
 
 In metadata, these are classes "FOO.X" and "foo.Y" (and thus appear in different namespaces
 when imported into C#.) This function determines the casing of the namespace part of a class, if needed
 to override the namespace name.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol">
	<summary>
 Represents a type or module declared in source. 
 Could be a class, structure, interface, delegate, enum, module.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceTypeFlags">
	<summary>
 Holds information about a SourceType in a compact form.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MembersInProgress.#ctor(System.Collections.Generic.Dictionary{System.String,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.Symbol}},Roslyn.Compilers.ArrayBuilder{Roslyn.Utilities.ValueTuple{Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Binder}})">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.MembersInProgress"/> struct.
 </summary>
	<param name="members">The members.</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.MembersInProgress">
	<summary>
  Accumulates different members kinds used while building the members.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SourceModuleSymbol.m_AssemblySymbol">
	<summary>
 Owning assembly.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceModuleSymbol.GetAttributes">
	<summary>
 Gets the attributes applied on this symbol.
 Returns an empty array if there are no attributes.
 </summary>
	<remarks>
 NOTE: This method should always be kept as a NotOverridable method.
 If you want to override attribute binding logic for a sub-class, then override <see cref="M:Roslyn.Compilers.VisualBasic.SourceModuleSymbol.GetAttributesBag"/> method.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceModuleSymbol.ModuleImportData">
	<summary>
 Data for Binder.BindImportClause that maintains flat lists of members, aliases,
 and corresponding syntax references in addition to the dictionaries needed by
 BindImportClause. The syntax references, instances of GlobalImportInfo, are used
 later, when validating constraints, to generate Locations for constraint errors.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceModuleSymbol.ValidateImports(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.NamespaceOrTypeAndImportsClausePosition},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.SourceModuleSymbol.GlobalImportInfo},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.AliasAndImportsClausePosition},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.SourceModuleSymbol.GlobalImportInfo},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Perform any validation of import statements that must occur
 after the import statements have been added to the module.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceModuleSymbol.ValidateImport(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.SourceModuleSymbol.GlobalImportInfo,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Perform validation of an import statement that must occur
 after the statement has been added to the module. Specifically,
 constraints are checked for generic type references.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceModuleSymbol.GetAllDeclarationErrorsInTree(Roslyn.Compilers.VisualBasic.SyntaxTree,System.Threading.CancellationToken)">
	<summary>
 Get all the declaration errors in a single tree.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceModuleSymbol.GetAllDeclarationErrors(System.Threading.CancellationToken,System.Boolean@)">
	<summary>
 Get all the declaration errors.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceModuleSymbol">
	<summary>
 Represents the primary module of an assembly being built by compiler.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceMethodSymbol.CreateDeclareMethod(Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol,Roslyn.Compilers.VisualBasic.DeclareStatementSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Creates a method symbol for Declare Sub or Function.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceMethodSymbol.DecodeOperatorModifiers(Roslyn.Compilers.VisualBasic.OperatorStatementSyntax,Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Decode the modifiers on a user-defined operator, reporting errors where applicable. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceMethodSymbol.ShadowsExplicitly">
	<summary>
  True if 'Shadows' is explicitly specified in method's declaration.
  </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceMethodSymbol.OverloadsExplicitly">
	<summary> 
 True if 'Overloads' is explicitly specified in method's declaration.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceMethodSymbol.OverridesExplicitly">
	<summary>
  True if 'Overrides' is explicitly specified in method's declaration.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceMethodSymbol.NonMergedLocation">
	<summary>
  Return the location from syntax reference only.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceMethodSymbol.BindTypeParameterConstraints(Roslyn.Compilers.VisualBasic.TypeParameterSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Bind the constraint declarations for the given type parameter.
 </summary>
	<remarks>
 The caller is expected to handle constraint checking and any caching of results.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceMethodSymbol.BoundAttributesSource">
	<summary>
 Symbol to copy bound attributes from, or null if the attributes are not shared among multiple source method symbols.
 </summary>
	<remarks>
 Used for example for event accessors. The "remove" method delegates attribute binding to the "add" method. 
 The bound attribute data are then applied to both accessors.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceMethodSymbol.GetAttributes">
	<summary>
 Gets the attributes applied on this symbol.
 Returns an empty array if there are no attributes.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceMethodSymbol.GetReturnTypeAttributes">
	<summary>
 Returns the list of attributes, if any, associated with the return type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceMethodSymbol.GetEarlyDecodedWellKnownAttributeData">
	<summary>
 Returns data decoded from early bound well-known attributes applied to the symbol or null if there are no applied attributes.
 </summary>
	<remarks>
 Forces binding and decoding of attributes.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceMethodSymbol">
	<summary>
 Base class for method symbols that are associated with some syntax and can receive custom attributes (directly or indirectly via another source symbol).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SourceMemberMethodSymbol.m_otherPartOfPartial">
	<summary>
 If this symbol represents a partial method definition or implementation part, its other part (if any).
 This should be set, if at all, before this symbol appears among the members of its owner.  
 The implementation part is not listed among the "members" of the enclosing type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SourceMemberMethodSymbol.m_suppressDuplicateProcDefDiagnostics">
	<summary>
 If this flag is set this method will be ignored 
 in duplicated signature analysis, see ERR_DuplicateProcDef1 diagnostics.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceMemberMethodSymbol.ValidateImplementedMethodConstraints(Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Validate method type parameter constraints against implemented methods.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceMemberMethodSymbol.InitializePartialMethodParts(Roslyn.Compilers.VisualBasic.SourceMemberMethodSymbol,Roslyn.Compilers.VisualBasic.SourceMemberMethodSymbol)">
	<summary>
  This method is to be called to assign implementation to a partial method.
  </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceMemberMethodSymbol">
	<summary>
 Represents a method declared in source. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceFile.BoundFileInformation">
	<summary>
 The bound information from a file.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceFile.FileImportData">
	<summary>
 Data for Binder.BindImportClause that maintains flat lists
 of members and member syntax references in addition to
 the dictionaries needed by BindImportClause.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceFile.ValidateImports(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.NamespaceOrTypeAndImportsClausePosition},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.SyntaxReference},System.Collections.Generic.Dictionary{System.String,Roslyn.Compilers.VisualBasic.AliasAndImportsClausePosition},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Perform any validation of import statements that must occur
 after the import statements have been added to the SourceFile.
 Specifically, constraints are checked for generic type references.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceFile.MemberImports">
	<summary>
 Return the member imports for this file. May return Nothing if there are no member imports.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceFile.AliasImports">
	<summary>
 Return the alias imports for this file. May return Nothing if there are no alias imports.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceFile.XmlNamespaces">
	<summary>
 Return the xmlns imports for this file. May return Nothing if there are no xmlns imports.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceFile.OptionStrict">
	<summary>
 Returns the value of the Option Strict declaration if there was one, otherwise Null.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceFile.OptionInfer">
	<summary>
 Returns the value of the Option Infer declaration if there was one, otherwise Null.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceFile.OptionExplicit">
	<summary>
 Returns the value of the Option Explicit declaration if there was one, otherwise Null.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceFile.OptionCompareText">
	<summary>
 Returns the value of the Option Compare Text/Binary declaration if there was one, otherwise Null. True means
 Text, False means Binary.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceFile.GenerateAllDeclarationErrors">
	<summary>
 Force all declaration errors to be generated.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceFieldSymbol.DeclarationSyntax">
	<summary> Field declaration syntax node </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceFieldSymbol.EqualsValueOrAsNewInitOpt">
	<summary> Field initializer's declaration syntax node. 
 It can be a EqualsValueSyntax or AsNewClauseSyntax</summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceFieldSymbol.HasDeclaredType">
	<summary>
 Gets a value indicating whether this instance has declared type. This means not an inferred type.
 </summary>
	<value>
		<c>true</c> if this instance has declared type; otherwise, <c>false</c>.
 </value>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceFieldSymbol.GetInferredType(Roslyn.Compilers.VisualBasic.SymbolsInProgress{Roslyn.Compilers.VisualBasic.FieldSymbol})">
	<summary>
 Gets the inferred type of this const field from the initialization value.
 </summary>
	<param name="inProgress">The previously visited const fields; used to detect cycles.</param><returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceFieldSymbol.GetConstantValue(Roslyn.Compilers.VisualBasic.SymbolsInProgress{Roslyn.Compilers.VisualBasic.FieldSymbol})">
	<summary>
 Gets the constant value.
 </summary>
	<param name="inProgress">The previously visited const fields; used to detect cycles.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceFieldSymbol.GetAttributes">
	<summary>
 Gets the attributes applied on this symbol.
 Returns an empty array if there are no attributes.
 </summary>
	<remarks>
 NOTE: This method should always be kept as a NotOverridable method.
 If you want to override attribute binding logic for a sub-class, then override <see cref="M:Roslyn.Compilers.VisualBasic.SourceFieldSymbol.GetAttributesBag"/> method.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceFieldSymbol.GetSynthesizedAttributes">
	<summary>
 Gets the synthesized attributes for this symbol.
 </summary>
	<returns>Array of synthesized attributes of this symbol</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceFieldSymbol.SyntaxTree">
	<summary>
 Gets the syntax tree.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceFieldSymbol.SourceFieldSymbolWithInitializer">
	<summary>
 A source field with an explicit initializer. In a declaration declaring multiple fields,
 such as "Dim a, b, c = d", this class is used for the first field only. (Other fields in
 the declaration are instances of SourceFieldSymbolSiblingInitializer.)
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceFieldSymbol.SourceFieldSymbolSiblingInitializer">
	<summary>
 A source field with an explicit initializer. In a declaration declaring multiple
 fields, such as "Dim a, b, c = d", this class is used for the fields other than
 the first. (The first field is an instance of SourceFieldSymbolWithInitializer.)
 An instance of this class holds a reference to the first field in the declaration
 and reuses the bound initializer from that field.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SourceEventSymbol.IsTypeInferred">
	<summary>
 Indicates whether event created a new delegate type.
 In such case the Type must be added to the members of the containing type
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceEventSymbol.GetAccessorImplementations(Roslyn.Compilers.VisualBasic.MethodKind)">
	<summary>
 Helper method for accessors to get the overridden accessor methods. Should only be called by the
 accessor method symbols.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceEventSymbol.GetAttributes">
	<summary>
 Gets the attributes applied on this symbol.
 Returns an empty array if there are no attributes.
 </summary>
	<remarks>
 NOTE: This method should always be kept as a NotOverridable method.
 If you want to override attribute binding logic for a sub-class, then override <see cref="M:Roslyn.Compilers.VisualBasic.SourceEventSymbol.GetAttributesBag"/> method.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceDelegateMethodSymbol.IsExtensionMethod">
	<summary>
 Returns true if this method is an extension method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceDelegateMethodSymbol.IsExternalMethod">
	<summary>
 Gets a value indicating whether this instance is external method.
 </summary>
	<value>
		<c>true</c> if this instance is external method; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceDelegateMethodSymbol.TypeParameters">
	<summary>
 Get the type parameters on this method. If the method has not generic,
 returns an empty list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceDelegateMethodSymbol.IsImplicitlyDeclared">
	<summary>
 Gets a value indicating whether the symbol was generated by the compiler
 rather than declared explicitly.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceDelegateMethodSymbol">
	<summary>
 This class represent a compiler generated method of a delegate type that is based upon source delegate or event delegate declaration.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceDeclareMethodSymbol">
	<summary>
 Represents a declare method defined in source.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceComplexParameterSymbol.BoundAttributesSource">
	<summary>
 Symbol to copy bound attributes from, or null if the attributes are not shared among multiple source method symbols.
 </summary>
	<remarks>
 Used for partial method parameters: 
 Implementation parameter always copies its attributes from the corresponding definition parameter.
 Definition is always complex parameter and so it stores the attribute bag.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceComplexParameterSymbol.IsExplicitByRef">
	<summary>
 Is parameter explicitly declared ByRef. Can be different from IsByRef only for
 String parameters of Declare methods.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceComplexParameterSymbol">
	<summary>
 Represents a parameter symbol defined in source.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceClonedParameterSymbol">
	<summary>
 Represents a source parameter cloned from another <see cref="T:Roslyn.Compilers.VisualBasic.SourceParameterSymbol"/> , 
 when they must share attribute data.
 </summary>
	<remarks>
 For example, parameters on delegate Invoke method are cloned to delegate BeginInvoke, EndInvoke methods. 
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceAttributeData.IsTargetAttribute(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.AttributeDescription)">
	<summary>
 This method finds an attribute by metadata name and signature. The algorithm for signature matching is similar to the one
 in Module.GetTargetAttributeSignatureIndex. Note, the signature matching is limited to primitive types
 and System.Type.  It will not match an arbitrary signature but it is sufficient to match the signatures of the current set of
 well known attributes.
 </summary>
	<param name="description">Attribute to match.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceAttributeData.GetSystemType(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Gets the System.Type type symbol from targetSymbol's containing assembly.
 </summary>
	<param name="targetSymbol">Target symbol on which this attribute is applied.</param>
	<returns>System.Type type symbol.</returns>
</member><member name="F:Roslyn.Compilers.VisualBasic.SourceAssemblySymbol.m_Compilation">
	<summary>
 A Compilation the assembly is created for.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.SourceAssemblySymbol.m_lazyIdentity">
	<summary>
 Assembly's identity.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.SourceAssemblySymbol.m_Modules">
	<summary>
 A list of modules the assembly consists of. 
 The first (index=0) module is a SourceModuleSymbol, which is a primary module, the rest are net-modules.
 </summary>
	<remarks></remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceAssemblySymbol.Compilation">
	<summary>
 A Compilation the assembly is created for.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceAssemblySymbol.GetNetModuleAttributesBag">
	<summary>
 Returns a bag of netmodule assembly attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
 </summary>
	<remarks>
 Forces binding and decoding of attributes.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceAssemblySymbol.GetAttributes">
	<summary>
 Gets the attributes applied on this symbol.
 Returns an empty array if there are no attributes.
 </summary>
	<remarks>
 NOTE: This method should always be kept as a NotOverridable method.
 If you want to override attribute binding logic for a sub-class, then override <see cref="M:Roslyn.Compilers.VisualBasic.SourceAssemblySymbol.GetAttributesBag"/> method.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.SourceAssemblySymbol.Flags">
	<summary>
 This represents what the user claimed in source through the AssemblyFlagsAttribute.
 It may be modified as emitted due to presence or absence of the public key.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceAssemblySymbol.GetAssemblyLevelDeclarationErrors(System.Boolean,System.Threading.CancellationToken)">
	<summary>
 Get assembly level declaration errors.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SourceAssemblySymbol.ReportDiagnosticsForSynthesizedAttributes(Roslyn.Compilers.VisualBasic.Compilation,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 We may synthesize some well-known attributes for this assembly symbol.  However, at synthesis time, it is
 too late to report diagnostics or cancel the emit.  Instead, we check for use site errors on the types and members
 we know we'll need at synthesis time.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceAssemblySymbol">
	<summary>
 Represents an assembly built by compiler.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.RangeVariableSymbol.Create(Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Create a range variable symbol associated with an identifier token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.RangeVariableSymbol.CreateForErrorRecovery(Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Create a range variable symbol not associated with an identifier token, i.e. with illegal name.
 Used for error recovery binding.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.RangeVariableSymbol">
	<summary>
 Represents a range variable symbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverrideHidingHelper.CheckHidingAndOverridingForType(Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Check for overriding and hiding errors in container and report them via diagnostics.
 </summary>
	<param name="container">Containing type to check. Should be an original definition.</param>
	<param name="diagnostics">Place diagnostics here.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverrideHidingHelper.CheckMembersAgainstBaseType(Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Check each member of container for constraints against the base type. For methods and properties and events,
 checking overriding and hiding constraints. For other members, just check for hiding issues.
 </summary>
	<param name="container">Containing type to check. Should be an original definition.</param>
	<param name="diagnostics">Place diagnostics here.</param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverrideHidingHelper.CheckAllAbstractsAreOverriddenAndNotHidden(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 If the "container" is a non-MustInherit, make sure it has no MustOverride Members
 If "container" is a non-MustInherit inheriting from a MustInherit, make sure that all MustOverride members
 have been overridden.
 If "container" is a MustInherit inheriting from a MustInherit, make sure that no MustOverride members
 have been shadowed.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverrideHidingHelper.CheckShadowing(Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol,Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Report any diagnostics related to shadowing for a member.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverrideHidingHelper.CanOverrideOrHide(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Some symbols do not participate in overriding/hiding (e.g. constructors). Accessors are consider
 to override or hide.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverrideHidingHelper.RequiresExplicitOverride(Roslyn.Compilers.VisualBasic.MethodSymbol)">
	<summary>
 If a method had an virtual inaccessible override, then an explicit override in metadata is needed
 to make it really override what it intends to override, and "skip" the inaccessible virtual
 method.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.OverrideHidingHelper">
	<summary>
 Methods, Properties, and Events all can override or hide members. 
 This class has helper methods and extensions for sharing by multiple symbol types.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverrideHidingHelper`1.MakeOverriddenMembers(`0)">
	<summary>
 Walk up the type hierarchy from ContainingType and list members that this
 method overrides (accessible methods/properties with the same signature, if this
 method is declared "override").
 
 Methods in the overridden list may not be virtual or may have different
 accessibities, types, accessors, etc.  They are really candidates to be
 overridden.
 
 All found accessible candidates of overridden members are collected in two 
 builders, those with 'exactly' matching signatures and those with 'generally'
 or 'inexactly' matching signatures. 'Exact' signature match is a 'general' 
 signature match which also does not have mismatches in total number of parameters
 and/or types of optional parameters. See also comments on correspondent 
 OverriddenMembersResult(Of TSymbol) properties.
 
 'Inexactly' matching candidates are only collected for reporting Dev10/Dev11
 errors like BC30697 and others. We collect 'inexact' matching candidates until 
 we find any 'exact' match.
 
 Also remembers inaccessible members that are found, but these do not prevent
 continuing to search for accessible members.
 
 </summary>
	<remarks>
 In the presence of non-VB types, the meaning of "same signature" is rather
 complicated.  If this method isn't from source, then it refers to the runtime's
 notion of signature (i.e. including return type, custom modifiers, etc).
 If this method is from source, use the VB version of signature. Note that 
 Dev10 C# has a rule that prefers members with less custom modifiers. Dev 10 VB has no
 such rule, so I'm not adding such a rule here.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverrideHidingHelper`1.FindOverriddenMembersInType(`0,System.Boolean,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.ArrayBuilder{`0},Roslyn.Compilers.ArrayBuilder{`0},Roslyn.Compilers.ArrayBuilder{`0})">
	<summary>
 Look for overridden members in a specific type. Return true if we find an overridden member candidate 
 with 'exact' signature match, or we hit a member that hides. See comments on MakeOverriddenMembers(...)
 for description of 'exact' and 'inexact' signature matches.
 
 Also remember any inaccessible members that we see.
 </summary>
	<param name="overridingSym">Syntax that overriding or hiding.</param>
	<param name="overridingIsFromSource">True if "overridingSym" is from source (this.IsFromSource).</param>
	<param name="overridingContainingType">The type that contains this method (this.ContainingType).</param>
	<param name="currType">The type to search.</param>
	<param name="overriddenBuilder">Builder to place exactly-matched overridden member candidates in. </param>
	<param name="inexactOverriddenMembers">Builder to place inexactly-matched overridden member candidates in. </param>
	<param name="inaccessibleBuilder">Builder to place exactly-matched inaccessible overridden member candidates in. </param>
</member><member name="T:Roslyn.Compilers.VisualBasic.OverrideHidingHelper`1">
	<summary>
 Many of the methods want to generically work on properties, methods (and maybe events) as TSymbol. We put all these
 methods into a generic class for convenience.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadingHelper.SetMetadataNameForAllOverloads(System.String,Roslyn.Compilers.VisualBasic.SymbolKind,Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol)">
	<summary>
 Set the correct metadata name for all overloads of a particular name and symbol kind
 (must be method or property) inside a container.
 
 The rules are as follows:
    1) If a method or property overrides one from its base class, its metadata name
       must match that.
    2) If method overload those in the base (because the Overloads keyword is used), and
       all metadata names in the base are consistent in case, use that name.
    3) All overloads with a class should match, except possibly for overrides. If there is
       an override or overload from base, use that. Otherwise, use casing of first member in
       class.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadingHelper.FindOverloads(System.String,Roslyn.Compilers.VisualBasic.SymbolKind,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.Symbol},System.Boolean@,System.Boolean@)">
	<summary>
 Collect all overloads in "container" of the given name and kind.
 Also determine if any have "Overloads" or "Overrides" specifiers.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadingHelper.SetMetadataNamesOfOverrides(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.Symbol},Roslyn.Compilers.VisualBasic.Compilation)">
	<summary>
 For each member in "overloadedMembers" that is marked Overrides, set its
 metadata name to be the metadata name of its overridden member. Return the
 first such name, lexically.
 
 Note: can return null if no override member with an actual overridden member was found.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadingHelper.NameOfFirstMember(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.Symbol},Roslyn.Compilers.VisualBasic.Compilation)">
	<summary>
 Return the name of the lexically first symbol in "overloadedMembers".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadingHelper.GetBaseMemberMetadataName(System.String,Roslyn.Compilers.VisualBasic.SymbolKind,Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol)">
	<summary>
 Check all accessible, visible members of the base types of container for the given name and kind. If they
 all have the same case-sensitive metadata name, return that name. Otherwise, return Nothing.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.OverloadingHelper">
	<summary>
 Function that help implement the overloading rules for VB, in particular the rules
 for recasing method and property names.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LocalSymbol.LocalDeclarationKind.AmbiguousLocals">
	<summary> 
 Only used in flow analysis for the pseudo-local representing a symbol 
 of the implicit receiver in case Dim statement defines more than one 
 variable, but uses the same object initializer for all of them, like in: 
     Dim a,b As New C() With { .X = .Y } 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalSymbol.Create(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.EqualsValueSyntax,Roslyn.Compilers.VisualBasic.LocalSymbol.LocalDeclarationKind)">
	<summary>
  Create a local symbol from a local variable declaration.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalSymbol.Create(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LocalSymbol.LocalDeclarationKind,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Create a local symbol associated with an identifier token.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalSymbol.Create(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Binder,System.String,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LocalSymbol.LocalDeclarationKind,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Create a local symbol associated with an identifier token and a different name (used for operators)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalSymbol.Create(Roslyn.Compilers.VisualBasic.Symbol,System.String,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LocalSymbol.LocalDeclarationKind,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Create a local symbol associated with an identifier token but a different name.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalSymbol.Create(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LocalSymbol.LocalDeclarationKind,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Create a local symbol that is not associated with any source.
 </summary>
	<remarks>Generally used for temporary locals past the initial binding phase.</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalSymbol.CreateInferredForFromTo(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ForStepClauseSyntax)">
	<summary>
 Create an inferred local symbol from a For from-to statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalSymbol.CreateInferredForEach(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Create an inferred local symbol from a For-each statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalSymbol.#ctor(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LocalSymbol.LocalDeclarationKind,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Create a local variable symbol. Note: this does not insert it automatically into a
 local binder so that it can be found by lookup.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LocalSymbol.IsReadOnly">
	<summary>
 Returns true if this local is a ReadOnly local. Compiler has a concept of ReadOnly locals.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LocalSymbol.IsImplicitlyDeclared">
	<summary>
 Was this local variable implicitly declared, because Option Explicit Off
 was in effect, and no other symbol was found with this name.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalSymbol.LocalSymbolWithBinder.#ctor(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LocalSymbol.LocalDeclarationKind,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Create a local variable symbol. Note: this does not insert it automatically into a
 local binder so that it can be found by lookup.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LocalSymbol.LocalSymbolWithBinder">
	<summary>
 Base class for any local symbol that needs a binder
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalSymbol.AliasLocalSymbolWithBinder.#ctor(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Binder,System.String,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LocalSymbol.LocalDeclarationKind,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Create a local variable symbol. Note: this does not insert it automatically into a
 local binder so that it can be found by lookup.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LocalSymbol.AliasLocalSymbolWithBinder">
	<summary>
 Class for a local symbol that needs a binder and has a different name than the identifier token.
 In this case the real name is returned by the name property and the "VB User visible name" can be
 obtained by accessing the IdentifierToken.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalSymbol.AliasLocalSymbol.#ctor(Roslyn.Compilers.VisualBasic.Symbol,System.String,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.LocalSymbol.LocalDeclarationKind,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Create a local variable symbol. Note: this does not insert it automatically into a
 local binder so that it can be found by lookup.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LocalSymbol.AliasLocalSymbol">
	<summary>
 Class for a local symbol that has a different name than the identifier token.
 </summary>
	<remarks>Instances of this class are used in rewriting.</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalSymbol.InferredForEachLocalSymbol.#ctor(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Create a local variable symbol. Note: this does not insert it automatically into a
 local binder so that it can be found by lookup.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LocalSymbol.InferredForEachLocalSymbol">
	<summary>
 A local symbol created by a for-each statement when Option Infer is on.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalSymbol.InferredForFromToLocalSymbol.#ctor(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ForStepClauseSyntax)">
	<summary>
 Create a local variable symbol. Note: this does not insert it automatically into a
 local binder so that it can be found by lookup.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LocalSymbol.InferredForFromToLocalSymbol">
	<summary>
 A local symbol created by For from-to statement when Option Infer is on.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalSymbol.VariableLocalSymbol.#ctor(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.EqualsValueSyntax,Roslyn.Compilers.VisualBasic.LocalSymbol.LocalDeclarationKind)">
	<summary>
 Create a local variable symbol. Note: this does not insert it automatically into a
 local binder so that it can be found by lookup.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LocalSymbol.VariableLocalSymbol">
	<summary>
 A local symbol created from a variable declaration or a for statement with an as clause.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.LocalSymbol.NoLocationVariable">
	<summary>
 Local symbol that is not associated with any source.
 </summary>
	<remarks>Generally used for temporary locals past the initial binding phase.</remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.LocalSymbol">
	<summary>
 Represents a local variable (typically inside a method body). This could also be a local variable implicitly
 declared by a For, Using, etc. When used as a temporary variable, its container can also be a Field or Property Symbol.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaSymbol.ReturnTypeIsBeingInferred">
	<summary>
 This symbol is used as the return type of a LambdaSymbol when we are interpreting 
 lambda's body in order to infer its return type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaSymbol.ReturnTypeIsUnknown">
	<summary>
 This symbol is used as the return type of a LambdaSymbol when we failed to 
 infer lambda's return type, but still want to interpret its body.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaSymbol.ReturnTypePendingDelegate">
	<summary>
 This symbol is used as the return type of a LambdaSymbol when we are dealing with
 query lambda and the return type should be taken from the target delegate upon
 successful conversion. The LambdaSymbol will be mutated then. 
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaSymbol.ReturnTypeVoidReplacement">
	<summary>
 This symbol is used as the return type of a LambdaSymbol when System.Void is used in code.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaSymbol.m_ReturnType">
	<summary>
 Can mutate for a query lambda from ReturnTypePendingDelegate 
 to the return type of the target delegate.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LambdaSymbol.MeParameter">
	<summary>
 "Me" parameter for this lambda will be that of the containing symbol
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaSymbol">
	<summary>
 Represents a method symbol for a lambda method.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaParameterSymbol">
	<summary>
 Represents a Lambda parameter.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImplementsHelper.FindExplicitlyImplementedMember``1(``0,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.QualifiedNameSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.Symbol},Roslyn.Compilers.VisualBasic.LookupResultKind@)">
	<summary>
 Find the implemented method denoted by "implementedMemberSyntax" that matches implementingSym.
 Returns the implemented method, or Nothing if none.
 
 Also stores into "candidateSymbols" (if not Nothing) and resultKind the symbols and result kind that
 should be used for semantic model purposes.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImplementsHelper.MembersAreMatchingForPurposesOfInterfaceImplementation(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Does 'implementingSym' match 'implementedSym' well enough to be considered a match for interface implementation?
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImplementsHelper.ValidateImplementedMember``1(``0,``0,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.QualifiedNameSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Perform additional validate of implementedSym and issue diagnostics.
 Return "implementedSym" if the symbol table should record implementedSym as the implemented
 symbol (even if diagnostics were issues). Returns Nothing if the code should not treat
 implementedSym as the implemented symbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImplementsHelper.ValidateImplementedMethodConstraints(Roslyn.Compilers.VisualBasic.SourceMethodSymbol,Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Validate method type parameter constraints. This is handled outside
 of ValidateImplementedMember because that method is invoked
 while computing the ExplicitInterfaceImplementations value on the
 implementing method, but method type parameters rely on the value
 of ExplicitInterfaceImplementations to determine constraints correctly.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImplementsHelper.ComputeImplementationForInterfaceMember``1(``0,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Collections.Generic.IEqualityComparer{``0})">
	<summary>
 Performs interface mapping to determine which symbol in this type or a base type
 actually implements a particular interface member.
 </summary>
	<typeparam name="TSymbol">MethodSymbol or PropertySymbol or EventSymbol (an interface member).</typeparam>
	<param name="interfaceMember">A non-null member on an interface type.</param>
	<param name="implementingType">The type implementing the interface member.</param>
	<param name="comparer">A comparer for comparing signatures of TSymbol according to metadata implementation rules.</param>
	<returns>The implementing member or Nothing, if there isn't one.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImplementsHelper.FindImplicitImplementationDeclaredInType``1(``0,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Collections.Generic.IEqualityComparer{``0})">
	<summary>
 Search the declared methods of a type for one that could be an implicit implementation
 of a given interface method (depending on interface declarations). It is assumed that the implementing
 type is not a source type.
 </summary>
	<typeparam name="TSymbol">MethodSymbol or PropertySymbol or EventSymbol (an interface member).</typeparam>
	<param name="interfaceMember">The interface member being implemented.</param>
	<param name="currType">The type on which we are looking for a declared implementation of the interface method.</param>
	<param name="comparer">A comparer for comparing signatures of TSymbol according to metadata implementation rules.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImplementsHelper.SubstituteExplicitInterfaceImplementations``1(Roslyn.Compilers.ReadOnlyArray{``0},Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Given a set of explicit interface implementations that are undergoing substitution, return the substituted versions.
 </summary>
	<typeparam name="TSymbol">Type of the interface members (Method, Property, Event)</typeparam>
	<param name="unsubstitutedImplementations">The ROA of members that are being implemented</param>
	<param name="substitution">The type substitution</param>
	<returns>The substituted members.</returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.ImplementsHelper">
	<summary>
 Methods, Properties, and Events all have implements clauses and need to handle interface
 implementation. This module has helper methods and extensions for sharing by multiple
 symbol types.
 </summary>
	<remarks></remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.IAttributeTargetSymbol.DefaultAttributeLocation">
	<summary>
 Attribute location corresponding to this symbol.
 </summary>
	<remarks>
 Location of an attribute if an explicit location is not specified via attribute target specification syntax.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CustomEventAccessorSymbol.BindParameters(Roslyn.Compilers.VisualBasic.Location,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Bind and validate parameters declared on the accessor.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.BoundLambdaParameterSymbol">
	<summary>
 Represents a Lambda parameter for a LambdaSymbol.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SignatureOnlyPropertySymbol">
	<summary>
 A representation of a proeprty symbol that is intended only to be used for comparison purposes
 (esp in PropertySignatureComparer).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SignatureOnlyParameterSymbol">
	<summary>
 Intended to be used to create ParameterSymbols for a SignatureOnlyMethodSymbol.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SignatureOnlyMethodSymbol">
	<summary>
 A representation of a method symbol that is intended only to be used for comparison purposes
 (esp in MethodSignatureComparer).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingTypeParameterSymbol.m_RetargetingModule">
	<summary>
 Owning RetargetingModuleSymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingTypeParameterSymbol.m_UnderlyingTypeParameter">
	<summary>
 The underlying TypeParameterSymbol, cannot be another RetargetingTypeParameterSymbol.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingTypeParameterSymbol">
	<summary>
 Represents a type parameter in a RetargetingModuleSymbol. Essentially this is a wrapper around 
 another TypeParameterSymbol that is responsible for retargeting symbols from one assembly to another. 
 It can retarget symbols for multiple assemblies at the same time.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingModuleSymbol.m_SymbolMap">
	<summary>
 Retargeting map from underlying module to this one.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingModuleSymbol.RetargetingSymbolTranslator.SymbolMap">
	<summary>
 Retargeting map from underlying module to the retargeting module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingModuleSymbol.RetargetingSymbolTranslator.RetargetingAssembly">
	<summary>
 RetargetingAssemblySymbol owning retargeting module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingModuleSymbol.RetargetingSymbolTranslator.RetargetingAssemblyMap">
	<summary>
 The map that captures information about what assembly should be retargeted 
 to what assembly. Key is the AssemblySymbol referenced by the underlying module,
 value is the corresponding AssemblySymbol referenced by the retargeting module, 
 and corresponding retargeting map for symbols.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingModuleSymbol.RetargetingSymbolTranslator.UnderlyingModule">
	<summary>
 The underlying ModuleSymbol for the retargeting module.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingPropertySymbol.m_RetargetingModule">
	<summary>
 Owning RetargetingModuleSymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingPropertySymbol.m_UnderlyingProperty">
	<summary>
 The underlying PropertySymbol, cannot be another RetargetingPropertySymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingPropertySymbol.m_LazyCustomAttributes">
	<summary>
 Retargeted custom attributes
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingParameterSymbol.m_UnderlyingParameter">
	<summary>
 The underlying ParameterSymbol, cannot be another RetargetingParameterSymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingParameterSymbol.m_LazyCustomAttributes">
	<summary>
 Retargeted custom attributes
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingParameterSymbol.RetargetingMethodParameterSymbol.m_RetargetingMethod">
	<summary>
 Owning RetargetingMethodSymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingParameterSymbol.RetargetingPropertyParameterSymbol.m_RetargetingProperty">
	<summary>
 Owning RetargetingPropertySymbol.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingParameterSymbol">
	<summary>
 Represents a parameter of a RetargetingMethodSymbol. Essentially this is a wrapper around 
 another ParameterSymbol that is responsible for retargeting symbols from one assembly to another. 
 It can retarget symbols for multiple assemblies at the same time.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingNamespaceSymbol.m_RetargetingModule">
	<summary>
 Owning RetargetingModuleSymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingNamespaceSymbol.m_UnderlyingNamespace">
	<summary>
 The underlying NamespaceSymbol, cannot be another RetargetingNamespaceSymbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingNamespaceSymbol.GetDeclaredAccessibilityOfMostAccessibleDescendantType">
	<summary>
 Calculate declared accessibility of most accessible type within this namespace or within a containing namespace recursively.
 Expected to be called at most once per namespace symbol, unless there is a race condition.
 
 Valid return values:
     Friend,
     Public,
     NotApplicable - if there are no types.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingNamespaceSymbol.AppendExtensionMethods(System.String,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.MethodSymbol})">
	<summary>
 This method is called directly by a Binder when it uses this module level namespace.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingNamespaceSymbol.BuildExtensionMethodsMap(System.Collections.Generic.Dictionary{System.String,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.MethodSymbol}})">
	<summary>
 This method is called when this namespace is part of a merged namespace and we are trying to build
 a map of extension methods for the whole merged namespace.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingNamespaceSymbol.BuildExtensionMethodsMapBucket(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.MethodSymbol},Roslyn.Compilers.VisualBasic.MethodSymbol)">
	<summary>
 Make sure we retarget methods when types of the underlying namespace add them to the map.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingNamespaceSymbol.AddExtensionMethodLookupSymbolsInfo(Roslyn.Compilers.VisualBasic.LookupSymbolsInfo,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 This method is called directly by a Binder when it uses this module level namespace.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingNamespaceSymbol.AppendExtensionMethodNamesViabilityCheck(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Make sure we retarget methods when underlying namespace checks their viability.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingNamespaceSymbol">
	<summary>
 Represents a namespace of a RetargetingModuleSymbol. Essentially this is a wrapper around 
 another NamespaceSymbol that is responsible for retargeting symbols from one assembly to another. 
 It can retarget symbols for multiple assemblies at the same time.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingNamedTypeSymbol.m_RetargetingModule">
	<summary>
 Owning RetargetingModuleSymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingNamedTypeSymbol.m_UnderlyingType">
	<summary>
 The underlying NamedTypeSymbol, cannot be another RetargetingNamedTypeSymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingNamedTypeSymbol.m_LazyCustomAttributes">
	<summary>
 Retargeted custom attributes
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingNamedTypeSymbol.AppendExtensionMethods(System.String,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.MethodSymbol})">
	<summary>
 This method is called directly by a Binder when it uses this type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingNamedTypeSymbol.AddExtensionMethodLookupSymbolsInfo(Roslyn.Compilers.VisualBasic.LookupSymbolsInfo,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 This method is called directly by a Binder when it uses this type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingNamedTypeSymbol.AppendExtensionMethodNamesViabilityCheck(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Make sure we retarget methods when underlying type checks their viability.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingNamedTypeSymbol.GenerateAllDeclarationErrors(System.Threading.CancellationToken)">
	<summary>
 Force all declaration errors to be generated.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingNamedTypeSymbol">
	<summary>
 Represents a type of a RetargetingModuleSymbol. Essentially this is a wrapper around 
 another NamedTypeSymbol that is responsible for retargeting referenced symbols from one assembly to another. 
 It can retarget symbols for multiple assemblies at the same time.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingModuleSymbol.m_RetargetingAssembly">
	<summary>
 Owning RetargetingAssemblySymbol.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingModuleSymbol.m_UnderlyingModule">
	<summary>
 The underlying ModuleSymbol, cannot be another RetargetingModuleSymbol.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingModuleSymbol.m_RetargetingAssemblyMap">
	<summary>
 The map that captures information about what assembly should be retargeted 
 to what assembly. Key is the AssemblySymbol referenced by the underlying module,
 value is the corresponding AssemblySymbol referenced by this module, and corresponding
 retargeting map for symbols.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingModuleSymbol.m_LazyCustomAttributes">
	<summary>
 Retargeted custom attributes
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingModuleSymbol.#ctor(Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAssemblySymbol,Roslyn.Compilers.VisualBasic.SourceModuleSymbol)">
	<summary>
 Constructor.
 </summary>
	<param name="retargetingAssembly">
 Owning assembly.
 </param>
	<param name="underlyingModule">
 Underlying ModuleSymbol, cannot be another RetargetingModuleSymbol.
 </param>
	<remarks></remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingModuleSymbol.UnderlyingModule">
	<summary>
 The underlying ModuleSymbol, cannot be another RetargetingModuleSymbol.
 </summary>
	<value></value>
</member><member name="M:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingModuleSymbol.SetReferences(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.AssemblyIdentity},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.AssemblySymbol},Roslyn.Compilers.VisualBasic.SourceAssemblySymbol)">
	<summary>
 A helper method for AssemblyManager to set AssemblySymbols for assemblies 
 referenced by this module.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingModuleSymbol">
	<summary>
 Represents a primary module of a RetargetingAssemblySymbol. Essentially this is a wrapper around 
 another SourceModuleSymbol that is responsible for retargeting symbols from one assembly to another. 
 It can retarget symbols for multiple assemblies at the same time.
 
 Here is how retargeting is implemented in general:
 - Symbols from underlying module are substituted with retargeting symbols.
 - Symbols from referenced assemblies that can be reused as is (i.e. don't have to be retargeted) are
   used as is.
 - Symbols from referenced assemblies that must be retargeted are substituted with result of retargeting.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingMethodSymbol.m_RetargetingModule">
	<summary>
 Owning RetargetingModuleSymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingMethodSymbol.m_UnderlyingMethod">
	<summary>
 The underlying MethodSymbol, cannot be another RetargetingMethodSymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingMethodSymbol.m_LazyCustomAttributes">
	<summary>
 Retargeted custom attributes
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingMethodSymbol.m_LazyReturnTypeCustomAttributes">
	<summary>
 Retargeted return type attributes
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingMethodSymbol">
	<summary>
 Represents a method in a RetargetingModuleSymbol. Essentially this is a wrapper around 
 another MethodSymbol that is responsible for retargeting symbols from one assembly to another. 
 It can retarget symbols for multiple assemblies at the same time.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingFieldSymbol.m_RetargetingModule">
	<summary>
 Owning RetargetingModuleSymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingFieldSymbol.m_UnderlyingField">
	<summary>
 The underlying FieldSymbol, cannot be another RetargetingFieldSymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingFieldSymbol.m_LazyCustomAttributes">
	<summary>
 Retargeted custom attributes
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingFieldSymbol">
	<summary>
 Represents a field in a RetargetingModuleSymbol. Essentially this is a wrapper around 
 another FieldSymbol that is responsible for retargeting symbols from one assembly to another. 
 It can retarget symbols for multiple assemblies at the same time.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingEventSymbol.m_RetargetingModule">
	<summary>
 Owning RetargetingModuleSymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingEventSymbol.m_UnderlyingEvent">
	<summary>
 The underlying EventSymbol, cannot be another RetargetingEventSymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingEventSymbol.m_LazyCustomAttributes">
	<summary>
 Retargeted custom attributes
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAttributeData.GetSystemType(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Gets the retargeted System.Type type symbol.
 </summary>
	<param name="targetSymbol">Target symbol on which this attribute is applied.</param>
	<returns>Retargeted System.Type type symbol.</returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAttributeData">
	<summary>
 Represents a retargeting custom attribute
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAssemblySymbol.m_UnderlyingAssembly">
	<summary>
 The underlying AssemblySymbol, it leaks symbols that should be retargeted.
 This cannot be an instance of RetargetingAssemblySymbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAssemblySymbol.m_Modules">
	<summary>
 The list of contained ModuleSymbol objects. First item in the list
 is RetargetingModuleSymbol that wraps corresponding SourceModuleSymbol 
 from m_UnderlyingAssembly.Modules list, the rest are PEModuleSymbols for 
 added modules.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAssemblySymbol.m_NoPiaResolutionAssemblies">
	<summary>
 An array of assemblies involved in canonical type resolution of
 NoPia local types defined within this assembly. In other words, all 
 references used by a compilation referencing this assembly.
 The array and its content is provided by AssemblyManager and must not be modified.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAssemblySymbol.m_LinkedReferencedAssemblies">
	<summary>
 An array of assemblies referenced by this assembly, which are linked (/l-ed) by 
 each compilation that is using this AssemblySymbol as a reference. 
 If this AssemblySymbol is linked too, it will be in this array too.
 The array and its content is provided by AssemblyManager and must not be modified.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAssemblySymbol.m_NoPiaUnificationMap">
	<summary>
 A map from a local NoPia type to corresponding canonical type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAssemblySymbol.m_IsLinked">
	<summary>
 Assembly is /l-ed by compilation that is using it as a reference.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAssemblySymbol.m_LazyCustomAttributes">
	<summary>
 Retargeted custom attributes
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAssemblySymbol.#ctor(Roslyn.Compilers.VisualBasic.SourceAssemblySymbol,System.Boolean)">
	<summary>
 Constructor.
 </summary>
	<param name="underlyingAssembly">
 The underlying AssemblySymbol, cannot be an instance of RetargetingAssemblySymbol.
 </param>
	<param name="isLinked">
 Assembly is /l-ed by compilation that is using it as a reference.
 </param>
</member><member name="P:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAssemblySymbol.UnderlyingAssembly">
	<summary>
 The underlying AssemblySymbol.
 This cannot be an instance of RetargetingAssemblySymbol.
 </summary>
	<value></value>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAssemblySymbol.GetDeclaredSpecialType(Roslyn.Compilers.SpecialType)">
	<summary>
 Lookup declaration for FX type in this Assembly.
 </summary>
	<param name="type"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.Retargeting.RetargetingAssemblySymbol">
	<summary>
 Essentially this is a wrapper around another AssemblySymbol that is responsible for retargeting
 symbols from one assembly to another. It can retarget symbols for multiple assemblies at the same time. 
 
 For example, compilation C1 references v1 of Lib.dll and compilation C2 references C1 and v2 of Lib.dll. 
 In this case, in context of C2, all types from v1 of Lib.dll leaking through C1 (through method 
 signatures, etc.) must be retargeted to the types from v2 of Lib.dll. This is what 
 RetargetingAssemblySymbol is responsible for. In the example above, modules in C2 do not 
 reference C1.m_AssemblySymbol, but reference a special RetargetingAssemblySymbol created for 
 C1 by AssemblyManager.
 
 Here is how retargeting is implemented in general:
 - Symbols from underlying assembly are substituted with retargeting symbols.
 - Symbols from referenced assemblies that can be reused as is (i.e. doesn't have to be retargeted) are
   used as is.
 - Symbols from referenced assemblies that must be retargeted are substituted with result of retargeting.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ReducedExtensionMethodSymbol.Create(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.MethodSymbol,System.Int32)">
	<summary>
 If this is an extension method that can be applied to an instance of the given type,
 returns the curried method symbol thus formed. Otherwise, returns Nothing.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ReducedExtensionMethodSymbol.ReducedTypeParameterSymbol">
	<summary>
 Represents type parameter of a curried extension method definition.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ReducedExtensionMethodSymbol.ReducedParameterSymbol">
	<summary>
 Represents parameter of a curried extension method definition.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ReducedExtensionMethodSymbol">
	<summary>
 Represents a curried extension method definition - first parameter and fixed 
 type parameters removed.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PropertySymbolExtensions.GetCanBeCalledWithNoParameters(Roslyn.Compilers.VisualBasic.PropertySymbol)">
	<summary>
 Determines if the property can be accessed with empty parameter list.
 </summary>
	<param name="prop">The property.</param><returns></returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.Type">
	<summary>
 Gets the type of the property. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.TypeCustomModifiers">
	<summary>
 Returns the list of custom modifiers, if any, associated with the type of the property. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.Parameters">
	<summary>
 Gets the parameters of this property. If this property has no parameters, returns
 an empty list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.HasSpecialName">
	<summary>
  True if this symbol has a special name (metadata flag SpecialName is set).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.IsDefault">
	<summary>
 Returns true if this property is a default property. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.IsReadOnly">
	<summary>
 Returns true if this is a read-only property; i.e., has no set accessor.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.IsReadable">
	<summary>
 Indicates if the property can be read, which means this 
 type overrides OR inherits a getter for this property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.IsWriteOnly">
	<summary>
 Returns true if this is a write-only property; i.e., has no get accessor.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.IsWritable">
	<summary>
 Indicates if the property can be written into, which means this 
 type overrides OR inherits a setter for this property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.GetMethod">
	<summary>
 Gets the associated "get" method for this property. If this property
 has no get accessor, returns Nothing.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PropertySymbol.GetMostDerivedGetMethod">
	<summary>
 Retrieves Get method for this property or 'most derived' Get method from closest 
 overridden property if such property exists.
 
 NOTE: It is not possible in VB, but possible in other langauges (for example in C#) to
       override read-write property an provide override only for setter, thus inheriting 
       getter's implementation. This method will find the Get method from the most-derived
       overridded property in this case
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.SetMethod">
	<summary>
 Gets the associated "set" method for this property. If this property
 has no set accessor, returns Nothing.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PropertySymbol.GetMostDerivedSetMethod">
	<summary>
 Retrieves Set method for this property or 'most derived' Set method from closest 
 overridden property if such property exists.
 
 NOTE: It is not possible in VB, but possible in other langauges (for example in C#) to
       override read-write property an provide override only for getter, thus inheriting 
       setter's implementation. This method will find the Set method from the most-derived
       overridded property in this case
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.IsOverloads">
	<summary>
 Returns true if this property hides a base property by name and signature.
 The equivalent of the "hidebysig" flag in metadata. 
 </summary>
	<remarks>
 This property should not be confused with general property overloading in Visual Basic, and is not directly related. 
 This property will only return true if this method hides a base property by name and signature (Overloads keyword).
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.OverriddenProperty">
	<summary>
 If this property overrides another property (because it both had the Overrides modifier
 and there correctly was a property to override), returns the overridden property.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PropertySymbol.GetAccessorOverride(System.Boolean)">
	<summary>
 Helper method for accessors to get the overridden accessor methods. Should only be called by the
 accessor method symbols.
 </summary>
	<param name="getter">True to get overridden getters, False to get overridden setters</param>
	<returns>All the accessors of the given kind implemented by this property.</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.ExplicitInterfaceImplementations">
	<summary>
 Returns interface properties explicitly implemented by this property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.MeParameter">
	<summary>
 Get the "this" parameter for this property.  This is only valid for source fields.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.HighestPriorityUseSiteError">
	<summary>
 Return error code that has highest priority while calculating use site error for this symbol. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PropertySymbol.IsWithEvents">
	<summary>
 Returns true if this property is an auto-created WithEvents property that 
 takes place of a field member when the field is marked as WithEvents.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PropertySymbol.CloneParameters(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.ParameterSymbol})">
	<summary>
 Clone the property parameters for the accessor method. The
 parameters are cloned (rather than referenced from the property)
 since the ContainingSymbol needs to be set to the accessor.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.PropertySymbol">
	<summary>
 Represents a property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.PropertySignatureComparer.AllAspectsSignatureComparer">
	<summary>
 This instance is used to compare all aspects.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.PropertySignatureComparer.RuntimePropertySignatureComparer">
	<summary>
 This instance is intended to reflect the definition of signature equality used by the runtime (ECMA 335 Section 8.6.1.6).
 It considers type, name, parameters, and custom modifiers.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.PropertySignatureComparer.RetargetedExplicitPropertyImplementationComparer">
	<summary>
 This instance is used to search for properties that have identical signatures in every regard.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.PropertySignatureComparer">
	<summary>
 Implementation of IEqualityComparer for PropertySymbols, with options for various aspects
 to compare.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.PEOrSourceOrMergedNamespaceSymbol.m_lazyExtensionMethodsMap">
	<summary>
 For a given namespace in context of a particular Compilation all binders use 
 either a compilation merged namespace symbol, or a module level namespace symbol 
 (PE, Source or Retargeting). In order to speed-up lookup of extension methods performed 
 by a binder, we build and cache a map of all extension methods declared within the namespace 
 grouped by name (case-insensitively). 
 
 If binder uses compilation merged namespace symbol, the map is built across all underlying 
 module level namespace symbols, separate maps for underlying namespace symbols are not built.
 
 If binder uses Retargeting module level namespace symbol, we build the map for the underlying 
 namespace symbol instead and push all requests through the underlying namespace.
 
 The map actually stores ReadOnlyArray(Of MethodSymbol), but we are using ReadOnlyArray(Of Symbol)
 in order to be able to pass the map to a more general API.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.PEOrSourceOrMergedNamespaceSymbol.DeclaredAccessibilityOfMostAccessibleDescendantType">
	<summary>
 Returns declared accessibility of most accessible type within this namespace or within a containing namespace recursively.
 Valid return values:
     Friend,
     Public,
     NotApplicable - if there are no types.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PEOrSourceOrMergedNamespaceSymbol.AppendExtensionMethods(System.String,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.MethodSymbol})">
	<summary>
 This is an entry point for the Binder to collect extension methods with the given name 
 declared within this (compilation merged or module level) namespace, so that methods 
 from the same type are grouped together. 
 
 A cached map of extension methods is used to optimize the lookup.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PEOrSourceOrMergedNamespaceSymbol.AddExtensionMethodLookupSymbolsInfo(Roslyn.Compilers.VisualBasic.LookupSymbolsInfo,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.NamespaceSymbol)">
	<summary>
 Add names of viable extension methods declared in this (compilation merged or module level) 
 namespace to nameSet parameter.
 
 The 'appendThrough' parameter allows RetargetingNamespaceSymbol to delegate majority of the work 
 to the underlying namespace symbol, but still perform viability check on RetargetingMethodSymbol.
 
 A cached map of extension methods is used to optimize the operation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.PEOrSourceOrMergedNamespaceSymbol.EnsureExtensionMethodsAreCollected">
	<summary>
 Build and cache a map of extension methods for this namespace.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.PEOrSourceOrMergedNamespaceSymbol">
	<summary>
 Represents a namespace.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.IsByRef">
	<summary>
 Is this ByRef parameter.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.IsExplicitByRef">
	<summary>
 Is parameter explicitly declared ByRef. Can be different from IsByRef only for
 String parameters of Declare methods.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.IsMetadataOut">
	<summary>
 Is this Out parameter (metadata flag In is set).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.IsMetadataIn">
	<summary>
 Is this In parameter (metadata flag Out is set).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.IsOut">
	<summary>
 True if the parameter flows data out of the method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.MarshallingInformation">
	<summary>
 Describes how the parameter is marshalled when passed to native code.
 Null if no specific marshalling information is available for the parameter.
 </summary>
	<remarks>PE symbols don't provide this information and always return Nothing.</remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.MarshallingType">
	<summary>
 Returns the marshalling type of this field, or 0 if marshalling information isn't available.
 </summary>
	<remarks>
 By default this information is extracted from <see cref="P:MarshallingInformation"/> if available. 
 Since the compiler does only need to know the marshalling type of symbols that aren't emitted 
 PE symbols just decode the type from metadata and don't provide full marshalling information.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.Type">
	<summary>
 Gets the type of this parameter.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.CustomModifiers">
	<summary>
 The list of custom modifiers, if any, associated with the parameter.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.Ordinal">
	<summary>
 Gets the ordinal order of this parameter. The first type parameter has ordinal zero.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.IsParamArray">
	<summary>
 Returns true if this parameter was declared as a ParamArray. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.IsOptional">
	<summary>
 Returns true if this parameter was declared as Optional. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.HasDefaultValue">
	<summary>
 Returns true if the parameter explicitly specifies a default value to be passed
 when no value is provided as an argument to a call.
 </summary>
	<remarks>
 True if the parameter has a default value defined in source via an optional parameter syntax, 
 or the parameter is from metadata and HasDefault and Optional metadata flags are set,
 or the parameter is from metadata, has Optional flag set and <see cref="T:System.Runtime.CompilerServices.DateTimeConstantAttribute"/>
 or <see cref="T:System.Runtime.CompilerServices.DecimalConstantAttribute"/> is specified.
 
 The default value can be obtained with the <see cref="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.DefaultValue"/> property.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.DefaultValue">
	<summary>
 Returns the default value of this parameter. If HasDefaultValue
 returns false, then this property throws an InvalidOperationException.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParameterSymbol.DefaultConstantValue(Roslyn.Compilers.VisualBasic.SymbolsInProgress{Roslyn.Compilers.VisualBasic.ParameterSymbol})">
	<summary>
 Returns the default value of this parameter as a ConstantValue.
 Return nothing if there isn't a default value.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ParameterSymbol.ChangeOwner(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Create a new ParameterSymbol with everything the same except the owner. Used for property
 accessor methods, for example.
 </summary>
	<remarks>
 Note: This is only implemented for those subclasses (e.g., SourceParameterSymbol) for which it
 is required. Thus, the base implementation throws an exception instead of being MustOverride.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.ParameterSymbol">
	<summary>
 Represents a parameter of a method or property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverriddenMembersResult`1.OverriddenMembers">
	<summary>
 The member(s) that are potentially being overridden. This collection only contains 
 candidates having signature 'exactly' matching the signature of the method/property. 
 
 'Exact' signature match is defined as 'general' signature match plus NO
 mismatches in total number of parameters or optional parameter types.
 
 See comments on InaccessibleMembers for more details on 'general' signature match.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverriddenMembersResult`1.InexactOverriddenMembers">
	<summary>
 The member(s) that are potentially being overridden. This collection only contains 
 candidates having signature 'generally' matching the signature of the method/property. 
 
 Two signatures 'generally' match if DetailedSignatureCompare (...) returns no 
 mismatches defined in SymbolComparisonResults.AllMismatches ignoring mismatches 
 grouped in SymbolComparisonResults.MismatchesForConflictingMethods.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverriddenMembersResult`1.InaccessibleMembers">
	<summary>
 Members that would be in OverriddenMembers if they were accessible.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.OverriddenMembersResult`1">
	<summary>
 Groups the information computed by MakeOverriddenMembers.
 </summary>
	<remarks>
 In C# this class also stores hidden members (and is named OverriddenOrHiddenMembersResult). 
 The way VB warns on hidden members, this did not turn out to be useful.
 </remarks>
	<typeparam name="TSymbol">Expected to be a member symbol type (e.g. method, property).</typeparam>
</member><member name="T:Roslyn.Compilers.VisualBasic.NoPiaMissingCanonicalTypeSymbol">
	<summary>
 A NoPiaMissingCanonicalTypeSymbol is a special kind of ErrorSymbol that represents
 a NoPia embedded type symbol that was attempted to be substituted with canonical type, 
 but the canonocal type couldn't be found.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.NoPiaIllegalGenericInstantiationSymbol">
	<summary>
 A NoPiaIllegalGenericInstantiationSymbol is a special kind of ErrorSymbol that represents
 a generic type instantiation that cannot cross assembly boundaries according to NoPia rules.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.NoPiaAmbiguousCanonicalTypeSymbol">
	<summary>
 A NoPiaAmbiguousCanonicalTypeSymbol is a special kind of ErrorSymbol that represents
 a NoPia embedded type symbol that was attempted to be substituted with canonical type, 
 but the canonocal type was ambiguous.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.NonMissingModuleSymbol.m_ReferencedAssemblySymbols">
	<summary>
 An array of AssemblySymbol objects corresponding to assemblies referenced by this module.
 The array and its content is provided by AssemblyManager and must not be modified.
 Items at the same position from this array and from GetReferencedAssemblySymbols should 
 correspond to each other. If reference is not resolved by compiler, corresponding item in 
 this array contains MissingAssemblySymbol.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.NonMissingModuleSymbol.m_ReferencedAssemblies">
	<summary>
 An array of assembly identities for assemblies referenced by this module.
 The array and its content is provided by AssemblyManager and must not be modified.
 Items at the same position from this array and from ModuleSymbol.m_ReferencedAssemblySymbols
 should correspond to each other. This array is returned by GetReferencedAssemblies() method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NonMissingModuleSymbol.IsMissing">
	<summary>
 Does this symbol represent a missing Module.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NonMissingModuleSymbol.GetReferencedAssemblies">
	<summary>
 Returns an array of assembly identities for assemblies referenced by this module.
 Items at the same position from GetReferencedAssemblies and from GetReferencedAssemblySymbols 
 should correspond to each other.
 
 The array and its content is provided by AssemblyManager and must not be modified.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NonMissingModuleSymbol.GetReferencedAssemblySymbols">
	<summary>
 Returns an array of AssemblySymbol objects corresponding to assemblies referenced 
 by this module. Items at the same position from GetReferencedAssemblies and 
 from GetReferencedAssemblySymbols should correspond to each other. If reference is 
 not resolved by compiler, GetReferencedAssemblySymbols returns MissingAssemblySymbol in the
 correspnding item.
 
 The array and its content is provided by AssemblyManager and must not be modified.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NonMissingModuleSymbol.SetReferences(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.AssemblyIdentity},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.AssemblySymbol},Roslyn.Compilers.VisualBasic.SourceAssemblySymbol)">
	<summary>
 A helper method for AssemblyManager to set assembly identities for assemblies 
 referenced by this module and corresponding AssemblySymbols.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NonMissingModuleSymbol.LookupTopLevelMetadataType(Roslyn.Compilers.Internal.MetadataTypeName@)">
	<summary>
 Lookup a top level type referenced from metadata, names should be
 compared case-sensitively.
 </summary>
	<param name="emittedName">
 Full type name, possibly with generic name mangling.
 </param>
	<returns>
 Symbol for the type, or MissingMetadataSymbol if the type isn't found.
 </returns>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.NonMissingModuleSymbol">
	<summary>
 A <see cref="T:Roslyn.Compilers.VisualBasic.NonMissingModuleSymbol"/> is a special kind of <see cref="T:Roslyn.Compilers.VisualBasic.ModuleSymbol"/> that represents
 a module that is not missing, i.e. the "real" thing.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.NonMissingAssemblySymbol.m_EmittedNameToTypeMap">
	<summary>
 This is a cache similar to the one used by MetaImport::GetTypeByName
 in native compiler. The difference is that native compiler pre-populates 
 the cache when it loads types. Here we are populating the cache only
 with things we looked for, so that next time we are looking for the same 
 thing, the lookup is fast. This cache also takes care of TypeForwarders. 
 Gives about 8% win on subsequent lookups in some scenarios.     
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.NonMissingAssemblySymbol.m_lazyGlobalNamespace">
	<summary>
 The global namespace symbol. Lazily populated on first access.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NonMissingAssemblySymbol.IsMissing">
	<summary>
 Does this symbol represent a missing assembly.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NonMissingAssemblySymbol.GlobalNamespace">
	<summary>
 Gets the merged root namespace that contains all namespaces and types defined in the modules
 of this assembly. If there is just one module in this assembly, this property just returns the 
 GlobalNamespace of that module.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NonMissingAssemblySymbol.LookupTopLevelMetadataType(Roslyn.Compilers.Internal.MetadataTypeName@)">
	<summary>
 Lookup a top level type referenced from metadata, names should be
 compared case-sensitively.
 </summary>
	<param name="emittedName">
 Full type name with generic name mangling.
 </param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.NonMissingAssemblySymbol.LookupTopLevelMetadataTypeWithCycleDetection(Roslyn.Compilers.Internal.MetadataTypeName@,Roslyn.Utilities.ConsList{Roslyn.Compilers.VisualBasic.AssemblySymbol})">
	<summary>
 NOTE: Methods other than this one should call LookupTopLevelMetadataType, rather than this method.
 
 Lookup a top level type referenced from metadata, names should be
 compared case-sensitively.  Detect cycles during lookup.
 </summary>
	<param name="emittedName">
 Full type name, possibly with generic name mangling.
 </param>
	<param name="visitedAssemblies">
 List of assemblies lookup has already visited (since type forwarding can introduce cycles).
 </param>
	<remarks>
 This is the only place where we look into other assemblies for forwarding types, so this is the only
 place where we need to pass along a list of visited assemblies.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.NonMissingAssemblySymbol.CachedTypeByEmittedName(System.String)">
	<summary>
 For test purposes only.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NonMissingAssemblySymbol.EmittedNameToTypeMapCount">
	<summary>
 For test purposes only.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.NonMissingAssemblySymbol">
	<summary>
 A <see cref="T:Roslyn.Compilers.VisualBasic.NonMissingAssemblySymbol"/> is a special kind of <see cref="T:Roslyn.Compilers.VisualBasic.AssemblySymbol"/> that represents
 an assembly that is not missing, i.e. the "real" thing.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceSymbol.GetNamespaceMembers">
	<summary>
 Get all the members of this symbol that are namespaces.
 </summary>
	<returns>A ReadOnlyArray containing all the namespaces that are members of this symbol. If this symbol has no namespace members,
 returns an empty ReadOnlyArray. Never returns Nothing.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceSymbol.GetModuleMembers">
	<summary>
 Get all the members of this symbol that are modules.
 </summary>
	<returns>A ReadOnlyArray containing all the types that are members of this namespace. If this namespace has no module members,
 returns an empty ReadOnlyArray. Never returns Nothing.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceSymbol.GetModuleMembers(System.String)">
	<summary>
 Get all the members of this symbol that are modules that have a particular name
 </summary>
	<returns>A ReadOnlyArray containing all the modules that are members of this namespace with the given name. 
 If this symbol has no modules with this name,
 returns an empty ReadOnlyArray. Never returns Nothing.</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceSymbol.IsGlobalNamespace">
	<summary>
 Returns whether this namespace is the unnamed, global namespace that is 
 at the root of all namespaces.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceSymbol.Extent">
	<summary>
 Namespaces are by their nature open-ended, but a NamespaceSymbol contains
 a specific set of members. The set of members contained by a NamespaceSymbol is denoted
 by the Extent of the namespace. If a Namespace has an Extent of NamespaceExtent.Module,
 it contains members of the namespace that are present in a particular module. If a Namespace has
 an extent of NamespaceExtent.Compilation, it contains all members of the namespace in a compilation,
 including those defined in source and all directly referenced metadata assemblies (or added metadata modules). 
 </summary>
	<returns>NamespaceExtent.Module if this namespace is restricted to members from a single module. 
 NamespaceExtend.Compilation if this namespace is merged across source and directly referenced metadata
 in a compilation.</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceSymbol.ConstituentNamespaces">
	<summary>
 If a namespace has Assembly or Compilation extent, it may be composed of multiple
 namespaces that are merged together. If so, ConstituentNamespaces returns
 all the namespaces that were merged. If this namespace was not merged, returns
 an array containing only this namespace.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceSymbol.ContainingAssembly">
	<summary>
 Containing assembly.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceSymbol.ContainingModule">
	<summary>
 Containing module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceSymbol.Kind">
	<summary>
 Gets the kind of this symbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceSymbol.Accept``2(Roslyn.Compilers.VisualBasic.SymbolVisitor{``0,``1},``0)">
	<summary>
 Implements visitor pattern.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceSymbol.DeclaredAccessibility">
	<summary>
 Get this accessibility that was declared on this symbol. For symbols that do
 not have accessibility declared on them, returns NotApplicable.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceSymbol.DeclaredAccessibilityOfMostAccessibleDescendantType">
	<summary>
 Returns declared accessibility of most accessible type within this namespace or within a containing namespace recursively.
 Valid return values:
     Friend,
     Public,
     NotApplicable - if there are no types.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceSymbol.GetDeclaredAccessibilityOfMostAccessibleDescendantType">
	<summary>
 Calculate declared accessibility of most accessible type within this namespace or within a containing namespace recursively.
 Expected to be called at most once per namespace symbol, unless there is a race condition.
 
 Valid return values:
     Friend,
     Public,
     NotApplicable - if there are no types.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceSymbol.ContainsTypesAccessibleFrom(Roslyn.Compilers.VisualBasic.AssemblySymbol)">
	<summary>
 Returns true if namespace contains types accessible from the target assembly.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceSymbol.IsShared">
	<summary>
 Returns true if this symbol is "shared"; i.e., declared with the "Shared"
 modifier or implicitly always shared.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceSymbol.LookupNestedNamespace(Roslyn.Compilers.ReadOnlyArray{System.String})">
	<summary>
 Lookup a nested namespace.
 </summary>
	<param name="names">
 Sequence of names for nested child namespaces.
 </param>
	<returns>
 Symbol for the most nested namespace, if found. Nothing 
 if namespace or any part of it can not be found.
 </returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceSymbol.LookupMetadataType(Roslyn.Compilers.Internal.MetadataTypeName@)">
	<summary>
 Lookup an immediately nested type referenced from metadata, names should be
 compared case-sensitively.
 </summary>
	<param name="fullEmittedName">
 Full type name possibly with generic name mangling.
 </param>
	<returns>
 Symbol for the type, or MissingMetadataSymbol if the type isn't found.
 </returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceSymbol.AppendExtensionMethods(System.String,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.MethodSymbol})">
	<summary>
 This is an entry point for the Binder to collect extension methods with the given name 
 declared within this (compilation merged or module level) namespace, so that methods 
 from the same type are grouped together. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceSymbol.AddExtensionMethodLookupSymbolsInfo(Roslyn.Compilers.VisualBasic.LookupSymbolsInfo,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 This is an entry point for the Binder. Its purpose is to add names of viable extension methods declared 
 in this (compilation merged or module level) namespace to nameSet parameter.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceSymbol.AddExtensionMethodLookupSymbolsInfo(Roslyn.Compilers.VisualBasic.LookupSymbolsInfo,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.NamespaceSymbol)">
	<summary>
 Add names of viable extension methods declared in this (compilation merged or module level) 
 namespace to nameSet parameter.
 
 The 'appendThrough' parameter allows RetargetingNamespaceSymbol to delegate majority of the work 
 to the underlying namespace symbol, but still perform viability check on RetargetingMethodSymbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceSymbol.BuildExtensionMethodsMap(System.Collections.Generic.Dictionary{System.String,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.MethodSymbol}})">
	<summary>
 Populate the map with all extension methods declared within this namespace, so that methods from
 the same type were grouped together within each bucket. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceSymbol.TypesToCheckForExtensionMethods">
	<summary>
 Return the set of types that should be checked for presence of extension methods in order to build
 a map of extension methods for the namespace. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceSymbol.BuildExtensionMethodsMap(System.Collections.Generic.Dictionary{System.String,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.MethodSymbol}},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.Symbol}}})">
	<summary>
 Populate the map with all extension methods in membersByName parameter.
 
 Returns True if an extension method was appended, False otherwise.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceSymbol.BuildExtensionMethodsMapBucket(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.MethodSymbol},Roslyn.Compilers.VisualBasic.MethodSymbol)">
	<summary>
 This method is overriden by RetargetingNamespaceSymbol and allows it to delegate majority of the work 
 to the underlying namespace symbol, but still retarget method symbols before they are added to the map
 of extension methods.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.NamespaceSymbol">
	<summary>
 Represents a namespace.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.IsNamespace">
	<summary>
 Returns true if this symbol is a namespace. If its not a namespace, it must be a type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.IsType">
	<summary>
 Returns true if this symbols is a type. Equivalent to Not IsNamespace.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.GetMembers">
	<summary>
 Get all the members of this symbol.
 </summary>
	<returns>A ReadOnlyArray containing all the members of this symbol. If this symbol has no members,
 returns an empty ReadOnlyArray. Never returns Nothing.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.GetMembers(System.String)">
	<summary>
 Get all the members of this symbol that have a particular name.
 </summary>
	<returns>A ReadOnlyArray containing all the members of this symbol with the given name. If there are
 no members with this name, returns an empty ReadOnlyArray. Never returns Nothing.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.GetTypeMembers">
	<summary>
 Get all the members of this symbol that are types.
 </summary>
	<returns>A ReadOnlyArray containing all the types that are members of this symbol. If this symbol has no type members,
 returns an empty ReadOnlyArray. Never returns Nothing.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.GetTypeMembers(System.String)">
	<summary>
 Get all the members of this symbol that are types that have a particular name, and any arity.
 </summary>
	<returns>A ReadOnlyArray containing all the types that are members of this symbol with the given name. 
 If this symbol has no type members with this name,
 returns an empty ReadOnlyArray. Never returns Nothing.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.GetTypeMembers(System.String,System.Int32)">
	<summary>
 Get all the members of this symbol that are types that have a particular name and arity.
 </summary>
	<returns>An ReadOnlyArray containing all the types that are members of this symbol with the given name and arity.
 If this symbol has no type members with this name and arity,
 returns an empty ReadOnlyArray. Never returns Nothing.</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.IsMustOverride">
	<summary>
 Returns true if this symbol was declared as requiring an override; i.e., declared
 with the "MustOverride" modifier. Never returns true for types. 
 </summary>
	<returns>
 Always returns False.
 </returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.IsNotOverridable">
	<summary>
 Returns true if this symbol was declared to override a base class members and was
 also restricted from further overriding; i.e., declared with the "NotOverridable"
 modifier. Never returns true for types.
 </summary>
	<returns>
 Always returns False.
 </returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.IsOverridable">
	<summary>
 Returns true if this member is overridable, has an implementation,
 and does not override a base class member; i.e., declared with the "Overridable"
 modifier. Does not return true for members declared as MustOverride or Overrides.
 </summary>
	<returns>
 Always returns False.
 </returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.IsOverrides">
	<summary>
 Returns true if this symbol was declared to override a base class members; i.e., declared
 with the "Overrides" modifier. Still returns true if the members was declared
 to override something, but (erroneously) no member to override exists.
 </summary>
	<returns>
 Always returns False.
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.AddExtensionMethodLookupSymbolsInfo(Roslyn.Compilers.VisualBasic.LookupSymbolsInfo,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.Symbol}}})">
	<summary>
 This is a helper method shared between NamedTypeSymbol and NamespaceSymbol.
 
 Its purpose is to add names of extension methods found in membersByName parameter
 to nameSet parameter. Method's viability check is delegated to overridable method
 AppendExtensionMethodNamesViabilityCheck, which is overriden by RetargetingNamedtypeSymbol
 and RetargetingNamespaceSymbol in order to perform the check on corresponding RetargetingMethodSymbol.
 
 Returns true if there were extension methods among the members, 
 regardless whether their names were added into the set. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.AppendExtensionMethodNamesViabilityCheck(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Perform extension method viability check within AppendExtensionMethodNames method above.
 This method is overriden by RetargetingNamedtypeSymbol and RetargetingNamespaceSymbol in order to 
 perform the check on corresponding RetargetingMethodSymbol.
 
 Returns true if the method is viable. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol.GetNamespaceOrTypeByQualifiedName(System.Collections.Generic.IEnumerable{System.String})">
	<summary> 
 Finds types or namespaces described by a qualified name. 
 </summary>
	<param name="qualifiedName">Sequence of simple plain names.</param>
	<returns> A set of namespace or type symbols with given qualified name (might comprise of types with multiple generic arities),  
 or an empty set if the member can't be found (the qualified name is ambiguous or the symbol doesn't exist). 
 </returns>
	<remarks> 
 "C.D" matches C.D, C(Of T).D, C(Of S,T).D(Of U), etc. 
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol">
	<summary>
 Represents either a namespace or a type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceExtent.Kind">
	<summary>
 Returns what kind of extent: Module, Assembly, or Compilation.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceExtent.Module">
	<summary>
 If the Kind is ExtendKind.Module, returns the module symbol that this namespace
 encompasses. Otherwise throws InvalidOperationException.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceExtent.Assembly">
	<summary>
 If the Kind is ExtendKind.Assembly, returns the assembly symbol that this namespace
 encompasses. Otherwise throws InvalidOperationException.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamespaceExtent.Compilation">
	<summary>
 If the Kind is ExtendKind.Compilation, returns the compilation symbol that this namespace
 encompasses. Otherwise throws InvalidOperationException.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceExtent.#ctor(Roslyn.Compilers.VisualBasic.ModuleSymbol)">
	<summary>
 Create a NamespaceExtent that represents a given ModuleSymbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceExtent.#ctor(Roslyn.Compilers.VisualBasic.AssemblySymbol)">
	<summary>
 Create a NamespaceExtent that represents a given AssemblySymbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceExtent.#ctor(Roslyn.Compilers.VisualBasic.Compilation)">
	<summary>
 Create a NamespaceExtent that represents a given Compilation.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.NamespaceExtent">
	<summary>
 A NamespaceExtent represents whether a namespace contains types and sub-namespaces from a particular module,
 assembly, or merged across all modules (source and metadata) in a particular compilation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbolExtensions.IsOrInGenericType(Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Safe to call on a null reference.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbolExtensions.FindFieldOrProperty(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,System.String,Roslyn.Compilers.TextSpan,Roslyn.Compilers.VisualBasic.SyntaxTree)">
	<summary>
 Given a name, find a member field or property (ignoring all other members) in a type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbolExtensions.AsUnboundGenericType(Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Given a possibly constructed/specialized generic type, create a symbol
 representing an unbound generic type for its definition.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.Arity">
	<summary>
 Returns the arity of this type, or the number of type parameters it takes.
 A non-generic type has zero arity.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.TypeParameters">
	<summary>
 Returns the type parameters that this type has. If this is a non-generic type,
 returns an empty ReadOnlyArray.  
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.TypeArguments">
	<summary>
 Returns the type arguments that have been substituted for the type parameters. 
 If nothing has been substituted for a give type parameters,
 then the type parameter itself is consider the type argument.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.ConstructedFrom">
	<summary>
 Returns the type symbol that this type was constructed from. This type symbol
 has the same containing type, but has type arguments that are the same
 as the type parameters (although its containing type might not).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.EnumUnderlyingType">
	<summary>
 For enum types, gets the underlying type. Returns null on all other
 kinds of types.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.AssociatedEvent">
	<summary>
 For implicitly declared delegate types returns the EventSymbol that caused this
 delegate type to be generated.
 For all other types returns null.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.KnownCircularStruct">
	<summary>
 Returns True for one of the types from a set of Structure types if
 that set represents a cycle. This property is intended for flow
 analysis only since it is only implemented for source types,
 and only returns True for one of the types within a cycle, not all.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.MangleName">
	<summary>
 Should the name returned by Name property be mangled with [`arity] suffix in order to get metadata name.
 Must return False for a type with Arity == 0.
 </summary>
	<remarks>
 I intentionally do not provide default implementation so that devs would be forced to think about 
 what the appropriate implementation should be for each new subclass they introduce.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.HasSpecialName">
	<summary>
  True if this symbol has a special name (metadata flag SpecialName is set).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.IsSerializable">
	<summary>
  True if this type is considered serializable (metadata flag Serializable is set).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.DelegateInvokeMethod">
	<summary>
 For delegate types, gets the delegate's invoke method.  Returns null on
 all other kinds of types.  Note that is is possible to have an ill-formed 
 delegate type imported from metadata which does not have an Invoke method.
 Such a type will be classified as a delegate but its DelegateInvokeMethod
 would be null.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.IsMustInherit">
	<summary>
 Returns true if this type was declared as requiring a derived class;
 i.e., declared with the "MustInherit" modifier. Always true for interfaces.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.IsNotInheritable">
	<summary>
 Returns true if this type does not allow derived types; i.e., declared
 with the NotInheritable modifier, or else declared as a Module, Structure,
 Enum, or Delegate.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.MightContainExtensionMethods">
	<summary>
 If this property returns false, it is certain that there are no extension
 methods inside this type. If this property returns true, it is highly likely
 (but not certain) that this type contains extension methods. This property allows
 the search for extension methods to be narrowed much more quickly.
 
 !!! Note that this property can mutate during lifetime of the symbol !!!
 !!! from True to False, as we learn more about the type.             !!! 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.HasEmbeddedAttribute">
	<summary>
 Returns True if the type is marked by 'Microsoft.VisualBasic.Embedded' attribute. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.AppendExtensionMethods(System.String,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.MethodSymbol})">
	<summary>
 This method is an entry point for the Binder to collect extension methods with the given name
 declared within this named type. Overriden by RetargetingNamedTypeSymbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.BuildExtensionMethodsMap(System.Collections.Generic.Dictionary{System.String,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.MethodSymbol}},Roslyn.Compilers.VisualBasic.NamespaceSymbol)">
	<summary>
 This method is called for a type within a namespace when we are building a map of extension methods 
 for the whole (compilation merged or module level) namespace.
 
 The 'appendThrough' parameter allows RetargetingNamespaceSymbol to delegate majority of the work 
 to the underlying named type symbols, but still add RetargetingMethodSymbols to the map.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.AddExtensionMethodLookupSymbolsInfo(Roslyn.Compilers.VisualBasic.LookupSymbolsInfo,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 This is an entry point for the Binder. Its purpose is to add names of viable extension methods declared 
 in this type to nameSet parameter.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.AddExtensionMethodLookupSymbolsInfo(Roslyn.Compilers.VisualBasic.LookupSymbolsInfo,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Add names of viable extension methods declared in this type to nameSet parameter.
 
 The 'appendThrough' parameter allows RetargetingNamedTypeSymbol to delegate majority of the work 
 to the underlying named type symbol, but still perform viability check on RetargetingMethodSymbol.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.InstanceConstructors">
	<summary>
 Get the instance constructors for this type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.IsReferenceType">
	<summary>
 Returns true if this type is known to be a reference type. It is never the case
 that IsReferenceType and IsValueType both return true. However, for an unconstrained
 type parameter, IsReferenceType and IsValueType will both return false.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.IsValueType">
	<summary>
 Returns true if this type is known to be a value type. It is never the case
 that IsReferenceType and IsValueType both return true. However, for an unconstrained
 type parameter, IsReferenceType and IsValueType will both return false.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.CanConstruct">
	<summary>
 Returns True if this types has Arity &gt;= 1 and Construct can be called. This is primarily useful
 when deal with error cases.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.Construct(Roslyn.Compilers.VisualBasic.TypeSymbol[])">
	<summary>
 Returns a constructed type given its type arguments.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.Construct(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol})">
	<summary>
 Construct a new type from this type, substituting the given type arguments for the 
 type parameters. This method should only be called if this named type does not have
 any substitutions applied for its own type arguments with exception of alpha-rename
 substitution (although it's container might have substitutions applied).
 </summary>
	<param name="typeArguments">A set of type arguments to be applied. Must have the same length
 as the number of type parameters that this type has.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.CheckCanConstructAndTypeArguments(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol})">
	<summary> Checks for validity of Construct(...) on this type with these type arguments. </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.Construct(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Construct a new type from this type definition, substituting the given type arguments for the 
 type parameters. This method should only be called on the OriginalDefinition. Unlike previous 
 Construct method, this overload supports type parameter substitution on this type and any number
 of its containing types. See comments for TypeSubstitution type for more information.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.ConstructUnboundGenericType">
	<summary>
 Returns an unbound generic type of this generic named type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.DefaultPropertyName">
	<summary>
 Returns Default property name for the type.
 If there is no default property name, then Nothing is returned.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.TypeSubstitution">
	<summary>
 If this is a generic type instantiation or a nested type of a generic type instantiation,
 return TypeSubstitution for this construction. Nothing otherwise.
 Returned TypeSubstitution should target OriginalDefinition of the symbol.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.Name">
	<summary>
 Gets the name of this symbol.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.MemberNames">
	<summary>
 Collection of names of members declared within this type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.IsScriptClass">
	<summary>
 Returns true if the type is a Script class. 
 It might be an interactive submission class or a Script class in a csx file.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.IsSubmissionClass">
	<summary>
 Returns true if the type is a submission class. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.IsImplicitClass">
	<summary>
 Returns true if the type is the implicit class that holds onto invalid global members (like methods or
 statements in a non script file).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetMembers">
	<summary>
 Get all the members of this symbol.
 </summary>
	<returns>A ReadOnlyArray containing all the members of this symbol. If this symbol has no members,
 returns an empty ReadOnlyArray. Never returns Nothing.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetMembers(System.String)">
	<summary>
 Get all the members of this symbol that have a particular name.
 </summary>
	<returns>A ReadOnlyArray containing all the members of this symbol with the given name. If there are
 no members with this name, returns an empty ReadOnlyArray. Never returns Nothing.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetTypeMembers">
	<summary>
 Get all the members of this symbol that are types.
 </summary>
	<returns>A ReadOnlyArray containing all the types that are members of this symbol. If this symbol has no type members,
 returns an empty ReadOnlyArray. Never returns Nothing.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetTypeMembers(System.String)">
	<summary>
 Get all the members of this symbol that are types that have a particular name, and any arity.
 </summary>
	<returns>A ReadOnlyArray containing all the types that are members of this symbol with the given name. 
 If this symbol has no type members with this name,
 returns an empty ReadOnlyArray. Never returns Nothing.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetTypeMembers(System.String,System.Int32)">
	<summary>
 Get all the members of this symbol that are types that have a particular name and arity.
 </summary>
	<returns>A ReadOnlyArray containing all the types that are members of this symbol with the given name and arity.
 If this symbol has no type members with this name and arity,
 returns an empty ReadOnlyArray. Never returns Nothing.</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.DeclaredAccessibility">
	<summary>
 Get this accessibility that was declared on this symbol. For symbols that do
 not have accessibility declared on them, returns NotApplicable.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.Accept``2(Roslyn.Compilers.VisualBasic.SymbolVisitor{``0,``1},``0)">
	<summary>
 Supports visitor pattern. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.Kind">
	<summary>
 Gets the kind of this symbol.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.IsComImport">
	<summary>
 Returns a flag indicating whether this symbol is ComImport.
 </summary>
	<remarks>
 A type can me marked as a ComImport type in source by applying the <see cref="T:System.Runtime.InteropServices.ComImportAttribute"/>
	</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetAppliedConditionalSymbols">
	<summary>
 Returns a sequence of preprocessor symbols specified in <see cref="T:ConditionalAttribute"/> applied on this symbol, or null if there are none.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.IsConditional">
	<summary>
 Returns a flag indicating whether this symbol has at least one applied conditional attribute.
 </summary>
	<remarks>
 Forces binding and decoding of attributes.
 NOTE: Conditional symbols on base type must be inherited by derived type, but the native VB compiler doesn't do so. We maintain comptability.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetAttributeUsageInfo">
	<summary> 
 Gets the associated <see cref="T:Roslyn.Compilers.AttributeUsageInfo"/> for an attribute type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetSecurityInformation">
	<summary>
 Declaration security information associated with this type, or null if there is none.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.HasDeclarativeSecurity">
	<summary>
 True if the type has declarative security information (HasSecurity flags).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.MakeDeclaredBase(Roslyn.Utilities.ConsList{Roslyn.Compilers.VisualBasic.Symbol},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 NamedTypeSymbol calls derived implementations of this method when declared base type
 is needed for the first time.
 
 basesBeingResolved are passed if there are any types already have their bases resolved
 so that the derived implementation could avoid infinite recursion
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.MakeDeclaredInterfaces(Roslyn.Utilities.ConsList{Roslyn.Compilers.VisualBasic.Symbol},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 NamedTypeSymbol calls derived implementations of this method when declared interfaces
 are needed for the first time.
 
 basesBeingResolved are passed if there are any types already have their bases resolved
 so that the derived implementation could avoid infinite recursion
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetDeclaredBase(Roslyn.Utilities.ConsList{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 Base type as "declared".
 Declared base type may contain circularities.
 
 If DeclaredBase must be accessed while other DeclaredBases are being resolved, 
 the bases that are being resolved must be specified here to prevent potential infinite recursion.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetDeclaredInterfaces(Roslyn.Utilities.ConsList{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 Interfaces as "declared".
 Declared interfaces may contain circularities.
 
 If DeclaredInterfaces must be accessed while other DeclaredInterfaces are being resolved, 
 the bases that are being resolved must be specified here to prevent potential infinite recursion.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.MakeAcyclicBaseType(Roslyn.Compilers.DiagnosticBag)">
	<summary>
 NamedTypeSymbol calls derived implementations of this method when acyclic base type
 is needed for the first time.
 This method typically calls GetDeclaredBase, filters for 
 illegal cycles and other conditions before returning result as acyclic.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.MakeAcyclicInterfaces(Roslyn.Compilers.DiagnosticBag)">
	<summary>
 NamedTypeSymbol calls derived implementations of this method when acyclic base interfaces
 are needed for the first time.
 This method typically calls GetDeclaredInterfaces, filters for 
 illegal cycles and other conditions before returning result as acyclic.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.CheckBase(Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Do additional verification of base types the after acyclic base is found. This is
 the chance to generate diagnostics that may require walking bases and as such
 can be performed only after the base has been determined and cycles broken.
 (For instance, checking constraints on Class B(Of T) Inherits A(Of B(Of T)).)
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.BaseType">
	<summary>
 Base type. 
 Could be Nothing for Interfaces or Object.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.CheckInterfaces(Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Do additional verification of interfaces after acyclic interfaces are found. This is
 the chance to generate diagnostics that may need to walk interfaces and as such
 can be performed only after the interfaces have been determined and cycles broken.
 (For instance, checking constraints on Class C(Of T) Implements I(Of C(Of T)).)
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.Interfaces">
	<summary>
 Interfaces that are implemented or inherited (if current type is interface itself).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetBestKnownBaseType">
	<summary>
 Returns declared base type or actual base type if already known
 This is only used by cycle detection code so that it can observe when cycles are broken 
 while not forcing actual Base to be realized.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetBestKnownInterfaces">
	<summary>
 Returns declared interfaces or actual Interfaces if already known
 This is only used by cycle detection code so that it can observe when cycles are broken 
 while not forcing actual Interfaces to be realized.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.IsGenericType">
	<summary>
 True iff this type or some containing type has type parameters.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetEmittedNamespaceName">
	<summary>
 Should return full emitted namespace name for a top level type if the name 
 might be different in case from containing namespace symbol full name, Nothing overwise.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.ImplementsAllMembersOfInterface(Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Does this type implement all the members of the given interface. Does not include members
 of interfaces that iface inherits, only direct members.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.IsUnboundGenericType">
	<summary>
 True if this is a reference to an <em>unbound</em> generic type.  These occur only
 within a <code>GetType</code> expression.  A generic type is considered <em>unbound</em>
 if all of the type argument lists in its fully qualified name are empty.
 Note that the type arguments of an unbound generic type will be returned as error
 types because they do not really have type arguments.  An unbound generic type
 yields null for its BaseType and an empty result for its Interfaces.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GenerateAllDeclarationErrors(System.Threading.CancellationToken)">
	<summary>
 Force all declaration errors to be generated.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetSynthesizedNestedTypes">
	<summary>
 Return compiler generated nested types that are created at Declare phase, but not exposed through GetMembers and the like APIs.
 Should return Nothing if there are no such types.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.IsWindowsRuntimeImport">
	<summary>
 True if the type is a Windows runtime type.
 </summary>
	<remarks>
 A type can me marked as a Windows runtime type in source by applying the WindowsRuntimeImportAttribute.
 WindowsRuntimeImportAttribute is a pseudo custom attribute defined as an internal class in System.Runtime.InteropServices.WindowsRuntime namespace.
 This is needed to mark Windows runtime types which are redefined in mscorlib.dll and System.Runtime.WindowsRuntime.dll.
 These two assemblies are special as they implement the CLR's support for WinRT.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.NamedTypeSymbol">
	<summary>
 Represents a type other than an array, a type parameter.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleSymbol.GlobalNamespace">
	<summary>
 Returns a NamespaceSymbol representing the global (root) namespace, with
 module extent, that can be used to browse all of the symbols defined in this module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleSymbol.ContainingAssembly">
	<summary>
 Returns the containing assembly. Modules are always directly contained by an assembly,
 so this property always returns the same as ContainingSymbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleSymbol.GetReferencedAssemblies">
	<summary>
 Returns an array of assembly identities for assemblies referenced by this module.
 Items at the same position from GetReferencedAssemblies and from GetReferencedAssemblySymbols 
 should correspond to each other.
 
 The array and its content is provided by AssemblyManager and must not be modified.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleSymbol.GetReferencedAssemblySymbols">
	<summary>
 Returns an array of AssemblySymbol objects corresponding to assemblies referenced 
 by this module. Items at the same position from GetReferencedAssemblies and 
 from GetReferencedAssemblySymbols should correspond to each other. If reference is 
 not resolved by compiler, GetReferencedAssemblySymbols returns MissingAssemblySymbol in the
 correspnding item.
 
 The array and its content is provided by AssemblyManager and must not be modified.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleSymbol.SetReferences(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.AssemblyIdentity},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.AssemblySymbol},Roslyn.Compilers.VisualBasic.SourceAssemblySymbol)">
	<summary>
 A helper method for AssemblyManager to set assembly identities for assemblies 
 referenced by this module and corresponding AssemblySymbols.
 </summary>
	<param name="names">Identities of referenced assemblies (those that are or will be emitted to metadada).</param>
	<param name="symbols">Assembly symbols that the identities are resolved against.</param>
	<param name="originatingSourceAssembly">
 Source assembly that triggered creation of this module symbol.
 For debug purposes only, this assembly symbol should not be persisted within
 this module symbol because the module can be shared across multiple source 
 assemblies. This method will only be called for the first one.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleSymbol.LookupTopLevelMetadataType(Roslyn.Compilers.Internal.MetadataTypeName@)">
	<summary>
 Lookup a top level type referenced from metadata, names should be
 compared case-sensitively.
 </summary>
	<param name="emittedName">
 Full type name possibly with generic name mangling.
 </param>
	<returns>
 Symbol for the type, or MissingMetadataSymbol if the type isn't found.
 </returns>
	<remarks></remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleSymbol.HasAssemblyCompilationRelaxationsAttribute">
	<summary>
 Returns true if there is any applied CompilationRelaxationsAttribute assembly attribute for this module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleSymbol.HasAssemblyRuntimeCompatibilityAttribute">
	<summary>
 Returns true if there is any applied RuntimeCompatibilityAttribute assembly attribute for this module.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ModuleSymbol.GetModuleNamespace(Roslyn.Compilers.Common.INamespaceSymbol)">
	<summary>
 Given a namespace symbol, returns the corresponding module specific namespace symbol
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleSymbol.IsMissing">
	<summary>
 Does this symbol represent a missing Module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ModuleSymbol.MightContainExtensionMethods">
	<summary>
 If this property returns false, it is certain that there are no extension
 methods (from language perspective) inside this module. If this property returns true, 
 it is highly likely (but not certain) that this type contains extension methods. 
 This property allows the search for extension methods to be narrowed much more quickly.
 
 !!! Note that this property can mutate during lifetime of the symbol !!!
 !!! from True to False, as we learn more about the module.           !!! 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ModuleSymbol">
	<summary>
 Represents a module within an assembly. Every assembly contains one or more modules.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MissingNamespaceSymbol">
	<summary>
 A <see cref="T:Roslyn.Compilers.VisualBasic.MissingNamespaceSymbol"/> is a special kind of <see cref="T:Roslyn.Compilers.VisualBasic.NamespaceSymbol"/> that represents
 a namespace that couldn't be found.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MissingModuleSymbol">
	<summary>
 A <see cref="T:Roslyn.Compilers.VisualBasic.MissingModuleSymbol"/> is a special kind of <see cref="T:Roslyn.Compilers.VisualBasic.ModuleSymbol"/> that represents
 a module that couldn't be found.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MissingMetadataTypeSymbol.TopLevel.m_LazyTypeId">
	<summary>
 SpecialType.TypeId
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MissingMetadataTypeSymbol.TopLevel.NamespaceName">
	<summary>
 This is the FULL namespace name (e.g., "System.Collections.Generic")
 of the type that couldn't be found.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MissingMetadataTypeSymbol.TopLevel">
	<summary>
 Represents not nested missing type.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MissingMetadataTypeSymbol.Nested">
	<summary>
 Represents nested missing type.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MissingMetadataTypeSymbol">
	<summary>
 A MissingMetadataSymbol is a special kind of ErrorSymbol that represents
 a type symbol that was attempted to be read from metadata, but couldn't be
 found, because:
   a) The metadata file it lives in wasn't referenced
   b) The metadata file was referenced, but didn't contain the type
   c) The metadata file was referenced, contained the correct outer type, but
      didn't contains a nested type in that outer type.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MissingAssemblySymbol">
	<summary>
 A <see cref="T:Roslyn.Compilers.VisualBasic.MissingAssemblySymbol"/> is a special kind of <see cref="T:Roslyn.Compilers.VisualBasic.AssemblySymbol"/> that represents
 an assembly that couldn't be found.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MissingCorLibrarySymbol.m_LazySpecialTypes">
	<summary>
 An array of cached Cor types defined in this assembly.
 Lazily filled by GetDeclaredSpecialType method.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MissingCorLibrarySymbol.GetDeclaredSpecialType(Roslyn.Compilers.SpecialType)">
	<summary>
 Lookup declaration for predefined CorLib type in this Assembly. Only should be
 called if it is know that this is the Cor Library (mscorlib).
 </summary>
	<param name="type"></param>
</member><member name="T:Roslyn.Compilers.VisualBasic.MissingCorLibrarySymbol">
	<summary>
 AssemblySymbol to represent missing, for whatever reason, CorLibrary.
 The symbol is created by AssemblyManager on as needed basis and is shared by all compilations
 with missing CorLibraries.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodSymbolExtensions.CanBeCalledWithNoParameters(Roslyn.Compilers.VisualBasic.MethodSymbol)">
	<summary>
 Determines if the method can be called with empty parameter list.
 </summary>
	<param name="method">The method.</param><returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodSymbolExtensions.IsPartial(Roslyn.Compilers.VisualBasic.MethodSymbol)">
	<summary> 
 Determines if the method is partial 
 </summary>
	<param name="method">The method</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodSymbolExtensions.IsPartialWithoutImplementation(Roslyn.Compilers.VisualBasic.MethodSymbol)">
	<summary> 
 Determines if the method is partial and does NOT have implementation provided 
 </summary>
	<param name="method">The method</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodSymbolExtensions.IsUserDefinedOperator(Roslyn.Compilers.VisualBasic.MethodSymbol)">
	<summary>
 Is method a user-defined operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.MethodKind">
	<summary>
 Gets what kind of method this is. There are several different kinds of things in the
 VB language that are represented as methods. This property allow distinguishing those things
 without having to decode the name of the method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.IsVararg">
	<summary>
 Returns whether this method is using VARARG calling convention.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.IsGenericMethod">
	<summary>
 Returns whether this method is generic; i.e., does it have any type parameters?
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.Arity">
	<summary>
 Returns the arity of this method, or the number of type parameters it takes.
 A non-generic method has zero arity.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.TypeParameters">
	<summary>
 Get the type parameters on this method. If the method has not generic,
 returns an empty list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.TypeArguments">
	<summary>
 Returns the type arguments that have been substituted for the type parameters. 
 If nothing has been substituted for a give type parameters,
 then the type parameter itself is consider the type argument.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.ConstructedFrom">
	<summary>
 Returns the method symbol that this method was constructed from. This method symbol
 has the same containing type (if any), but has type arguments that are the same
 as the type parameters (although its containing type might not).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.IsSub">
	<summary>
 Returns true if this method has no return type; i.e., is a Sub instead of a Function.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.ReturnType">
	<summary>
 Gets the return type of the method. If the method is a Sub, returns
 the same type symbol as is returned by Compilation.VoidType.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.ReturnTypeCustomModifiers">
	<summary>
 Returns the list of custom modifiers, if any, associated with the returned value. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodSymbol.GetReturnTypeAttributes">
	<summary>
 Returns the list of attributes, if any, associated with the return type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.ParameterCount">
	<summary>
 Optimization: in many cases, the parameter count (fast) is sufficient and we
 don't need the actual parameter symbols (slow).
 </summary>
	<remarks>
 The default implementation is always correct, but may be unnecessarily slow.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.Parameters">
	<summary>
 Gets the parameters of this method. If this method has no parameters, returns
 an empty list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.Syntax">
	<summary>
 Should return syntax node that originated the method. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodSymbol.CallsAreOmitted(Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken,Roslyn.Compilers.VisualBasic.SyntaxTree)">
	<summary>
 Returns true if calls to this method are omitted in the given syntax tree at the given syntax node location.
 Calls are omitted when the called method is a partial method with no implementation part, or when the
 called method is a conditional method whose condition is not true at the given syntax node location in the source file
 corresponding to the given syntax tree.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodSymbol.CallsAreConditionallyOmitted(Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken,Roslyn.Compilers.VisualBasic.SyntaxTree)">
	<summary>
 Calls are conditionally omitted if all the following requirements are true:
  (a) Me.IsSub == True.
  (b) Containing type is not an interface type.
  (c) Me.IsConditional == True, i.e. it has at least one applied conditional attribute.
  (d) This method is not the Property Set method.
  (e) None of conditional symbols corresponding to these conditional attributes are true at the given syntax node location.
 </summary>
	<remarks>
 Forces binding and decoding of attributes.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodSymbol.GetAppliedConditionalSymbols">
	<summary>
 Returns a sequence of preprocessor symbols specified in <see cref="T:ConditionalAttribute"/> applied on this symbol, or null if there are none.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.IsConditional">
	<summary>
 Returns a flag indicating whether this symbol has at least one applied conditional attribute.
 </summary>
	<remarks>
 Forces binding and decoding of attributes.
 NOTE: Conditional symbols on the overridden method must be inherited by the overriding method, but the native VB compiler doesn't do so. We maintain comptability.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.HasSpecialName">
	<summary>
 True if this symbol has a special name (metadata flag SpecialName is set).
 </summary>
	<remarks>
 This is set for methods with special semantics such as constructors or accessors
 as well as in special synthetic methods such as lambdas.
 Also set for methods marked with <see cref="T:System.Runtime.CompilerServices.SpecialNameAttribute"/>.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.AssociatedPropertyOrEvent">
	<summary>
 If this method has MethodKind of MethodKind.PropertyGet or MethodKind.PropertySet,
 returns the property that this method is the getter or setter for.
 If this method has MethodKind of MethodKind.EventAdd or MethodKind.EventRemove,
 returns the event that this method is the adder or remover for.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.OverriddenMethod">
	<summary>
 If this method overrides another method (because it both had the Overrides modifier
 and there correctly was a method to override), returns the overridden method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.ExplicitInterfaceImplementations">
	<summary>
 Returns interface methods explicitly implemented by this method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.IsExternalMethod">
	<summary>
 Returns true if this method is not implemented in IL of the assembly it is defined in.
 </summary>
	<remarks>
 External methods are 
 1) Declare Subs and Declare Functions, 
 2) methods marked by <see cref="T:System.Runtime.InteropServices.DllImportAttribute"/>, 
 3) methods marked by <see cref="T:System.Runtime.CompilerServices.MethodImplAttribute"/> 
    with <see cref="F:System.Runtime.CompilerServices.MethodImplOptions.InternalCall"/> or <see cref="F:System.Runtime.CompilerServices.MethodCodeType.Runtime"/> flags.
 4) Synthesized constructors of ComImport types
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodSymbol.GetDllImportData">
	<summary>
 Returns platform invocation information for this method if it is a PlatformInvoke method, otherwise returns Nothing.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.ReturnValueMarshallingInformation">
	<summary>
 Marshalling information for return value (FieldMarshal in metadata). 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.ImplementationAttributes">
	<summary>
 Misc implementation metadata flags (ImplFlags in metadata).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodSymbol.GetSecurityInformation">
	<summary>
 Declaration security information associated with this method, or null if there is none.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.HasDeclarativeSecurity">
	<summary>
 True if the method has declarative security information (HasSecurity flags).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.IsExtensionMethod">
	<summary>
 Returns true if this method is an extension method from the VB language perspective; 
 i.e., declared with an Extension attribute and meets other language requirements.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.IsOverloads">
	<summary>
 Returns true if this method hides a base method by name and signature.
 The equivalent of the "hidebysig" flag in metadata. 
 </summary>
	<remarks>
 This property should not be confused with general method overloading in Visual Basic, and is not directly related. 
 This property will only return true if this method hides a base method by name and signature (Overloads keyword).
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.IsRuntimeImplemented">
	<summary>
 True if the implementation of this method is supplied by the runtime.
 </summary>
	<remarks>
		<see cref="P:Roslyn.Compilers.VisualBasic.MethodSymbol.IsRuntimeImplemented"/> implies <see cref="P:Roslyn.Compilers.VisualBasic.MethodSymbol.IsExternalMethod"/>.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.IsEntryPointCandidate">
	<summary> 
 Determines whether this method is a candidate for a default 
 assembly entry point. Any method called "Main" is.
 </summary>
	<returns>True if the method can be used as an entry point.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodSymbol.IsAccessibleEntryPoint">
	<summary>
 Entry point is considered accessible if it is not private and none of the containing types is private (they all might be Family or Friend).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodSymbol.HasEntryPointSignature">
	<summary> 
 Checks if the method has an entry point compatible signature, i.e. 
 - the return type is either void or int 
 - has either no parameter or a single parameter of type string[] 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodSymbol.CheckCanConstructAndTypeArguments(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol})">
	<summary> Checks for validity of Construct(...) on this method with these type arguments. </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.MeParameter">
	<summary>
 Get the "this" parameter for this method.  This is only valid for source methods.
 Returns Nothing for a Shared method, the Me parameter for a non-shared method, and throws
 InvalidOperationException for a symbol that isn't a original source method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.HighestPriorityUseSiteError">
	<summary>
 Return error code that has highest priority while calculating use site error for this symbol. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.ReducedFromDefinition">
	<summary>
 If this method is a reduced extension method, gets the extension method definition that
 this method was reduced from. Otherwise, returns Nothing.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.IsReducedExtensionMethod">
	<summary>
 Is this a reduced extension method?
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.ReducedFrom">
	<summary>
 If this method is a reduced extension method, gets the extension method (possibly constructed) that
 this method was reduced from. Otherwise, returns Nothing.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.ReceiverType">
	<summary>
 If this method can be applied to an object, returns the type of object it is applied to.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.FixedTypeParameters">
	<summary>
 Fixed type parameters for a reduced extension method or empty.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodSymbol.ReduceExtensionMethod(Roslyn.Compilers.VisualBasic.TypeSymbol,System.Int32)">
	<summary>
 If this is an extension method that can be applied to a instance of the given type,
 returns the reduced method symbol thus formed. Otherwise, returns Nothing.
 
 Name lookup should use this method in order to capture proximity, which affects 
 overload resolution. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodSymbol.ReduceExtensionMethod(Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 If this is an extension method that can be applied to a instance of the given type,
 returns the reduced method symbol thus formed. Otherwise, returns Nothing.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.Proximity">
	<summary>
 Proximity level of a reduced extension method.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodSymbol.GetBoundMethodBody(Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.Binder@)">
	<summary> 
 Returns bound block representing method's body. This method is called 
 by 'method compiler' when it is ready to emit IL code for the method.
 
 The bound method body is typically a high-level tree - it may contain 
 lambas, foreach etc... which will be processed in CompileMethod(...)
 </summary>
	<param name="methodBodyBinder">Optionally returns a binder, OUT parameter!</param>
	<remarks>
 The method MAY return a binder used for binding so it can be reused later in method compiler
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.SuppressDebugInfo">
	<summary>
 If True, suppresses generation of debug info in this method even if generateDebugInfo is true
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.PartialImplementationPart">
	<summary>
 If this is a partial method declaration without a body, and the method also
 has a part that implements it with a body, returns that implementing
 definition.  Otherwise null.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MethodSymbol.PartialDefinitionPart">
	<summary>
 If this is a partial method with a body, returns the corresponding
 definition part (without a body).  Otherwise null.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SymbolComparisonResults.RequiredExtraParameterMismatch">
	<summary> 
 One of the methods has more parameters than the other 
 AND 
 at least one of the extra parameters is NOT optional
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SymbolComparisonResults.OptionalParameterMismatch">
	<summary> 
 One of the methods has more parameters than the other 
 AND at least one of the extra parameters IS optional
 OR 
 there is at least one parameter in one method with optionality (being optional or 
 required) not equal to that of the matching parameter from the other method
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SymbolComparisonResults.TotalParameterCountMismatch">
	<summary>
 Mismatch in total number of parameters, both required and optional
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodSignatureComparer.RuntimeMethodSignatureComparer">
	<summary>
 This instance is intended to reflect the definition of signature equality used by the runtime (ECMA 335 Section 8.6.1.6).
 It considers return type, name, parameters, calling convention, and custom modifiers.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodSignatureComparer.AllAspectsSignatureComparer">
	<summary>
 This instance is used to compare all aspects.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodSignatureComparer.ParametersAndReturnTypeSignatureComparer">
	<summary>
 This instance is used to compare parameter and return types, including byref.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodSignatureComparer.VisualBasicSignatureAndConstraintsAndReturnTypeComparer">
	<summary>
 This instance is used to search for methods that have the same signature, return type,
 and constraints according to the VisualBasic definition.  Custom modifiers are ignored.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodSignatureComparer.RetargetedExplicitMethodImplementationComparer">
	<summary>
 This instance is used to search for methods that have identical signatures in every regard.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodSignatureComparer.AreConstraintTypesSubset(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.TypeSymbol},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.TypeSymbol})">
	<summary>
 Returns true if the first set of constraint types
 is a subset of the second set.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MethodSignatureComparer">
	<summary>
 Implementation of IEqualityComparer for MethodSymbols, with options for various aspects
 to compare.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.LambdaMethod">
	<summary>
 A method symbol for a lambda expression.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.Constructor">
	<summary>
 An instance constructor. The return type is always void.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.Conversion">
	<summary>
 A user-defined conversion.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.DelegateInvoke">
	<summary>
 The invoke method of a delegate.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.EventAdd">
	<summary>
 The implicitly-defined add method associated with an event.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.EventRaise">
	<summary>
 The implicitly-defined raise method associated with an event.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.EventRemove">
	<summary>
 The implicitly-defined remove method associated with an event.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.Operator">
	<summary>
 A user-defined operator.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.Ordinary">
	<summary>
 A normal method.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.PropertyGet">
	<summary>
 The implicitly-defined get method associated with a property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.PropertySet">
	<summary>
 The implicitly-defined set method associated with a property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.ReducedExtension">
	<summary>
 An extension method with the first parameter and fixed type parameters removed.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.SharedConstructor">
	<summary>
 A shared constructor. The return type is always void.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MethodKind.DeclareMethod">
	<summary>
 Declare Sub or Function.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.MetadataOrSourceAssemblySymbol.m_LazySpecialTypes">
	<summary>
 An array of cached Cor types defined in this assembly.
 Lazily filled by GetSpecialType method.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.MetadataOrSourceAssemblySymbol.m_CachedSpecialTypes">
	<summary>
 How many Cor types have we cached so far.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MetadataOrSourceAssemblySymbol.GetDeclaredSpecialType(Roslyn.Compilers.SpecialType)">
	<summary>
 Lookup declaration for predefined CorLib type in this Assembly. Only should be
 called if it is know that this is the Cor Library (mscorlib).
 </summary>
	<param name="type"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MetadataOrSourceAssemblySymbol.RegisterDeclaredSpecialType(Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Register declaration of predefined CorLib type in this Assembly.
 </summary>
	<param name="corType"></param>
</member><member name="P:Roslyn.Compilers.VisualBasic.MetadataOrSourceAssemblySymbol.KeepLookingForDeclaredSpecialTypes">
	<summary>
 Continue looking for declaration of predefined CorLib type in this Assembly
 while symbols for new type declarations are constructed.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MetadataOrSourceAssemblySymbol.MakeFinalIVTDetermination(Roslyn.Compilers.VisualBasic.AssemblySymbol)">
	<summary>
 Determine whether this assembly has been granted access to <paramref name="potentialGiverOfAccess"></paramref>.
 Assumes that the public key has been determined. The result will be cached.
 </summary>
	<param name="potentialGiverOfAccess"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.MetadataOrSourceAssemblySymbol">
	<summary>
 Represents source or metadata assembly.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PETypeParameterSymbol">
	<summary>
 The class to represent all generic type parameters imported from a PE/module.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.PEPropertySymbol.SetIsWithEvents(System.Boolean)">
	<summary>
 Marks property as definitely IsWithEvents or not.
 The effects of this change cannot be undone.
 Will have no effect if someone already asked if property is IsWithEvents (and will assert since it is not supposed to happen).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.PEPropertySymbol.DoSignaturesMatch(Roslyn.Compilers.VisualBasic.Metadata.PE.MetadataDecoder,Roslyn.Compilers.MetadataReader.MetadataDecoder{Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.AssemblySymbol,Roslyn.Compilers.VisualBasic.Symbol}.ParamInfo[],Roslyn.Compilers.VisualBasic.Metadata.PE.PEMethodSymbol,Roslyn.Compilers.MetadataReader.MetadataDecoder{Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.AssemblySymbol,Roslyn.Compilers.VisualBasic.Symbol}.ParamInfo[],Roslyn.Compilers.VisualBasic.Metadata.PE.PEMethodSymbol,Roslyn.Compilers.MetadataReader.MetadataDecoder{Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.AssemblySymbol,Roslyn.Compilers.VisualBasic.Symbol}.ParamInfo[])">
	<summary>
 For the property to be considered valid, accessor signatures must be consistent
 with each other, and accessor signatures must be consistent with the property
 signature ignoring ByRef. These requirements are stricter than Dev11 which
 allows many inconsistencies including different numbers of parameters.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PEPropertySymbol">
	<summary>
 The class to represent all properties imported from a PE/module.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.PEPropertyOrEventHelpers">
	<summary>
 Helper methods that exist to share code between properties and events.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PEParameterSymbol">
	<summary>
 The class to represent all types imported from a PE/module.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PENestedNamespaceSymbol.m_ContainingNamespaceSymbol">
	<summary>
 The parent namespace. There is always one, Global namespace contains all
 top level namespaces. 
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PENestedNamespaceSymbol.m_Name">
	<summary>
 The name of the namespace.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PENestedNamespaceSymbol.m_TypesByNS">
	<summary>
 The sequence of groups of TypeDef row ids for types contained within the namespace, 
 recursively including those from nested namespaces. The row ids are grouped by the 
 fully-qualified namespace name in case-sensitive manner. There could be multiple groups 
 for each fully-qualified namespace name. The groups are sorted by their key  
 in case-insensitive manner. Empty string is used as namespace name for types 
 immediately contained within Global namespace. Therefore, all types in this namespace, if any, 
 will be in several first IGroupings.
 
 This member is initialized by constructor and is cleared in EnsureAllMembersLoaded 
 as soon as symbols for children are created.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.PENestedNamespaceSymbol.#ctor(System.String,Roslyn.Compilers.VisualBasic.Metadata.PE.PENamespaceSymbol,System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.UInt32}})">
	<summary>
 Constructor.
 </summary>
	<param name="name">
 Name of the namespace, must be not empty.
 </param>
	<param name="containingNamespace">
 Containing namespace.
 </param>
	<param name="typesByNS">
 The sequence of groups of TypeDef row ids for types contained within the namespace, 
 recursively including those from nested namespaces. The row ids are grouped by the 
 fully-qualified namespace name in case-sensitive manner. There could be multiple groups 
 for each fully-qualified namespace name. The groups are sorted by their key  
 in case-insensitive manner. Empty string is used as namespace name for types 
 immediately contained within Global namespace. Therefore, all types in this namespace, if any, 
 will be in several first IGroupings.
 </param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.PENestedNamespaceSymbol.GetDeclaredAccessibilityOfMostAccessibleDescendantType">
	<summary>
 Calculate declared accessibility of most accessible type within this namespace or within a containing namespace recursively.
 Expected to be called at most once per namespace symbol, unless there is a race condition.
 
 Valid return values:
     Friend,
     Public,
     NotApplicable - if there are no types.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PENestedNamespaceSymbol">
	<summary>
 The class to represent all, but Global, namespaces imported from a PE/module.
 Namespaces that differ only by casing in name are merged.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamespaceSymbol.m_lazyMembers">
	<summary>
 A map of namespaces immediately contained within this namespace 
 grouped by their name (case-insensitively).
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamespaceSymbol.m_lazyTypes">
	<summary>
 A map of types immediately contained within this namespace 
 grouped by their name (case-insensitively).
 </summary>
	<remarks></remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamespaceSymbol.ContainingPEModule">
	<summary>
 Returns PEModuleSymbol containing the namespace.
 </summary>
	<returns>PEModuleSymbol containing the namespace.</returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamespaceSymbol.LoadAllMembers(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.UInt32}})">
	<summary>
 Initializes m_Namespaces and m_Types maps with information about 
 namespaces and types immediately contained within this namespace.
 </summary>
	<param name="typesByNS">
 The sequence of groups of TypeDef row ids for types contained within the namespace, 
 recursively including those from nested namespaces. The row ids must be grouped by the 
 fully-qualified namespace name in case-sensitive manner. There could be multiple groups 
 for each fully-qualified namespace name. The groups must be sorted by their key in 
 case-insensensitive manner. Empty string must be used as namespace name for types 
 immediately contained within Global namespace. Therefore, all types in THIS namespace, 
 if any, must be in several first IGroupings.
 </param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamespaceSymbol.LazyInitializeNamespaces(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.UInt32}}}})">
	<summary>
 Create symbols for nested namespaces and initialize m_Namespaces map.
 </summary>
	<param name="childNamespaces"></param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamespaceSymbol.LazyInitializeTypes(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.UInt32}})">
	<summary>
 Create symbols for nested types and initialize m_Types map.
 </summary>
	<param name="types"></param>
	<remarks></remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamespaceSymbol.AreTypesLoaded">
	<summary>
 For test purposes only.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamespaceSymbol.TypesToCheckForExtensionMethods">
	<summary>
 Return the set of types that should be checked for presence of extension methods in order to build
 a map of extension methods for the namespace. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamespaceSymbol">
	<summary>
 The base class to represent a namespace imported from a PE/module.
 Namespaces that differ only by casing in name are merged.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamedTypeSymbolWithEmittedNamespaceName">
	<summary>
 The class to represent top level types imported from a PE/module.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamedTypeSymbol.m_lazyNestedTypes">
	<summary>
 A map of types immediately contained within this type 
 grouped by their name (case-insensitively).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamedTypeSymbol.m_lazyMemberNames">
	<summary>
 A set of all the names of the members in this type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamedTypeSymbol.m_lazyMembers">
	<summary>
 A map of members immediately contained within this type 
 grouped by their name (case-insensitively).
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamedTypeSymbol.m_lazyTypeKind">
	<summary>
 Lazily initialized by TypeKind property.
 Using Integer type to make sure read/write operations are atomic.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamedTypeSymbol.IsValidWithEventsProperty(Roslyn.Compilers.VisualBasic.Metadata.PE.PEPropertySymbol)">
	<summary>
 Some simple sanity checks if a property can actually be a withevents property
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamedTypeSymbol.GenerateAllDeclarationErrors(System.Threading.CancellationToken)">
	<summary>
 Force all declaration errors to be generated.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PENamedTypeSymbol">
	<summary>
 The class to represent all types imported from a PE/module.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEModuleSymbol.m_AssemblySymbol">
	<summary>
 Owning AssemblySymbol. This can be a PEAssemblySymbol or a SourceAssemblySymbol.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEModuleSymbol.m_Module">
	<summary>
 A Module object providing metadata.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEModuleSymbol.m_GlobalNamespace">
	<summary>
 Global namespace. 
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEModuleSymbol.m_LazySystemTypeSymbol">
	<summary>
 Cache the symbol for well-known type System.Type because we use it frequently
 (for attributes).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEModuleSymbol.TypeDefRowIdToTypeMap">
	<summary>
 This is a map from TypeDef row id to the target TypeSymbol. 
 It is used by MetadataDecoder to speed-up type reference resolution
 for metadata coming from this module. The map is lazily populated
 as we load types from the module.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEModuleSymbol.TypeRefRowIdToTypeMap">
	<summary>
 This is a map from TypeRef row id to the target TypeSymbol. 
 It is used by MetadataDecoder to speed-up type reference resolution
 for metadata coming from this module. The map is lazily populated
 by MetadataDecoder as we resolve TypeRefs from the module.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PEModuleSymbol">
	<summary>
 Represents a net-module imported from a PE. Can be a primary module of an assembly. 
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.PEMethodSymbol.SetAssociatedProperty(Roslyn.Compilers.VisualBasic.Metadata.PE.PEPropertySymbol,Roslyn.Compilers.VisualBasic.MethodKind)">
	<summary>
 Associate the method with a particular property. Returns
 false if the method is already associated with a property or event.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.PEMethodSymbol.SetAssociatedEvent(Roslyn.Compilers.VisualBasic.Metadata.PE.PEEventSymbol,Roslyn.Compilers.VisualBasic.MethodKind)">
	<summary>
 Associate the method with a particular event. Returns
 false if the method is already associated with a property or event.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PEMethodSymbol">
	<summary>
 The class to represent all methods imported from a PE/module.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEGlobalNamespaceSymbol.m_ModuleSymbol">
	<summary>
 The module containing the namespace.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PEFieldSymbol">
	<summary>
 The class to represent all fields imported from a PE/module.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PEEventSymbol">
	<summary>
 The class to represent all events imported from a PE/module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAttributeData.AttributeClass">
	<summary>
 The attribute class.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAttributeData.AttributeConstructor">
	<summary>
 The constructor on the attribute class.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAttributeData.CommonConstructorArguments">
	<summary>
 Constructor arguments on the attribute.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAttributeData.CommonNamedArguments">
	<summary>
 Named (property value) arguments on the attribute. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAttributeData.IsTargetAttribute(System.String,System.String,System.Boolean)">
	<summary>
 Matches an attribute by metadata namespace, metadata type name. Does not load the type symbol for
 the attribute.
 </summary>
	<param name="namespaceName"></param>
	<param name="typeName"></param>
	<returns>True if the attribute data matches.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAttributeData.IsTargetAttribute(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.AttributeDescription)">
	<summary>
 Matches an attribute by metadata namespace, metadata type name and metadata signature. Does not load the
 type symbol for the attribute.
 </summary>
	<param name="description">Attribute to match.</param>
	<returns>True if the attribute matches</returns>
	<remarks>Matching an attribute by name does not load the attribute class.</remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAttributeData">
	<summary>
 Class to represent custom attributes attached to symbols.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAssemblySymbol.m_Assembly">
	<summary>
 An Assembly object providing metadata for the assembly.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAssemblySymbol.m_DocumentationProvider">
	<summary>
 A MetadataDocumentationProvider providing XML documentation for this assembly.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAssemblySymbol.m_Modules">
	<summary>
 The list of contained PEModuleSymbol objects.
 The list doesn't use type ReadOnlyCollection(Of PEModuleSymbol) so that we
 can return it from Modules property as is.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAssemblySymbol.m_NoPiaResolutionAssemblies">
	<summary>
 An array of assemblies involved in canonical type resolution of
 NoPia local types defined within this assembly. In other words, all 
 references used by a compilation referencing this assembly.
 The array and its content is provided by AssemblyManager and must not be modified.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAssemblySymbol.m_LinkedReferencedAssemblies">
	<summary>
 An array of assemblies referenced by this assembly, which are linked (/l-ed) by 
 each compilation that is using this AssemblySymbol as a reference. 
 If this AssemblySymbol is linked too, it will be in this array too.
 The array and its content is provided by AssemblyManager and must not be modified.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAssemblySymbol.m_IsLinked">
	<summary>
 Assembly is /l-ed by compilation that is using it as a reference.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.PEAssemblySymbol">
	<summary>
 Represents an assembly imported from a PE.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.MethodRefMetadataDecoder.GetGenericMethodTypeParamSymbol(System.Int32)">
	<summary>
 We know that we'll never have a method context because that's what we're
 trying to find.  Instead, just return an indexed type parameter that will
 make comparison easier.
 </summary>
	<param name="position"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.MethodRefMetadataDecoder.GetGenericTypeParamSymbol(System.Int32)">
	<summary>
 This override changes two things:
     1) Return type arguments instead of type parameters.
     2) Handle non-PE types.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.MethodRefMetadataDecoder.FindMethodBySignature(Roslyn.Compilers.VisualBasic.TypeSymbol,System.UInt32)">
	<summary>
 Search through the members of a given type symbol to find the method that matches a particular
 signature.
 </summary>
	<param name="targetTypeSymbol">Type containing the desired method symbol.</param>
	<param name="targetMemberRefToken">A MemberRef token that can be used to obtain the name and signature of the method</param>
	<returns>The matching method symbol, or null if the inputs do not correspond to a valid method.</returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.MethodRefMetadataDecoder">
	<summary>
 This subclass of MetadataDecoder is specifically for finding
 method symbols corresponding to method MemberRefs.  The parent 
 implementation is unsuitable because it requires a PEMethodSymbol
 for context when decoding method type parameters and no such
 context is available because it is precisely what we are trying
 to find.  Since we know in advance that there will be no context
 and that signatures decoded with this class will only be used
 for comparison (when searching through the methods of a known
 TypeSymbol), we can return indexed type parameters instead.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.MetadataDecoder.m_ModuleSymbol">
	<summary>
 ModuleSymbol for the module - source of metadata.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.MetadataDecoder.m_typeContextOpt">
	<summary>
 Type context for resolving generic type arguments.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Metadata.PE.MetadataDecoder.m_methodContextOpt">
	<summary>
 Method context for resolving generic method type arguments.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.MetadataDecoder.LookupTopLevelTypeDefSymbol(System.Int32,Roslyn.Compilers.Internal.MetadataTypeName@)">
	<summary>
 Lookup a type defined in referenced assembly.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.MetadataDecoder.LookupTopLevelTypeDefSymbol(Roslyn.Compilers.Internal.MetadataTypeName@)">
	<summary>
 Lookup a type defined in this module.
 This method will be called only if the type we are
 looking for hasn't been loaded yet. Otherwise, MetadataDecoder
 would have found the type in TypeDefRowIdToTypeMap based on its 
 TypeDef row id. 
 </summary>
	<param name="emittedName"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.MetadataDecoder.SubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol[],System.Boolean[])">
	<summary>
 Produce constructed type symbol.
 </summary>
	<param name="genericTypeDef">
 Symbol for generic type.
 </param>
	<param name="arguments">
 Generic type arguments, including those for nesting types.
 </param>
	<param name="refersToNoPiaLocalType">
 Flags for arguments. Each item indicates whether corresponding argument refers to NoPia local types.
 </param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.MetadataDecoder.IsOrClosedOverATypeFromAssemblies(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.AssemblySymbol})">
	<summary>
 Perform a check whether the type or at least one of its generic arguments 
 is defined in the specified assemblies. The check is performed recursively. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Metadata.PE.MetadataDecoder.SubstituteNoPiaLocalType(Roslyn.Compilers.Internal.MetadataTypeName@,System.Boolean,Roslyn.Compilers.VisualBasic.TypeSymbol,System.String,System.String,System.String,Roslyn.Compilers.VisualBasic.AssemblySymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.AssemblySymbol})">
	<summary>
 Find canonical type for NoPia embedded type.
 </summary>
	<param name="fullEmittedName"></param>
	<param name="isInterface"></param>
	<param name="baseType"></param>
	<param name="interfaceGuid"></param>
	<param name="scope"></param>
	<param name="identifier"></param>
	<param name="referringAssembly"></param>
	<param name="lookupIn"></param>
	<returns>
 Symbol for the canonical type or an ErrorTypeSymbol. Never returns null.
 </returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.Metadata.PE.MetadataDecoder">
	<summary>
 Helper class to resolve metadata tokens and signatures.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MergedNamespaceSymbol.Create(Roslyn.Compilers.VisualBasic.AssemblySymbol,Roslyn.Compilers.VisualBasic.NamespaceSymbol,System.Collections.Generic.IEnumerable{Roslyn.Compilers.VisualBasic.NamespaceSymbol})">
	<summary>
 Create a possibly merged namespace symbol. If only a single namespace is passed it, it is just returned directly.
 If two or more namespaces are passed in, then a new merged namespace is created with the given extent and container.
 </summary>
	<param name="extent">The namespace extent to use, IF a merged namespace is created.</param>
	<param name="containingNamespace">The containing namespace to used, IF a merged namespace is created.</param>
	<param name="namespacesToMerge">One or more namespaces to merged. If just one, then it is returned.
 The merged namespace symbol may hold onto the array.</param>
	<returns></returns>A namespace symbol representing the merged namespace.(of /returns)

</member><member name="M:Roslyn.Compilers.VisualBasic.MergedNamespaceSymbol.SlowGetChildrenOfName(System.String)">
	<summary>
 Method that is called from the CachingLookup to lookup the children of a given name. Looks
 in all the constituent namespaces.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MergedNamespaceSymbol.SlowGetChildNames">
	<summary>
 Method that is called from the CachingLookup to get all child names. Looks
 in all constituent namespaces.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MergedNamespaceSymbol.GetDeclaredAccessibilityOfMostAccessibleDescendantType">
	<summary>
 Calculate declared accessibility of most accessible type within this namespace or within a containing namespace recursively.
 Expected to be called at most once per namespace symbol, unless there is a race condition.
 
 Valid return values:
     Friend,
     Public,
     NotApplicable - if there are no types.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MergedNamespaceSymbol.RawContainsAccessibleTypes">
	<summary>
 For test purposes only.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MergedNamespaceSymbol.CompilationMergedNamespaceSymbol.ContainsTypesAccessibleFrom(Roslyn.Compilers.VisualBasic.AssemblySymbol)">
	<summary>
 Returns true if namespace contains types accessible from the target assembly.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MergedNamespaceSymbol.CompilationMergedNamespaceSymbol.BuildExtensionMethodsMap(System.Collections.Generic.Dictionary{System.String,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.MethodSymbol}})">
	<summary>
 Populate the map with all extension methods declared within this namespace, so that methods from
 the same type are grouped together within each bucket. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MergedNamespaceSymbol">
	<summary>
 A MergedNamespaceSymbol represents a namespace that merges the contents of two or more other
 namespaces. Any sub-namespaces with the same names are also merged if they have two or more
 instances.
 
 Merged namespaces are used to merged the symbols from multiple metadata modules and the source "module"
 into a single symbol tree that represents all the available symbols. The compiler resolves names
 against Me merged set of symbols.
 
 Typically there will not be very many merged namespaces in a Compilation: only the root namespaces and
 namespaces that are used in multiple referenced modules. (Microsoft, System, System.Xml,
 System.Diagnostics, System.Threading, ...)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InstanceTypeSymbol.InternalSubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InstanceTypeSymbol">
	<summary>
 An InstanceTypeSymbol is a NamedTypeSymbol that is a pure instance type, where the class
 (and any containing classes) have no type substitutions applied.
 This class provide shared implementation for types whose definition is (possibly lazily)
 constructed from source or metadata. It provides the shared implementation between these two, primarily
 the implementation of Construct and InternalSubstituteTypeParameters.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InstanceErrorTypeSymbol.InternalSubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InstanceErrorTypeSymbol">
	<summary>
 The base class for potentially constructable (i.e. with known arity) error type symbols
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.IndexedTypeParameterSymbol.Take(System.Int32)">
	<summary>
 Create a vector of n dummy type parameters.  Always reuses the same type parameter symbol
 for the same position.
 </summary>
	<param name="count"></param>
	<returns></returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.IndexedTypeParameterSymbol">
	<summary>
 Indexed type parameters are used in place of type parameters for method signatures.  There is
 a unique mapping from index to a single IndexedTypeParameterSymbol.  
 
 They don't have a containing symbol or locations.
 
 They do not have constraints, variance, or attributes. 
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.IdentifierComparison.Comparer">
	<summary>
 Returns a StringComparer that compares strings according the VB identifier comparison rules.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.IdentifierComparison.Equals(System.String,System.String)">
	<summary>
 Determines if two VB identifiers are equal according to the VB identifier comparison rules.
 </summary>
	<param name="ident1">First identifier to compare</param>
	<param name="ident2">Second identifier to compare</param>
	<returns>True if the identifiers should be considered the same.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.IdentifierComparison.Compare(System.String,System.String)">
	<summary>
 Compares two VB identifiers according to the VB identifier comparison rules.
 </summary>
	<param name="ident1">First identifier to compare</param>
	<param name="ident2">Second identifier to compare</param>
	<returns>-1 if ident1 &lt; ident2, 1 if ident1 &gt; ident2, 0 if they are equal.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.IdentifierComparison.GetHashCode(System.String)">
	<summary>
 Gets a case-insensitive hash code for VB identifiers.
 </summary>
	<param name="ident">identifier to get the hash code for</param>
	<returns>The hash code for the given identifier</returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.IdentifierComparison">
	<summary>
 A class that encapsulates the VB case-insensitive identifier comparison rules.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.HandledEvent.HandlesKind">
	<summary>
 Kind of Handles event container. (Me, MyBase, MyClass or a WithEvents variable)
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.HandledEvent.EventSymbol">
	<summary>
 Symbol for the event handled in current Handles item.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.HandledEvent">
	<summary>
 represents a single item in Handles list.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.HandledEventKind.Me">
	<summary>
 Handles Me.Event1
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.HandledEventKind.MyClass">
	<summary>
 Handles MyClass.Event1
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.HandledEventKind.MyBase">
	<summary>
 Handles MyBase.Event1
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.HandledEventKind.WithEvents">
	<summary>
 Handles SomeWithEventsVariable.Event1
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.HandledEventKind">
	<summary>
 Kind of a Handles item represented by a HandledEvent
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.Type">
	<summary>
 Gets the type of this variable.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.HasDeclaredType">
	<summary>
 Gets a value indicating whether this instance has declared type. This means a field was declared with an AsClause
 or in case of const fields with an AsClause whose type is not System.Object
 </summary>
	<value>
		<c>true</c> if this instance has declared type; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.CustomModifiers">
	<summary>
 The list of custom modifiers, if any, associated with the member variable.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.AssociatedPropertyOrEvent">
	<summary>
 If this variable serves as a backing variable for an automatically generated
 property or event, returns that property or event. 
 Otherwise returns Nothing.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.IsReadOnly">
	<summary>
 Returns true if this variable was declared as ReadOnly 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.IsConst">
	<summary>
 Returns true if this field was declared as "const" (i.e. is a constant declaration), or
 is an Enum member.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.IsMetadataConstant">
	<summary>
 Gets a value indicating whether this instance is metadata constant. A field is considered to be 
 metadata constant if the field value is a valid default value for a field.
 </summary>
	<value>
		<c>true</c> if this instance is metadata constant; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.IsConstButNotMetadataConstant">
	<summary>
 Gets a value indicating whether this instance is const, but not metadata constant. A field is considered to be 
 const but not metadata constant if the const field's type is either Date or Decimal.
 </summary>
	<value>
		<c>true</c> if this instance is metadata constant; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.HasConstantValue">
	<summary>
 Returns false if the field wasn't declared as "const", or constant value was omitted or erroneous.
 True otherwise.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.ConstantValue">
	<summary>
 If IsConst returns true, then returns the value of the constant or Enum member.
 If IsConst return false, then returns Nothing.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.FieldSymbol.GetConstantValue(Roslyn.Compilers.VisualBasic.SymbolsInProgress{Roslyn.Compilers.VisualBasic.FieldSymbol})">
	<summary>
 Gets the constant value.
 </summary>
	<param name="inProgress">The previously visited const fields; used to detect cycles.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.FieldSymbol.GetInferredType(Roslyn.Compilers.VisualBasic.SymbolsInProgress{Roslyn.Compilers.VisualBasic.FieldSymbol})">
	<summary>
 Const fields do not (always) have to be declared with a given type. To get the inferred type determined from
 the initialization this method should be called instead of "Type". For non const field this method returns the
 declared type.
 </summary>
	<param name="inProgress">The previously visited const fields; used to detect cycles.</param><returns></returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.HasSpecialName">
	<summary>
  True if this symbol has a special name (metadata flag SpecialName is set).
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.HasRuntimeSpecialName">
	<summary>
 True if RuntimeSpecialName metadata flag is set for this symbol.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.IsNotSerialized">
	<summary>
 True if NotSerialized metadata flag is set for this symbol.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.MarshallingInformation">
	<summary>
 Describes how the field is marshalled when passed to native code.
 Null if no specific marshalling information is available for the field.
 </summary>
	<remarks>PE symbols don't provide this information and always return Nothing.</remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.MarshallingType">
	<summary>
 Returns the marshalling type of this field, or 0 if marshalling information isn't available.
 </summary>
	<remarks>
 By default this information is extracted from <see cref="P:MarshallingInformation"/> if available. 
 Since the compiler does only need to know the marshalling type of symbols that aren't emitted 
 PE symbols just decode the type from metadata and don't provide full marshalling information.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.MeParameter">
	<summary>
 Get the "this" parameter for this field.  This is only valid for source fields.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.FieldSymbol.HighestPriorityUseSiteError">
	<summary>
 Return error code that has highest priority while calculating use site error for this symbol. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.FieldSymbol">
	<summary>
 Represents a member variable -- a variable declared as a member of a Class or Structure. 
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer.FieldsOrProperty">
	<summary>
 The field or property being initialized, or Nothing if this represents an executable statement in script code.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer.Syntax">
	<summary>
 A reference to <see cref="T:Roslyn.Compilers.VisualBasic.EqualsValueSyntax"/>.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer.#ctor(Roslyn.Compilers.VisualBasic.SyntaxReference)">
	<summary>
 Initializer for an executable statement in script code.
 </summary>
	<param name="syntax">The initializer syntax for the statement.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer.#ctor(Roslyn.Compilers.VisualBasic.FieldSymbol,Roslyn.Compilers.VisualBasic.SyntaxReference)">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer"/> structure.
 </summary>
	<param name="field">The field.</param>
	<param name="syntax">The initializer syntax for the field.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer.#ctor(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.Symbol},Roslyn.Compilers.VisualBasic.SyntaxReference)">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer"/> structure.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer.#ctor(Roslyn.Compilers.VisualBasic.PropertySymbol,Roslyn.Compilers.VisualBasic.SyntaxReference)">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer"/> structure.
 </summary>
	<param name="property">The property.</param>
	<param name="syntax">The initializer syntax for the property.</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer">
	<summary>
 Represents a field or property initializer. Holds the symbol and the syntax for the initialization.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ExtendedErrorTypeSymbol.ErrorInfo">
	<summary>
 Returns information about the reason that this type is in error.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ExtendedErrorTypeSymbol">
	<summary>
 An error type symbol with name and diagnostic. More info can be added in the future.
 </summary>
	<remarks></remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventSymbol.HasSpecialName">
	<summary>
  True if this symbol has a special name (metadata flag SpecialName is set).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EventSymbol.GetFieldAttributes">
	<summary>
 Gets the attributes on event's associated field, if any.
 Returns an empty <see cref="T:Roslyn.Compilers.ReadOnlyArray`1"/>  if
 there are no attributes.
 </summary>
	<remarks>
 This publicly exposes the attributes of the internal backing field.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventSymbol.DelegateParameters">
	<summary>
 Gets the parameters of this event. If this event has no parameters, returns
 an empty list.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventSymbol.DelegateReturnType">
	<summary>
 Gets the return type of the event (typically System.Void). 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.EventSymbol.DelegateReturnTypeCustomModifiers">
	<summary>
 Returns the list of custom modifiers, if any, associated with the return type of the event. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EventSymbol.DelegateInvokeMethod">
	<summary>
 Can be null in error cases.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EventSymbol.Accept``2(Roslyn.Compilers.VisualBasic.SymbolVisitor{``0,``1},``0)">
	<summary>
 Implements visitor pattern.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.EventSymbol">
	<summary>
 Represents an event.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.EventSignatureComparer.ExplicitEventImplementationComparer">
	<summary>
 This instance is used when trying to determine which implemented interface event is implemented
 by a event with an Implements clause, according to VB rules.
 This comparer uses event signature that may come from As clause delegate or from a parameter list.
 The event signatures are compared without regard to name (including the interface part, if any)
 and the return type must match. (NOTE: that return tupe of implementing event is always Void)
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.EventSignatureComparer.OverrideSignatureComparer">
	<summary>
 This instance is used to check whether one event overrides another, according to the VB definition.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.EventSignatureComparer.RuntimeEventSignatureComparer">
	<summary>
 This instance is intended to reflect the definition of signature equality used by the runtime (ECMA 335 Section 8.6.1.6).
 It considers type, name, parameters, and custom modifiers.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.EventSignatureComparer">
	<summary>
 Implementation of IEqualityComparer for EventSymbol, with options for various aspects
 to compare.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ErrorTypeSymbol.ErrorInfo">
	<summary>
 Returns information about the reason that this type is in error.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ErrorTypeSymbol.InternalSubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ErrorTypeSymbol.NonErrorGuessType">
	<summary> 
 If we believe we know which symbol the user intended, then we should retain that information
 in the corresponding error symbol - it can be useful for deciding how to handle the error.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ErrorTypeSymbol.ResultKind">
	<summary>
 Return why the candidate symbols were bad.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ErrorTypeSymbol.CandidateSymbols">
	<summary>
 When constructing this ErrorTypeSymbol, there may have been symbols that seemed to
 be what the user intended, but were unsuitable. For example, a type might have been
 inaccessible, or ambiguous. This property returns the possible symbols that the user
 might have intended. It will return no symbols if no possible symbols were found.
 See the CandidateReason property to understand why the symbols were unsuitable.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ErrorTypeSymbol.GenerateAllDeclarationErrors(System.Threading.CancellationToken)">
	<summary>
 Force all declaration errors to be generated.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CustomModifier.IsOptional">
	<summary>
 If true, a language may use the modified storage location without 
 being aware of the meaning of the modification, modopt vs. modreq. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CustomModifier.Modifier">
	<summary>
 A type used as a tag that indicates which type of modification applies.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.CustomModifier">
	<summary>
 Represents a custom modifier (modopt/modreq).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeParameterDiagnosticInfo">
	<summary>
 A tuple of TypeParameterSymbol and DiagnosticInfo, created for errors
 reported from ConstraintsHelper rather than creating Diagnostics directly.
 This decouples constraints checking from syntax and Locations, and supports
 callers that may want to create Location instances lazily or not at all.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ConstraintsHelper.DirectTypeConstraintKind">
	<summary>
 Enum used internally by RemoveDirectConstraintConflicts to
 track what type constraint has been seen, to report conflicts
 between { 'Structure', 'Class', [explicit type] }. The 'New'
 constraint does not need to be tracked for those conflicts.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ConstraintsHelper.RemoveDirectConstraintConflicts(Roslyn.Compilers.VisualBasic.TypeParameterSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeParameterConstraint},Roslyn.Utilities.ConsList{Roslyn.Compilers.VisualBasic.TypeParameterSymbol},Roslyn.Compilers.VisualBasic.DirectConstraintConflictKind,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.TypeParameterDiagnosticInfo})">
	<summary>
 Return the constraints for the type parameter with any cycles
 or conflicting constraints reported as errors and removed.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ConstraintsHelper.CheckAllConstraints(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.TypeParameterDiagnosticInfo})">
	<summary>
 Check all generic constraints on the given type and any containing types
 (such as A(Of T) in A(Of T).B(Of U)). This includes checking constraints
 on generic types within the type (such as B(Of T) in A(Of B(Of T)())).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ConstraintsHelper.CheckConstraints(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.TypeSubstitution,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeParameterSymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.TypeParameterDiagnosticInfo})">
	<summary>
 Check type parameters for the containing type or method symbol.
 The type parameters are assumed to be the original definitions of type
 parameters from the containing type or method, and the TypeSubstitution
 instance is used for substituting type parameters within the constraints
 of those type parameters, so the substitution should map from type
 parameters to type arguments.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ConstraintsHelper.GetNonInterfaceConstraint(Roslyn.Compilers.VisualBasic.TypeParameterSymbol)">
	<summary>
 Return the most derived type from the set of constraint types on this type
 parameter and any type parameter it depends on. Returns Nothing if there
 are no concrete constraint types. If there are multiple constraints, returns
 the most derived, ignoring any subsequent constraints that are neither
 more or less derived. This method assumes there are no constraint cycles.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ConstraintsHelper.GetClassConstraint(Roslyn.Compilers.VisualBasic.TypeParameterSymbol)">
	<summary>
 Return the most derived class type from the set of constraint types on this type
 parameter and any type parameter it depends on. Returns Nothing if there are
 no concrete constraint types. If there are multiple constraints, returns the most
 derived, ignoring any subsequent constraints that are neither more or less derived.
 This method assumes there are no constraint cycles. Unlike GetBaseConstraintType,
 this method will always return a NamedTypeSymbol representing a class: returning
 System.ValueType for value types, System.Array for arrays, and System.Enum for enums.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ConstraintsHelper.GetAllConstraints(Roslyn.Compilers.VisualBasic.TypeParameterSymbol,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.ConstraintsHelper.TypeParameterAndConstraint},System.Nullable{Roslyn.Compilers.VisualBasic.TypeParameterConstraint})">
	<summary>
 Populate the collection with all constraints for the type parameter, traversing
 any constraints that are also type parameters. The result is a collection of type
 and flag constraints, with no type parameter references. This method assumes
 there are no constraint cycles.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ConstraintsHelper.TypeParameterAndConstraint">
	<summary>
 A tuple of type parameter and constraint type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ConstraintsHelper.HasPublicParameterlessConstructor(Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Return true if the class type has a public parameterless constructor.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ConstraintsHelper.ContainsTypeConstraint(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.TypeParameterConstraint},Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Return true if the constraints collection contains the given type constraint.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ConstraintsHelper">
	<summary>
 Helper methods for generic type parameter constraints. There are two sets of methods: one
 set for resolving constraint "bounds" (that is, determining the effective base type, interface set,
 etc.), and another set for checking for constraint violations in type and method references.
 
 Bounds are resolved by calling one of the ResolveBounds overloads. Typically bounds are
 resolved by each TypeParameterSymbol at, or before, one of the corresponding properties
 (BaseType, Interfaces, etc.) is accessed. Resolving bounds may result in errors (cycles,
 inconsistent constraints, etc.) and it is the responsibility of the caller to report any such
 errors as declaration errors or use-site errors (depending on whether the type parameter
 was from source or metadata) and to ensure bounds are resolved for source type parameters
 even if the corresponding properties are never accessed directly.
 
 Constraints are checked by calling one of the CheckConstraints or CheckAllConstraints
 overloads for any generic type or method reference from source. In some circumstances,
 references are checked at the time the generic type or generic method is bound and constructed
 by the Binder. In those case, it is sufficient to call one of the CheckConstraints overloads
 since compound types (such as A(Of T).B(Of U) or A(Of B(Of T))) are checked incrementally
 as each part is bound. In other cases however, constraint checking needs to be delayed to
 prevent cycles where checking constraints requires binding the syntax that is currently
 being bound (such as the constraint in Class C(Of T As C(Of T)). In those cases, the caller
 must lazily check constraints, and since the types may be compound types, it is necessary
 to call CheckAllConstraints.
 </summary>
</member><member name="T:BaseTypeAnalysis.DependencyDesc">
	<summary>
 a link in a dependency chain
 it means that "dependent" is dependent on the rest of the chain.
 "kind" tells what kind of dependency this is.
 </summary>
</member><member name="T:BaseTypeAnalysis.DependencyKind">
	<summary>
 Source types may have dependencies via inheritance or containment
 The diagnostics is different in those cases.
 </summary>
</member><member name="M:BaseTypeAnalysis.GetDependenceDiagnosticForBase(Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Detects situations when a type participates in a dependency loop
 And generates appropriate diagnostics.
 No diagnostics means there was no loop
 </summary>
</member><member name="M:BaseTypeAnalysis.GetDependenceChain(System.Collections.Generic.HashSet{Roslyn.Compilers.VisualBasic.Symbol},Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 if there is a dependency chain from "current" to the "root"
 Returning Nothing, means that there is no dependency
 Returning Empty, means that root and current are the same and we have a 0-length dependency
 Otherwise a dependence chain is formed.
 </summary>
</member><member name="M:BaseTypeAnalysis.GetDependencyDiagnosticsForImportedClass(Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Verifies that given symbol does not have loops in its inheritance chain
 and reports appropriate diagnostics.
 </summary>
</member><member name="M:BaseTypeAnalysis.GetDependencyDiagnosticsForImportedBaseInterface(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Verifies that given symbol does not have loops in its inheritance hierarchy
 and reports appropriate diagnostics.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeEarlyWellKnownAttributeData">
	<summary>
 Information decoded from early well-known custom attributes applied on a type.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MethodWellKnownAttributeData">
	<summary>
 Information decoded from well-known custom attributes applied on a method.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MethodEarlyWellKnownAttributeData">
	<summary>
 Information decoded from early well-known custom attributes applied on a method.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.EventWellKnownAttributeData">
	<summary>
 Information decoded from well-known custom attributes applied on an event.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ParameterEarlyWellKnownAttributeData">
	<summary>
 Information decoded from early well-known custom attributes applied on a parameter.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AssemblySymbol.m_CorLibrary">
	<summary>
 The system assembly, which provides primitive types like Object, String, etc., think mscorlib.dll. 
 The value is provided by AssemblyManager and must not be modified. For SourceAssemblySymbol, non-missing 
 coreLibrary must match one of the referenced assemblies returned by GetReferencedAssemblySymbols() method of 
 the main module. If there is no existing assembly that can be used as a source for the primitive types, 
 the value is a Compilation.MissingCorLibrary. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssemblySymbol.CorLibrary">
	<summary>
 The system assembly, which provides primitive types like Object, String, etc., think mscorlib.dll. 
 The value is a MissingAssemblySymbol if none of the referenced assemblies can be used as a source for the 
 primitive types and the owning assembly cannot be used as the source too. Otherwise, it is one of 
 the referenced assemblies returned by GetReferencedAssemblySymbols() method or the owning assembly.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.SetCorLibrary(Roslyn.Compilers.VisualBasic.AssemblySymbol)">
	<summary>
 A helper method for AssemblyManager to set the system assembly, which provides primitive 
 types like Object, String, etc., think mscorlib.dll. 
 </summary>
	<param name="corLibrary"></param>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssemblySymbol.BaseName">
	<summary>
 Get the base name of the assembly. This is equivalent to AssemblyName.Name, but may be 
 much faster to retrieve for source code assemblies, since it does not require binding the assembly-level
 attributes that contain the version number and other assembly information.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssemblySymbol.IsInteractive">
	<summary>
 True if the assembly contains interactive code.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssemblySymbol.Identity">
	<summary>
 Get the name of this assembly.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssemblySymbol.Modules">
	<summary>
 Gets a read-only list of all the modules in this assembly. (There must be at least one.) The first one is the main module
 that holds the assembly manifest.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssemblySymbol.GlobalNamespace">
	<summary>
 Gets the merged root namespace that contains all namespaces and types defined in the modules
 of this assembly. If there is just one module in this assembly, this property just returns the 
 GlobalNamespace of that module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssemblySymbol.IsMissing">
	<summary>
 Does this symbol represent a missing assembly.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.LookupTopLevelMetadataType(Roslyn.Compilers.Internal.MetadataTypeName@)">
	<summary>
 Lookup a top level type referenced from metadata, names should be
 compared case-sensitively.
 </summary>
	<param name="emittedName">
 Full type name with generic name mangling.
 </param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.LookupAssemblyForForwardedMetadataType(Roslyn.Compilers.Internal.MetadataTypeName@,System.Boolean)">
	<summary>
 Look up the assembly to which the given metadata type is forwarded.
 </summary>
	<param name="emittedName"></param>
	<param name="ignoreCase">Pass true to look up emittedName case-insensitively.  WARNING: more expensive.</param>
	<returns>
 The assembly to which the given type is forwarded or nothing, if there isn't one.
 </returns>
	<remarks>
 The returned assembly may also forward the type.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.GetDeclaredSpecialType(Roslyn.Compilers.SpecialType)">
	<summary>
 Lookup declaration for predefined CorLib type in this Assembly. Only valid if this 
 assembly is the Cor Library
 </summary>
	<param name="type"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.RegisterDeclaredSpecialType(Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Register declaration of predefined CorLib type in this Assembly.
 </summary>
	<param name="corType"></param>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssemblySymbol.KeepLookingForDeclaredSpecialTypes">
	<summary>
 Continue looking for declaration of predefined CorLib type in this Assembly
 while symbols for new type declarations are constructed.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.GetNoPiaResolutionAssemblies">
	<summary>
 Return an array of assemblies involved in canonical type resolution of
 NoPia local types defined within this assembly. In other words, all 
 references used by previous compilation referencing this assembly.
 </summary>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.GetLinkedReferencedAssemblies">
	<summary>
 Return an array of assemblies referenced by this assembly, which are linked (/l-ed) by 
 each compilation that is using this AssemblySymbol as a reference. 
 If this AssemblySymbol is linked too, it will be in this array too.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssemblySymbol.IsLinked">
	<summary>
 Assembly is /l-ed by compilation that is using it as a reference.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.GetInternalsVisibleToPublicKeys(System.String)">
	<summary>
 An empty list means there was no IVT attribute with matching <paramref>"simpleName"</paramref>.
 An IVT attribute without a public key setting is represented by an entry that is empty in the returned list
 </summary>
	<param name="simpleName"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.GetSpecialType(Roslyn.Compilers.SpecialType)">
	<summary>
 Get symbol for predefined type from Cor Library used by this assembly.
 </summary>
	<param name="type"></param>
	<returns>The symbol for the pre-defined type or Nothing if the type is not defined in the core library</returns>
	<remarks></remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssemblySymbol.ObjectType">
	<summary>
 The NamedTypeSymbol for the .NET System.Object type, which could have a TypeKind of
 Error if there was no COR Library in a compilation using the assembly.
</summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.GetPrimitiveType(Microsoft.Cci.PrimitiveTypeCode)">
	<summary>
 Get symbol for predefined type from Cor Library used by this assembly.
 </summary>
	<param name="type"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.GetTypeByMetadataName(System.String)">
	<summary>
 Lookup a type within the assembly using its canonical CLR metadata name (names are compared case-sensitively).
 </summary>
	<param name="metadataName">
	</param>
	<returns>
 Symbol for the type or null if type cannot be found or is ambiguous. 
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.GetTypeByMetadataName(System.String,System.Boolean,System.Boolean)">
	<summary>
 Lookup a type within the assembly using its canonical CLR metadata name (names are compared case-sensitively).
 </summary>
	<param name="metadataName"></param>
	<param name="includeReferences">
 If search within assembly fails, lookup in assemblies referenced by the primary module.
 For source assembly, this is equivalent to all assembly references given to compilation.
 </param>
	<param name="useCLSCompliantNameArityEncoding">
 While resolving the name, consider only types following CLS-compliant generic type names and arity encoding (ECMA-335, section 10.7.2).
 I.e. arity is inferred from the name and matching type must have the same emitted name and arity.
 </param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.AssemblySymbol.GetTopLevelTypeByMetadataName(Roslyn.Compilers.Internal.MetadataTypeName@,System.Boolean)">
	<summary>
 Lookup a top level type within the assembly or one of the assemblies reeferenced by the primary module, 
 names are compared case-sensitively. In case of ambiguity, type from this assembly wins,
 otherwise Nothing is returned.
 </summary>
	<returns>
 Symbol for the type or Nothing if type cannot be found or ambiguous. 
 </returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.AssemblySymbol.MightContainExtensionMethods">
	<summary>
 If this property returns false, it is certain that there are no extension
 methods (from language perspective) inside this assembly. If this property returns true, 
 it is highly likely (but not certain) that this type contains extension methods. 
 This property allows the search for extension methods to be narrowed much more quickly.
 
 !!! Note that this property can mutate during lifetime of the symbol !!!
 !!! from True to False, as we learn more about the assembly.         !!! 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AssemblySymbol">
	<summary>
 Represents a .NET assembly. An assembly consists of one or more modules.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Compilation.AssemblyManager.CacheLockObject">
	<summary>
 The object that must be locked for the duration of read/write operations on AssemblyManager's caches.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.AssemblyManager.WeakIdentityPropertiesEquivalent(Roslyn.Compilers.AssemblyIdentity,Roslyn.Compilers.AssemblyIdentity)">
	<summary>
 VB allows two weak assembly references of the same simple name be passed to a compilation 
 as long as their versions are different. It ignores culture.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.AssemblyManager.IsSourceAssemblySymbolCreated(Roslyn.Compilers.VisualBasic.Compilation)">
	<summary>
 For testing purposes only.
 </summary>
	<param name="compilation"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.AssemblyManager.IsReferencedAssembliesMapCreated(Roslyn.Compilers.VisualBasic.Compilation)">
	<summary>
 For testing purposes only.
 </summary>
	<param name="compilation"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.AssemblyManager.IsReferencedModulesMapCreated(Roslyn.Compilers.VisualBasic.Compilation)">
	<summary>
 For testing purposes only.
 </summary>
	<param name="compilation"></param>
	<returns></returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.Compilation.AssemblyManager">
	<summary>
 AssemblyManager encapsulates functionality to create an underlying SourceAssemblySymbol 
 (with underlying ModuleSymbols) for Compilation and AssemblySymbols for referenced assemblies 
 (with underlying ModuleSymbols) all properly linked together based on reference resolution 
 between them.
 
 AssemblyManager is also responsible for reuse of metadata readers for imported modules and 
 assemblies as well as existing AssemblySymbols for referenced assemblies. In order to do that, 
 it maintains global cache for metadata readers and AssemblySymbols associated with them. 
 The cache uses WeakReferences to refer to the metadata readers and AssemblySymbols to allow 
 memory and resources being reclaimed once they are no longer used. The tricky part about reusing 
 existing AssemblySymbols is to find a set of AssemblySymbols that are created for the referenced 
 assemblies, which (the AssemblySymbols from the set) are linked in a way, consistent with the 
 reference resolution between the referenced assemblies.
 
 When existing Compilation is used as a metadata reference, there are scenarios when its underlying 
 SourceAssemblySymbol cannot be used to provide symbols in context of the new Compilation. Consider 
 classic multi-targeting scenario: compilation C1 references v1 of Lib.dll and compilation C2 
 references C1 and v2 of Lib.dll. In this case, SourceAssemblySymbol for C1 is linked to AssemblySymbol 
 for v1 of Lib.dll. However, given the set of references for C2, the same reference for C1 should be 
 resolved against v2 of Lib.dll. In other words, in context of C2, all types from v1 of Lib.dll 
 leaking through C1 (through method signatures, etc.) must be retargeted to the types from v2 of Lib.dll.
 In this case, AssemblyManager creates a special RetargetingAssemblySymbol for C1, which is responsible 
 for the type retargeting. The RetargetingAssemblySymbols could also be reused for different 
 Compilations, AssemblyManager maintains a cache of RetargetingAssemblySymbols (WeakReferences) for each 
 Compilation.
 
 The only public entry point of this class is CreateSourceAssembly() method.
 
 TODO: Comment on CorLibrary.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayTypeSymbol.#ctor(Roslyn.Compilers.VisualBasic.TypeSymbol,System.Collections.Generic.List{Roslyn.Compilers.MetadataReader.MetadataDecoder{Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.AssemblySymbol,Roslyn.Compilers.VisualBasic.Symbol}.ModifierInfo},Roslyn.Compilers.VisualBasic.AssemblySymbol)">
	<summary>
 Create a new ArrayTypeSymbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayTypeSymbol.#ctor(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.CustomModifier},System.Int32,Roslyn.Compilers.VisualBasic.Compilation)">
	<summary>
 Create a new ArrayTypeSymbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayTypeSymbol.#ctor(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.CustomModifier},System.Int32,Roslyn.Compilers.VisualBasic.AssemblySymbol)">
	<summary>
 Create a new ArrayTypeSymbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayTypeSymbol.#ctor(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.CustomModifier},System.Int32,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Create a new ArrayTypeSymbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayTypeSymbol.#ctor(Roslyn.Compilers.VisualBasic.TypeSymbol,System.Int32,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Create a new ArrayTypeSymbol.
 </summary>
	<param name="elementType">The element type of this array type.</param>
	<param name="rank">The rank of this array type.</param>
	<param name="systemArray">Symbol for System.Array</param>
	<param name="iListOfT">Symbol for IList(Of T), can be Nothing for rank &gt; 1.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayTypeSymbol.#ctor(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.CustomModifier},System.Int32,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.NamedTypeSymbol})">
	<summary>
 Create a new ArrayTypeSymbol.
 </summary>
	<param name="elementType">The element type of this array type.</param>
	<param name="customModifiers"> THe custom modifiers, if any</param>
	<param name="rank">The rank of this array type.</param>
	<param name="systemArray">Symbol for Syste.Array</param>
	<param name="interfaces">Symbols for the interfaces of this array. Should be IList(Of elementType) or Nothing.</param>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayTypeSymbol.CustomModifiers">
	<summary>
 The list of custom modifiers, if any, associated with the array.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayTypeSymbol.Rank">
	<summary>
 Gets the number of dimensions of this array. A regular single-dimensional array
 has rank 1, a two-dimensional array has rank 2, etc.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ArrayTypeSymbol.ElementType">
	<summary>
 Gets the type of the elements that are stored in this array.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayTypeSymbol.InternalSubstituteTypeParameters(Roslyn.Compilers.VisualBasic.TypeSubstitution)">
	<summary>
 Substitute the given type substitution within this type, returning a new type. If the
 substitution had no effect, return Me. 
 !!! Only code implementing construction of generic types is allowed to call this method !!!
 !!! All other code should use Construct methods.                                        !!! 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ArrayTypeSymbol">
	<summary>
 An ArrayTypeSymbol represents an array type, such as Integer() or Object(,).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.AnonymousTypeOrDelegateTemplateSymbol.m_metadataEntityName">
	<summary>
 The name used to emit definition of the type. Will be set when the type's 
 metadata is ready to be emitted, Name property will throw exception if this field 
 is queried before that moment because the name is not defined yet.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.AnonymousTypeOrDelegateTemplateSymbol.TypeDescriptorKey">
	<summary>
 The key of the anonymous type descriptor used for this type template
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.AnonymousTypeOrDelegateTemplateSymbol.GenerateNameForIndex(System.Int32)">
	<summary> Generates the template name base on the index </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.AnonymousTypeOrDelegateTemplateSymbol.LocationAndNames">
	<summary> Describes the type descriptor location and property/parameter names associated with this location </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.AnonymousTypeOrDelegateTemplateSymbol.AdjustMetadataNames(Roslyn.Compilers.VisualBasic.AnonymousTypeDescriptor)">
	<summary>
 In emit phase every time a created anonymous type is referenced we try to adjust name of 
 template's fields as well as store the lowest location of the template. The last one will 
 be used for ordering templates and assigning emitted type names.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.AnonymousTypeOrDelegateTemplateSymbol.GenerateAllDeclarationErrors(System.Threading.CancellationToken)">
	<summary>
 Force all declaration errors to be generated.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.AnonymousTypeTemplateSymbol.GenerateNameForIndex(System.Int32)">
	<summary> Generates the template name base on the index </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.AnonymousTypePropertySymbol.PropertyIndex">
	<summary> Index of the property in the containing anonymous type </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.AnonymousTypeConstructorSymbol.SuppressDebugInfo">
	<summary>
 If True, suppresses generation of debug info in this method even if generateDebugInfo is true
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.AnonymousDelegateTemplateSymbol.GenerateNameForIndex(System.Int32)">
	<summary> Generates the template name base on the index </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.NonGenericAnonymousDelegateSymbol">
	<summary>
 This is a symbol to represent Anonymous Delegate for a lambda
 like:
        Sub() ...
 
 This delegate type doesn't have generic parameters. Unlike generic anonymous types,
 for which we are constructing new instance of substituted symbol for each use site 
 with reference to the location, we are creating new instance of this symbol with its
 own location for each use site. But all of them are representing the same delegate 
 type and are going to be equal to each other. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.AnonymousTypeOrDelegatePublicSymbol.GenerateAllDeclarationErrors(System.Threading.CancellationToken)">
	<summary>
 Force all declaration errors to be generated.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.AnonymousTypeOrDelegatePublicSymbol.MapToImplementationSymbol">
	<summary> 
 Map an anonymous type or delegate public symbol to an implementation symbol to be 
 used in emit.
 
 NOTE: All anonymous types/delegated (except for delegate with signature 'Sub()') with the 
 same set of fields/parameters (field names and IsKey flags are taken into account) are 
 generated based on the same generic type template.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.AnonymousTypeOrDelegatePublicSymbol.MapMethodToImplementationSymbol(Roslyn.Compilers.VisualBasic.MethodSymbol)">
	<summary> 
 Map an anonymous type or delegate's method symbol to an implementation method symbol to be used in emit
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.AnonymousTypeOrDelegatePublicSymbol.FindSubstitutedMethodSymbol(Roslyn.Compilers.VisualBasic.MethodSymbol)">
	<summary> 
 Map an anonymous type or delegate's method symbol to a substituted method symbol.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.AnonymousTypePropertyPublicSymbol.PropertyIndex">
	<summary> Index of the property in the containing anonymous type </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AnonymousTypeManager._concurrentTypesCache">
	<summary> Cache of created anonymous types </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AnonymousTypeManager._concurrentDelegatesCache">
	<summary> Cache of created anonymous delegates </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AnonymousTypeManager._anonymousTypeTemplatesSetIsSealed">
	<summary> 
 We should not see new anonymous types from source after we finished emit,
 this field seals the collection; in DEBUG it also is used to check this assertion.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.AreTemplatesSealed">
	<summary>
 Collection of anonymous type templates is sealed 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.GetOrCreateAnonymousTypeImplementationSymbol(Roslyn.Compilers.VisualBasic.AnonymousTypeManager.AnonymousTypePublicSymbol)">
	<summary> 
 Given anonymous type public symbol construct an anonymous type symbol to be used 
 in emit; the type symbol is created based on generic type generated for each 
 'unique' anonymous type structure.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.GetOrCreateAnonymousDelegateImplementationSymbol(Roslyn.Compilers.VisualBasic.AnonymousTypeManager.AnonymousDelegatePublicSymbol)">
	<summary> 
 Given anonymous delegate public symbol construct an anonymous type symbol to be 
 used in emit; the type symbol may be created based on generic type generated for 
 each 'unique' anonymous delegate structure OR if the delegate's signature is 
 'Sub()' it will be an instance of NonGenericAnonymousDelegateSymbol type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.AssignTemplatesNamesAndCompile(Roslyn.Compilers.VisualBasic.Compilation.MethodCompiler,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Resets numbering in anonymous type names and compiles their methods
 NOTE: this call also seals the collection of templates so after it is called once
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.AllCreatedTemplates">
	<summary> Returns all templates owned by this type manager </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.ContainingModule">
	<summary> Source module </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.Compilation">
	<summary> Owning compilationSource module </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.ConstructAnonymousTypeSymbol(Roslyn.Compilers.VisualBasic.AnonymousTypeDescriptor)">
	<summary> 
 Given anonymous type descriptor provided construct an anonymous type symbol
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.ConstructAnonymousDelegateSymbol(Roslyn.Compilers.VisualBasic.AnonymousTypeDescriptor)">
	<summary> 
 Given anonymous delegate descriptor provided, construct an anonymous delegate symbol
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.EqualsIgnoringCustomModifiers(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Compares anonymous types ignoring custom modifiers
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AnonymousTypeManager">
	<summary> 
 Manages anonymous types and delegates created on module level. All requests 
 for anonymous type/delegate symbols go via the instance of this class.
 
 Manager also is in charge of creating implementation types which are used in 
 emit phase to substitute anonymous type/delegate public symbols.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AnonymousTypeDescriptor.Location">
	<summary> Anonymous type/delegate location </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AnonymousTypeDescriptor.Fields">
	<summary> Anonymous type fields </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AnonymousTypeDescriptor.Key">
	<summary> 
 Anonymous type descriptor Key 
 
 The key is being used to separate anonymous type templates, for example in an anonymous type 
 symbol cache. The type descriptors with the same keys are supposed to map to 'the same' anonymous
 type template in terms of the same generic type being used for their implementation.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AnonymousTypeDescriptor.IsImplicitlyDeclared">
	<summary> Anonymous type is implicitly declared </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AnonymousTypeDescriptor.Parameters">
	<summary> Anonymous delegate parameters, including one for return type </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AnonymousTypeDescriptor.IsGood">
	<summary>
 This is ONLY used for debugging purpose
 </summary>
	<value></value>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AnonymousTypeDescriptor.SubstituteTypeParametersIfNeeded(Roslyn.Compilers.VisualBasic.TypeSubstitution,Roslyn.Compilers.VisualBasic.AnonymousTypeDescriptor@)">
	<summary>
 Performs internal substitution of types in anonymous type descriptor fields and returns True 
 if any of the fields was changed, in which case a new descriptor is returned in newDescriptor
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AnonymousTypeDescriptor">
	<summary> 
 Describes anonymous type/delegate in terms of fields/parameters
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AnonymousTypeField.Name">
	<summary> Anonymous type field/parameter name, not nothing and not empty </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AnonymousTypeField.Location">
	<summary>Location of the field</summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AnonymousTypeField.Type">
	<summary> Anonymous type field/parameter type, must be not nothing when 
 the field is passed to anonymous type descriptor </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AnonymousTypeField._type">
	<summary> 
 Anonymous type field/parameter type, may be nothing when field descriptor is created,
 must be assigned before passing the descriptor to anonymous type descriptor.
 Once assigned, is considered to be 'sealed'. 
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AnonymousTypeField.IsKey">
	<summary> Anonymous type field is declared as a 'Key' field </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AnonymousTypeField.IsByRef">
	<summary>
 Does this describe a ByRef parameter of an Anonymous Delegate type
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AnonymousTypeField.IsGood">
	<summary>
 This is ONLY used for debugging purpose
 </summary>
	<value></value>
	<returns></returns>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.AnonymousTypeField">
	<summary> 
 Describes anonymous type field in terms of its name, type and other attributes.
 Or describes anonymous delegate parameter, including "return" parameter, in terms 
 of its name, type and other attributes.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.CheckAndReportMissingSymbols(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.AnonymousTypeManager.AnonymousTypeOrDelegateTemplateSymbol},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Checks if all special and well-known symbols required for emitting anonymous types 
 provided exist, if not reports errors and returns True.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AliasSymbol.Target">
	<summary>
 Gets the <see cref="T:Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol"/>  for the
 namespace or type referenced by the alias.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AliasSymbol.ContainingSymbol">
	<summary>
 Using aliases in VB are always at the top
 level within a compilation unit, within the [Global] namespace declaration.  We
 return that as the "containing" symbol, even though the alias isn't a member of the
 namespace as such.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AliasSymbol">
	<summary>
 Symbol representing a using alias appearing in a compilation unit. 
 Generally speaking, these symbols do not appear in the set of symbols reachable
 from the unnamed namespace declaration.  In other words, when a using alias is used in a
 program, it acts as a transparent alias, and the symbol to which it is an alias is used in
 the symbol table.  For example, in the source code
 <pre>
 Imports o = System.Object
 Namespace NS
     partial class C : Inherits o : End Class
     partial class C : Inherits Object : End Class
     partial class C : Inherits System.Object : End Class
 End Namespace
 
 </pre>
 all three declarations for class C are equivalent and result in the same symbol table object for C. 
 However, these alias symbols do appear in the results of certain SemanticModel APIs. 
 Specifically, for the base clause of the first of C's class declarations, the
 following APIs may produce a result that contains an AliasSymbol:
 <pre>
     SemanticInfo SemanticModel.GetSemanticInfo(ExpressionSyntax expression);
     SemanticInfo SemanticModel.BindExpression(SyntaxNode location, ExpressionSyntax expression);
     SemanticInfo SemanticModel.BindType(SyntaxNode location, ExpressionSyntax type);
     SemanticInfo SemanticModel.BindNamespaceOrType(SyntaxNode location, ExpressionSyntax type);
 </pre>
 Also, the following are affected if container=Nothing (and, for the latter, when container=Nothing or arity=0):
 <pre>
     Public Function LookupNames(position As Integer, Optional container As NamespaceOrTypeSymbol = Nothing, Optional options As LookupOptions = LookupOptions.Default, Optional results As List(Of String) = Nothing) As IList(Of String)
     Public Function LookupSymbols(position As Integer,
                                  Optional container As NamespaceOrTypeSymbol = Nothing,
                                  Optional name As String = Nothing,
                                  Optional arity As Integer? = Nothing,
                                  Optional options As LookupOptions = LookupOptions.Default,
                                  Optional results As List(Of Symbol) = Nothing) As IList(Of Symbol)
 </pre>
	</summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Accessibility.NotApplicable">
	<summary>
 Indicates that accessibility is not applicable to this kind of symbol.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Accessibility">
	<summary>
 Represents the accessibility of a symbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolDisplayVisitor.AddConstantValue(Roslyn.Compilers.Common.ITypeSymbol,System.Object)">
	<summary> Append a default argument (i.e. the default argument of an optional parameter). 
 Assumed to be non-null. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SymbolDisplayVisitor.TypeParameterSpecialConstraintCount(Roslyn.Compilers.Common.ITypeParameterSymbol)">
	<summary>
 Return the number of special constraints ('Class', 'Structure',
 and 'New') associated with the type parameter.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.CustomSymbolDisplayFormatter">
	<summary>
 This class associates a symbol with particular custom format for display.
 It can be passed as an argument for an error message in place where symbol display should go, 
 which allows to defer building strings and doing many other things (like loading metadata) 
 associated with that until the error message is actually requested.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeArgumentInference.InferenceNode.InferTypeAndPropagateHints">
	<summary>
 Returns True if the inference algorithm should be restarted.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeArgumentInference.InferenceGraph.FindMatchingBaseInterface(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol@)">
	<summary>
 Returns False if the search should be cancelled.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeArgumentInference.InferenceGraph.FindMatchingBaseClass(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol@)">
	<summary>
 Returns False if the search should be cancelled.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeArgumentInference">
	<summary>
 The only public entry point is the Infer method.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.StatementSyntaxWalker">
	<summary>
 This class walks all the statements in some syntax, in order, except those statements that are contained
 inside expressions (a statement can occur inside an expression if it is inside
 a lambda.)
 
 This is used when collecting the declarations and declaration spaces of a method body.
 
 Typically the client overrides this class and overrides various Visit methods, being sure to always
 delegate back to the base.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticFacts.HaveSameSignature(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.MethodSymbol)">
	<summary>
 Determine if two methods have the same signature according to section 4.1.1 of the VB language spec.
 The name, number of type parameters, and number and types of the method's non-optional parameters are
 considered. ByRef/Byval, parameter names, returns type, constraints, or optional parameters are not considered.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticFacts.IsSymbolAccessible(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary> 
 Checks if 'symbol' is accessible from within 'within'.  If 'symbol' is accessed off
 of an expression then 'throughTypeOpt' is the type of that expression. This is needed to
 properly do protected access checks.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticFacts.IsSymbolAccessible(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.AssemblySymbol)">
	<summary> 
 Checks if 'symbol' is accessible from within the assembly 'within', but outside any 
 type. Protected members are deemed inaccessible.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverloadResolution.Candidate.IsExtensionMethod">
	<summary>
 Whether the method is used as extension method vs. called as a static method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverloadResolution.Candidate.IsOperator">
	<summary>
 Whether the method is used as an operator.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverloadResolution.Candidate.IsLifted">
	<summary>
 Whether the method is used in a lifted to nullable form.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverloadResolution.Candidate.PrecedenceLevel">
	<summary>
 Precedence level for an extension method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverloadResolution.Candidate.FixedTypeParameters">
	<summary>
 Extension method type parameters that were fixed during currying, if any.
 If none were fixed, BitArray.Null should be returned. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverloadResolution.Candidate.ReceiverType">
	<summary>
 Receiver type for extension method. Otherwise, containing type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverloadResolution.Candidate.ReceiverTypeDefinition">
	<summary>
 For extension methods, the type of the fist parameter in method's definition (i.e. before type parameters are substituted).
 Otherwise, same as the ReceiverType.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.OverloadResolution.Candidate">
	<summary>
 Information about a candidate from a group.
 Will have different implementation for methods, extension methods and properties.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.OverloadResolution.MethodCandidate">
	<summary>
 Implementation for an ordinary method (based on usage).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.OverloadResolution.ExtensionMethodCandidate">
	<summary>
 Implementation for an extension method, i.e. it is used as an extension method.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.OverloadResolution.OperatorCandidate">
	<summary>
 Implementation for an operator
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.OverloadResolution.LiftedOperatorCandidate">
	<summary>
 Implementation for a lifted operator.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.OverloadResolution.PropertyCandidate">
	<summary>
 Implementation for a property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult.MaxDelegateRelaxationLevel">
	<summary>
 Only bits specific to delegate relaxation level are returned.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverloadResolution.OverloadResolutionResult.RemainingCandidatesRequireNarrowingConversion">
	<summary>
 This might simplify error reporting. If not, consider getting rid of this property. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.MethodOrPropertyInvocationOverloadResolution(Roslyn.Compilers.VisualBasic.BoundMethodOrPropertyGroup,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.ReadOnlyArray{System.String},Roslyn.Compilers.VisualBasic.Binder,System.Boolean)">
	<summary>
 Perform overload resolution on the given method or property group, with the given arguments and names.
 The names can be null if no names were supplied to any arguments.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.QueryOperatorInvocationOverloadResolution(Roslyn.Compilers.VisualBasic.BoundMethodGroup,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.VisualBasic.Binder,System.Boolean)">
	<summary>
 Perform overload resolution on the given method group, with the given arguments.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.MethodInvocationOverloadResolution(Roslyn.Compilers.VisualBasic.BoundMethodGroup,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.ReadOnlyArray{System.String},Roslyn.Compilers.VisualBasic.Binder,System.Boolean,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.BoundNode,System.Boolean,System.Boolean)">
	<summary>
 Perform overload resolution on the given method group, with the given arguments and names.
 The names can be null if no names were supplied to any arguments.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.PropertyInvocationOverloadResolution(Roslyn.Compilers.VisualBasic.BoundPropertyGroup,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.ReadOnlyArray{System.String},Roslyn.Compilers.VisualBasic.Binder,System.Boolean)">
	<summary>
 Perform overload resolution on the given array of property symbols. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ShouldConsiderExtensionMethods(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult})">
	<summary>
 Given instance method candidates gone through applicability analysis, 
 figure out if we should consider extension methods, if any.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.EliminateLessApplicableToTheArguments(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean,Roslyn.Compilers.VisualBasic.Binder,System.Boolean)">
	<summary>
 §11.8.1 Overloaded Method Resolution
      6.	Next, if, given any two members of the set, M and N, M is more applicable than N 
         to the argument list, eliminate N from the set. If more than one member remains 
         in the set and the remaining members are not equally applicable to the argument 
         list, a compile-time error results.
      7.	Otherwise, given any two members of the set, M and N, apply the following tie-breaking rules, in order.
 
 Returns amount of applicable candidates left.
 
 Note that less applicable candidates are going to be eliminated if and only if there are most applicable
 candidates.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ApplyTieBreakingRulesToEquallyApplicableCandidates(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Returns amount of applicable candidates left.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.FastFindMostApplicableCandidates(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.ArrayBuilder{System.Int32},Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Returns True if there are most applicable candidates.
 
 indexesOfMostApplicableCandidates will contain indexes of equally applicable candidates, which are most applicable
 by comparison to the other (non-equal) candidates. The indexes will be in ascending order.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ApplyTieBreakingRules(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult},Roslyn.Compilers.ArrayBuilder{System.Int32},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 §11.8.1 Overloaded Method Resolution
      7.	Otherwise, given any two members of the set, M and N, apply the following tie-breaking rules, in order.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ShadowBasedOnTieBreakingRules(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean@,System.Boolean@,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 §11.8.1 Overloaded Method Resolution
      7.	Otherwise, given any two members of the set, M and N, apply the following tie-breaking rules, in order.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ShadowBasedOnSubOrFunction(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean@,System.Boolean@)">
	<summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
    7.10.	If the overload resolution is being done to resolve the target of a 
             delegate-creation expression from an AddressOf expression and M is a 
             function, while N is a subroutine, eliminate N from the set.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ShadowBasedOnDelegateRelaxation(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult},System.Int32@)">
	<summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
 7.8.	If one or more arguments are AddressOf or lambda expressions, and all of the corresponding 
         delegate types in M match exactly, but not all do in N, eliminate N from the set.
 7.9.	If one or more arguments are AddressOf or lambda expressions, and all of the corresponding 
         delegate types in M are widening conversions, but not all are in N, eliminate N from the set.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ShadowBasedOnOptionalParametersDefaultsUsed(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,System.Boolean@,System.Boolean@)">
	<summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
 7.9.	If M did not use any optional parameter defaults in place of explicit 
         arguments, but N did, then eliminate N from the set.
 
 !!!WARNING!!! The index (7.9) is based on "VB11 spec [draft 3]" version of documentation rather 
 than Dev10 documentation.
 TODO: Update indexes of other overload method resolution rules 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ShadowBasedOnInferenceLevel(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder,System.Int32@,System.Int32@,System.Boolean@)">
	<summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
 7.7.  If M and N both required type inference to produce type arguments, and M did not 
       require determining the dominant type for any of its type arguments (i.e. each the 
       type arguments inferred to a single type), but N did, eliminate N from the set.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.CompareApplicabilityToTheArguments(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult@,Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 §11.8.1.1 Applicability
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.CompareParameterTypeApplicability(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 §11.8.1.1 Applicability
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.GroupEquallyApplicableCandidates(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult},System.Int32)">
	<summary>
 This method groups equally applicable (§11.8.1.1 Applicability) candidates into buckets. 
 
 Returns an ArrayBuilder of buckets. Each bucket is represented by an ArrayBuilder(Of Integer), 
 which contains indexes of equally applicable candidates from input parameter 'candidates'.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.EliminateExtensionMethodsInPresenceOfInstanceMethods(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult})">
	<summary>
 §11.8.1 Overloaded Method Resolution
      5.	Next, if any instance methods remain in the set, 
         eliminate all extension methods from the set.
 
 Returns amount of applicable candidates left.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.AnalyzeNarrowingCandidates(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean,System.Boolean,Roslyn.Compilers.VisualBasic.Binder,System.Boolean@)">
	<summary>
 §11.8.1 Overloaded Method Resolution
      3.	Next, eliminate all members from the set that require narrowing conversions 
         to be applicable to the argument list, except for the case where the argument 
         expression type is Object.
      4.	Next, eliminate all remaining members from the set that require narrowing coercions 
         to be applicable to the argument list. If the set is empty, the type containing the 
         method group is not an interface, and strict semantics are not being used, the 
         invocation target expression is reclassified as a late-bound method access.
         Otherwise, the normal rules apply.
 
 Returns amount of applicable candidates left.
 </summary>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.EliminateNotApplicableToArguments(Roslyn.Compilers.VisualBasic.BoundMethodOrPropertyGroup,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.ReadOnlyArray{System.String},Roslyn.Compilers.VisualBasic.Binder,System.Int32@)">
	<summary>
 §11.8.1 Overloaded Method Resolution
     2.	Next, eliminate all members from the set that are inaccessible or not applicable to the argument list.
 
 Note, similar to Dev10 compiler this process will eliminate candidates requiring narrowing conversions
 if strict semantics is used, exception are candidates that require narrowing only from numeric constants.
 
 Returns amount of applicable candidates left.
 </summary>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.BuildParameterToArgumentMap(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.ReadOnlyArray{System.String},Roslyn.Compilers.ArrayBuilder{System.Int32}@,Roslyn.Compilers.ArrayBuilder{System.Int32}@)">
	<summary>
 Figure out corresponding arguments for parameters §11.8.2 Applicable Methods.
 
 Note, this function mutates the candidate structure.
 
 If non-Nothing ArrayBuilders are returned through parameterToArgumentMap and paramArrayItems
 parameters, the caller is responsible fo returning them into the pool.
 
 Assumptions: 
    1) This function is never called for a candidate that should be rejected due to parameter count.
    2) Omitted arguments [ Call Foo(a, , b) ] are represented by OmittedArgumentExpression node in the arguments array.
    3) Omitted argument never has name.
    4) argumentNames contains Nothing for all positional arguments.
 
 !!! Should keep this function in sync with Binder.PassArguments, which uses data this function populates.              !!!
 !!! Should keep this function in sync with Binder.ReportOverloadResolutionFailureForASingleCandidate.                  !!!
 !!! Everything we flag as an error here, Binder.ReportOverloadResolutionFailureForASingleCandidate should detect as well. !!!
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.MatchArguments(Roslyn.Compilers.VisualBasic.BoundMethodOrPropertyGroup,Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.ReadOnlyArray{System.String},Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Match candidate's parameters to arguments §11.8.2 Applicable Methods.
 
 Note, similar to Dev10 compiler this process will eliminate candidate requiring narrowing conversions
 if strict semantics is used, exception are candidates that require narrowing only from numeric constants.
 
 Assumptions: 
    1) This function is never called for a candidate that should be rejected due to parameter count.
    2) Omitted arguments [ Call Foo(a, , b) ] are represented by OmittedArgumentExpression node in the arguments array.
    3) Omitted argument never has name.
    4) argumentNames contains Nothing for all positional arguments.
 
 !!! Should keep this function in sync with Binder.PassArguments, which uses data this function populates.              !!!
 !!! Should keep this function in sync with Binder.ReportOverloadResolutionFailureForASingleCandidate.                  !!!
 !!! Should keep this function in sync with InferenceGraph.PopulateGraph.                                               !!!
 !!! Everything we flag as an error here, Binder.ReportOverloadResolutionFailureForASingleCandidate should detect as well. !!!
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.MatchArgumentToByRefParameter(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult@,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder,System.Collections.Generic.KeyValuePair{Roslyn.Compilers.VisualBasic.ConversionKind,Roslyn.Compilers.VisualBasic.MethodSymbol}@,System.Collections.Generic.KeyValuePair{Roslyn.Compilers.VisualBasic.ConversionKind,Roslyn.Compilers.VisualBasic.MethodSymbol}@)">
	<summary>
 Should be in sync with Binder.ReportByRefConversionErrors.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.MatchArgumentToByValParameter(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult@,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder,System.Collections.Generic.KeyValuePair{Roslyn.Compilers.VisualBasic.ConversionKind,Roslyn.Compilers.VisualBasic.MethodSymbol}@)">
	<summary>
 Should be in sync with Binder.ReportByValConversionErrors.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.CollectOverloadedCandidates(Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.Candidate},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.ReadOnlyArray{System.String},Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.BoundNode,System.Boolean,System.Boolean)">
	<summary>
 Performs an initial pass through the group of candidates and does
 the following in the process.
 1) Eliminates candidates based on the number of supplied arguments and number of supplied generic type arguments.
 2) Adds additional entries for expanded ParamArray forms when applicable.
 3) Infers method's generic type arguments if needed.
 4) Substitutes method's generic type arguments.
 5) Eliminates candidates based on shadowing by signature.
    This partially takes care of §11.8.1 Overloaded Method Resolution, section 7.1.	
      If M is defined in a more derived type than N, eliminate N from the set. 
 6) Eliminates candidates with identical virtual signatures by applying various shadowing and
    tie-breaking rules from §11.8.1 Overloaded Method Resolution, section 7.0 
     • If M has fewer parameters from an expanded paramarray than N, eliminate N from the set. 
 7) Takes care of unsupported overloading within the same type for instance methods/properties.
 
 Assumptions:
 1) Shadowing by name has been already applied.
 2) group can include extension methods.
 3) group contains original definitions, i.e. method type arguments have not been substituted yet. 
    Exception are extension methods with type parameters substituted based on receiver type rather 
    than based on type arguments supplied at the call site.    
 4) group contains only accessible candidates.
 5) group doesn't contain members involved into unsupported overloading, i.e. differ by casing or custom modifiers only.
 6) group does not contain duplicates.
 7) All elements of arguments array are Not Nothing, omitted arguments are represented by OmittedArgumentExpression node.
 </summary>
	<remarks>
 This method is destructive to content of the [group] parameter.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.CombineCandidates(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult},Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,System.Int32,Roslyn.Compilers.ReadOnlyArray{System.String})">
	<summary>
 Combine new candidate with the list of existing candidates, applying various shadowing and
 tie-breaking rules. New candidate may or may not be added to the result, some
 existing candidates may be removed from the result.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ShadowBasedOnExtensionVsInstanceAndPrecedence(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,System.Boolean@,System.Boolean@)">
	<summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
    7.5.	If M is not an extension method and N is, eliminate N from the set.
    7.6.	If M and N are extension methods and M was found before N, eliminate N from the set.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ShadowBasedOnGenericity(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,System.Boolean@,System.Boolean@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
    7.4.	If M is less generic than N, eliminate N from the set.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ShadowBasedOnDepthOfGenericity(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,System.Boolean@,System.Boolean@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Implements shadowing based on
 §11.8.1.3 Depth of genericity
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.CompareParameterTypeGenericDepth(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean@,System.Boolean@)">
	<summary>
	</summary>
	<returns>False if node of candidates wins</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ShadowBasedOnExtensionMethodTargetTypeGenericity(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,System.Boolean@,System.Boolean@)">
	<summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
    7.3.	If M and N are extension methods and the target type of M has fewer type 
         parameters than the target type of N, eliminate N from the set. 
         !!! Note that spec talks about "fewer type parameters", but it is not really about count. 
         !!! It is about one refers to a type parameter and the other one doesn't.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ShadowBasedOnReceiverType(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,System.Boolean@,System.Boolean@)">
	<summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
    7.1.	If M is defined in a more derived type than N, eliminate N from the set.
         This rule also applies to the types that extension methods are defined on. 
    7.2.	If M and N are extension methods and the target type of M is a class or 
         structure and the target type of N is an interface, eliminate N from the set.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.DoesReceiverMatchInstance(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 For a receiver to match an instance, more or less, the type of that instance has to be convertible
 to the type of the receiver with the same bit-representation (i.e. identity on value-types
 and reference-convertibility on reference types).
 Actually, we don't include the reference-convertibilities that seem nonsensical, e.g. enum() to underlyingtype()
 We do include inheritance, implements and variance conversions amongst others.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ShadowBasedOnParamArrayUsage(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,System.Boolean@,System.Boolean@)">
	<summary>
 Implements shadowing based on
 §11.8.1 Overloaded Method Resolution.
 •	If M has fewer parameters from an expanded paramarray than N, eliminate N from the set.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.OverloadResolution.OperatorNames">
	<summary>
 A map from Operator name to number of parameters and kind.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.OverloadResolution.OperatorInfo">
	<summary>
 Operator kind and expected number of parameters.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ResolveUnaryOperator(Roslyn.Compilers.VisualBasic.UnaryOperatorKind,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.SpecialType@,Roslyn.Compilers.VisualBasic.OverloadResolution.OverloadResolutionResult@)">
	<summary>
 Returns UnaryOperatorKind.Error in case of error, otherwise adjusted operator kind.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ResolveNotLiftedIntrinsicUnaryOperator(Roslyn.Compilers.VisualBasic.UnaryOperatorKind,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Returns result type of the operator or SpecialType.None if operator is not supported.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.TryFoldConstantUnaryOperator(Roslyn.Compilers.VisualBasic.UnaryOperatorKind,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean@)">
	<summary>
 Attempts to fold unary operator applied to a constant expression. 
 
 Returns Nothing if operator cannot be folded.
 
 If folding failed due to non-integer overflow, ConstantValue.Bad is returned. Consumer 
 is responsible for reporting appropriate diagnostics.
 
 If integer overflow occurs, integerOverflow is set to True and ConstantValue for overflowed result is returned. 
 Consumer is responsible for reporting appropriate diagnostics and potentially discarding the result.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ResolveBinaryOperator(Roslyn.Compilers.VisualBasic.BinaryOperatorKind,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.Binder,System.Boolean,Roslyn.Compilers.SpecialType@,Roslyn.Compilers.VisualBasic.OverloadResolution.OverloadResolutionResult@)">
	<summary>
 Returns UnaryOperatorKind.Error in case of error, otherwise adjusted operator kind.
 
 For comparison operators, the operator type computed here is not
 the result type of the comparison (which is typically boolean),
 but is the type to which the operands are to be converted. For
 other operators, the type computed here is both the result type
 and the common operand type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.TryFoldConstantBinaryOperator(Roslyn.Compilers.VisualBasic.BinaryOperatorKind,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean@,System.Boolean@)">
	<summary>
 Attempts to fold binary operator applied to constant expressions. 
 
 Returns Nothing if operator cannot be folded.
 
 If folding failed due to non-integer overflow or divide by zero, 
 ConstantValue.Bad is returned. Consumer is responsible for reporting appropriate diagnostics.
 
 If divide by zero occurs, divideByZero is set to True.
 
 If integer overflow occurs, integerOverflow is set to True and ConstantValue for overflowed result is returned. 
 Consumer is responsible for reporting appropriate diagnostics and potentially discarding the result.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ResolveNotLiftedIntrinsicBinaryOperator(Roslyn.Compilers.VisualBasic.BinaryOperatorKind,Roslyn.Compilers.SpecialType,Roslyn.Compilers.SpecialType)">
	<summary>
 Returns result type of the operator or SpecialType.None if operator is not supported.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.DetermineMostSpecificWideningConversion(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.MethodSymbol},Roslyn.Compilers.ArrayBuilder{System.Collections.Generic.KeyValuePair{Roslyn.Compilers.VisualBasic.ConversionKind,Roslyn.Compilers.VisualBasic.ConversionKind}},Roslyn.Compilers.BitArray@,Roslyn.Compilers.VisualBasic.MethodSymbol@,System.Boolean)">
	<summary>
 Returns True if resolution of user defined conversions is complete, i.e. there were operators
 applicable for the "Most Specific Widening Conversion" purposes. 
 This, however, doesn't mean that resolution is successful.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.ClassifyConversionOperatorInOutConversions(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.ConversionKind@,Roslyn.Compilers.VisualBasic.ConversionKind@,System.Boolean)">
	<summary>
 Returns false if operator should be ignored.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.DetermineMostSpecificNarrowingConversion(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.MethodSymbol},Roslyn.Compilers.ArrayBuilder{System.Collections.Generic.KeyValuePair{Roslyn.Compilers.VisualBasic.ConversionKind,Roslyn.Compilers.VisualBasic.ConversionKind}},Roslyn.Compilers.BitArray@,Roslyn.Compilers.VisualBasic.MethodSymbol@,System.Boolean)">
	<summary>
 Returns True if resolution of user defined conversions is complete, i.e. there was an operator
 that converts from the most specific source type to the most specific target type. 
 This, however, doesn't mean that resolution is successful.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.MostEncompassed(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.TypeSymbol})">
	<summary>
 The most encompassed type in a set of types is the one type that is encompassed
 by all other types in the set. If no single type is encompassed by all other types,
 then the set has no most encompassed type. In intuitive terms, the most encompassed
 type is the “smallest” type in the set—the one type that can be converted from each
 of the other types through a narrowing conversion.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.MostEncompassing(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.TypeSymbol})">
	<summary>
 The most encompassing type in a set of types is the one type that encompasses
 all other types in the set. If no single type encompasses all other types, then
 the set has no most encompassing type. In intuitive terms, the most encompassing
 type is the “largest” type in the set—the one type to which each of the other
 types can be converted through a widening conversion.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.DetermineConversionOperatorDegreeOfGenericity(Roslyn.Compilers.VisualBasic.MethodSymbol)">
	<summary>
 Returns number of types in the list of {input type, output type} that refer to a generic type parameter.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.IsWidening(Roslyn.Compilers.VisualBasic.MethodSymbol)">
	<summary>
 A quick check whether given conversion operator is a widening operator.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.CollectUserDefinedConversionOperators(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.MethodSymbol})">
	<summary>
 Collect user-defined conversion operators.
 Operators declared in the same type are grouped together. 
 Within a group, widening operators are followed by narrowing operators.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.CollectUserDefinedOperators(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.MethodKind,System.String,Roslyn.Compilers.VisualBasic.OverloadResolution.OperatorInfo,System.String,Roslyn.Compilers.VisualBasic.OverloadResolution.OperatorInfo,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.MethodSymbol})">
	<summary>
 Collect user-defined operators.
 Operators declared in the same type are grouped together. 
 Within a group, name1 operators are followed by name2 operators.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.CollectUserDefinedOperators(Roslyn.Compilers.VisualBasic.TypeSymbol,System.String,Roslyn.Compilers.VisualBasic.MethodKind,Roslyn.Compilers.VisualBasic.OverloadResolution.OperatorInfo,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.MethodSymbol})">
	<summary>
 Returns True if we should stop climbing inheritence hierarchy.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.OverloadResolution.GetTypeToLookForOperatorsIn(Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Given the type of operator's argument, return corresponding type to
 look for operator in. Can return Nothing.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.Exists">
	<summary>
 True if the conversion exists, either as an widening or narrowing conversion.
 </summary>
	<remarks>
 If this returns True, exactly one of IsNarrowing or IsWidening will return True. If this returns False,
 neither IsNarrowing or IsWidening will return True.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsNarrowing">
	<summary>
 True if this conversion a narrowing conversion, and not a widening conversion. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsWidening">
	<summary>
 True if this conversion is a widening conversion, and not a narrowing conversion.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsIdentity">
	<summary>
 True if this conversion is an identity conversion. 
 </summary>
	<remarks>
 Note that identity conversion are also considered widening conversions.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsDefault">
	<summary>
 True if this conversion is a default conversion (a conversion from the "Nothing" literal). 
 </summary>
	<remarks>Note that default conversions are considered widening conversions.</remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsNumeric">
	<summary>
 True if this conversion is a widening numeric conversion or a narrowing numeric conversion, as defined in
 section 8.3.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsBoolean">
	<summary>
 True if this conversion is a narrowing boolean conversion, as defined in section 8.2.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsReference">
	<summary>
 True if this conversion is a widening reference conversion or narrowing reference conversion, as defined in
 section 8.4.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsAnonymousDelegate">
	<summary>
 True if this conversion is a widening anonymous delegate conversion as defined in section 8.8, or a
 narrowing anonymous delegate conversion as defined in section 8.9.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsArray">
	<summary>
 True if this conversion is a widening array conversion or a narrowing array conversion, as defined in
 section 8.5.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsValueType">
	<summary>
 True if this conversion a widening value type conversion or a narrowing value type conversion as defined in
 section 8.6.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsNullableValueType">
	<summary>
 True if this conversion a widening nullable value type conversion or a narrowing nullable value type
 conversion as defined in section 8.6.1.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsString">
	<summary>
 True if this conversion a widening string conversion or a narrowing string conversion as defined in section
 8.7.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsTypeParameter">
	<summary>
 True if this conversion a widening type parameter or a narrowing type parameter conversion, as defined in
 section 8.10.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.IsUserDefined">
	<summary>
 True if this conversion a widening user defined or a narrowing user defined conversion, as defined in
 section 8.11.
 </summary>
	<remarks>
 If this returns True, the involved conversion method can be obtained with the UserDefinedConversionMethod
 property.
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.Conversion.Method">
	<summary>
 The method that defines the user defined conversion, if any. Otherwise returns Nothing.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Conversion">
	<summary>
 Summarizes whether a conversion is allowed, and if so, which kind of conversion (and in some cases, the
 associated symbol).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.ConversionKind.Identity">
	<summary>
 Because flags can be combined, use the method IsIdentityConversion when testing for ConversionKind.Identity
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.TryFoldConstantConversion(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean@)">
	<summary>
 Attempts to fold conversion of a constant expression. 
 
 Returns Nothing if conversion cannot be folded.
 
 If conversion failed due to non-integer overflow, ConstantValue.Bad is returned. Consumer 
 is responsible for reporting appropriate diagnostics.
 
 If integer overflow occurs, integerOverflow is set to True and ConstantValue for overflowed result is returned. 
 Consumer is responsible for reporting appropriate diagnostics and potentially discarding the result.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.TryFoldConstantNumericOrBooleanConversion(Roslyn.Compilers.ConstantValue@,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean@)">
	<summary>
 Attempts to fold conversion of a constant expression.
 
 Returns Nothing if conversion cannot be folded, i.e. unexpected source and destination types. 
 Returns Bad value (Discriminator = ConstantValueTypeDiscriminator.Bad) if conversion failed due to non-integer overflow. 
 
 If integer overflow occurs, integerOverflow is set to True and the overflowed result is returned. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.ClassifyConversion(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 This function classifies all intrinsic language conversions and user-defined conversions.
 </summary>
	<param name="source"></param>
	<param name="destination"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.ClassifyPredefinedConversion(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 This function classifies all intrinsic language conversions, such as inheritance,
 implementation, array covariance, and conversions between intrinsic types.
 </summary>
	<param name="source"></param>
	<param name="destination"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.ClassifyConversion(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 This function classifies all intrinsic language conversions and user-defined conversions.
 </summary>
	<param name="source"></param>
	<param name="destination"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.ClassifyExpressionReclassification(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Reclassify lambdas, array literals, etc. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.ClassifyUserDefinedConversion(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 This function classifies user-defined conversions between two types.
 </summary>
	<param name="source"></param>
	<param name="destination"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.ClassifyUserDefinedConversion(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 This function classifies user-defined conversions.
 </summary>
	<param name="source"></param>
	<param name="destination"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.ClassifyPredefinedConversion(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 This function classifies all intrinsic language conversions, such as inheritance,
 implementation, array covariance, and conversions between intrinsic types.
 </summary>
	<param name="source"></param>
	<param name="destination"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.ToInterfaceConversionClassificator.AccumulateConversionClassificationToVariantCompatibleInterface(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,System.Int32)">
	<summary>
 Accumulates classification information about conversion to interface.
 Returns True when classification gets promoted to Identity, this method should not 
 be called after that.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.ToInterfaceConversionClassificator.ClassifyInterfaceImmediateVarianceCompatibility(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,System.Int32)">
	<summary>
 Returns when classification gets promoted to Identity.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Conversions.ToInterfaceConversionClassificator">
	<summary>
 Helper structure to classify conversions from named types to interfaces
 in accumulating fashion.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.IsDerivedFrom(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Returns true if and only if baseType is a base class of derivedType.
 </summary>
	<param name="derivedType">
 Derived class type.
 </param>
	<param name="baseType">
 Target base class type.
 </param>
	<returns></returns>
	<remarks>
	</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.ClassifyMethodConversionBasedOnReturnType(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Calculate MethodConversionKind based on required return type conversion.
 
 TODO: It looks like Dev10 MethodConversionKinds for return are badly named because
       they appear to give classification in the direction opposite to the data
       flow. This is very confusing. However, I am not going to rename them just yet.
       Will do this when all parts are ported and working together, otherwise it will 
       be very hard to port the rest of the feature.
 
 We are trying to classify conversion between methods
 ConvertFrom(...) As returnTypeOfConvertFromMethod -&gt; ConvertTo(...) As returnTypeOfConvertToMethod
 
 The relaxation stub would look like:
 Stub(...) As returnTypeOfConvertToMethod
     Return ConvertFrom(...)
 End ... 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.ClassifyMethodConversionBasedOnArgumentConversion(Roslyn.Compilers.VisualBasic.ConversionKind,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Returns the methods conversions for the given conversion kind

 We are trying to classify conversion between methods arguments
 delegateInvoke(parameterConvertFrom) -&gt; targetMethod(parameterConvertTo)
 
 The relaxation stub would look like (stub has same signature as delegate invoke):
 Stub(parameterConvertFrom)
     return targetMethod(parameterConvertTo)
 End Method
 </summary>
	<param name="conversion">The conversion.</param>
	<param name="delegateParameterType">The delegate parameter type.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.DetermineDelegateRelaxationLevelForLambdaReturn(Roslyn.Compilers.VisualBasic.BoundReturnStatement)">
	<summary>
 Will set only bits used for delegate relaxation level.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.DetermineDelegateRelaxationLevel(Roslyn.Compilers.VisualBasic.MethodConversionKind)">
	<summary>
 Determine the relaxation level of a given conversion. This will be used by
 overload resolution in case of conflict. This is to prevent applications that compiled in VB8
 to fail in VB9 because there are more matches. And the same for flipping strict On to Off.
 
 Will set only bits used for delegate relaxation level.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.IsStubRequiredForMethodConversion(Roslyn.Compilers.VisualBasic.MethodConversionKind)">
	<summary>
 Determines whether a stub needed for the delegate creations conversion based on the given method conversions.
 </summary>
	<param name="methodConversions">The method conversions.</param><returns>
		<c>true</c> if a stub needed for conversion; otherwise, <c>false</c>.
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.IsNarrowingMethodConversion(Roslyn.Compilers.VisualBasic.MethodConversionKind,System.Boolean)">
	<summary>
 Tells whether the method conversion is considered to be narrowing or not.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Conversions.IsCLRPredefinedConversion(Roslyn.Compilers.VisualBasic.ConversionKind)">
	<summary>
 Determines whether the given conversion is CLR supported conversion or not.
 </summary>
	<param name="conversion">The conversion.</param><returns>
		<c>true</c> if the given conversion is a CLR supported conversion; otherwise, <c>false</c>.
 </returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.Conversions">
	<summary>
 The purpose of this class is to answer questions about convertibility of one type to another.
 It also answers questions about conversions from an expression to a type.

 The code is organized such that each method attempts to implement exactly one section of the
 specification.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ArrayLiteralTypeSymbol.#ctor(Roslyn.Compilers.VisualBasic.BoundArrayLiteral)">
	<summary>
 Create a new ArrayTypeSymbol.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ArrayLiteralTypeSymbol">
	<summary>
 Used by ClassifyUserDefinedConversion to pass an ArrayTypeSymbol that has a link back to the BoundArrayLiteral node.
 This allows the ClassifyConversionOperatorInOutConversions to properly classify a conversion from the inferred array 
 type to the input type of a user defined conversion.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CompileTimeCalculations.NarrowIntegralResult(System.Int64,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean@)">
	<summary>
 Narrow a quadword result to a specific integral type, setting Overflow true
 if the result value cannot be represented in the result type.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AccessCheckResult">
	<summary>
 The possible reasons a symbol may be inaccessible
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessCheck.IsSymbolAccessible(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.AssemblySymbol,Roslyn.Utilities.ConsList{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 Checks if 'symbol' is accessible from within assembly 'within'.  
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessCheck.CheckSymbolAccessibility(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.AssemblySymbol,Roslyn.Utilities.ConsList{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 Checks if 'symbol' is accessible from within assembly 'within'.  
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessCheck.IsSymbolAccessible(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Utilities.ConsList{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 Checks if 'symbol' is accessible from within type 'within', with
 an optional qualifier of type "throughTypeOpt".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessCheck.CheckSymbolAccessibility(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Utilities.ConsList{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 Checks if 'symbol' is accessible from within type 'within', with
 an qualifier of type "throughTypeOpt". Sets "failedThroughTypeCheck" to true
 if it failed the "through type" check.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessCheck.CheckSymbolAccessibilityCore(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Utilities.ConsList{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 Checks if 'symbol' is accessible from within 'within', which must be a NamedTypeSymbol or 
 an AssemblySymbol.  If 'symbol' is accessed off
 of an expression then 'throughTypeOpt' is the type of that expression. This is needed to
 properly do protected access checks. Sets "failedThroughTypeCheck" to true if this protected
 check failed.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AccessCheck.AccessExposure.ExposedType">
	<summary>
 The exposed type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AccessCheck.AccessExposure.ExposedTo">
	<summary>
 Namespace or type that "gains" access to the type.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AccessCheck.AccessExposure">
	<summary>
 Captures information about illegal access exposure.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessCheck.VerifyAccessExposure(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.AccessCheck.AccessExposure}@)">
	<summary>
 Returns true if there is no illegal access exposure, false otherwise.
 </summary>
	<param name="exposedThrough">
 Type or member exposing the type.
 </param>
	<param name="exposedType">
 The exposed type.
 </param>
	<param name="illegalExposure">
 If function returns false, it requests an instance of ArrayBuilder from the pool and populates
 it with information about illegal exposure. The caller is responsible for returning the ArrayBuilder
 to the pool.
 </param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessCheck.VerifyAccessExposure(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol@)">
	<summary>
 Returns true if there is no illegal access exposure, false otherwise.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessCheck.MemberIsOrNestedInType(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Determine if member is the definition of the type, or 
 is contained (directly or indirectly) in the definition of the type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessCheck.VerifyAccessExposureHelper(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol@,System.Boolean@,System.Boolean)">
	<summary>
 Returns true if there is no illegal access exposure, false otherwise.
 
 Four cases:
 1: Member is not protected, non of its enclosing scopes are protected
 2: Member is not protected, but some of its enclosing scopes are protected
 3: Member is protected, non of its enclosing scopes are protected
 4: Member is protected, some of its enclosing scopes are also protected
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessCheck.CanBeAccessedThroughInheritance(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,System.Boolean)">
	<summary>
 Can type be accessed through container's inheritance?
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessCheck.FindEnclosingTypeWithGivenAccess(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Accessibility,System.Boolean)">
	<summary>
 This function finds the inner most enclosing scope whose Access
 is lesser than or equal to the given access "StopAtAccess".
 </summary>
	<param name="member">Member - for which the enclosing scope has to be found</param>
	<param name="stopAtAccess">the enclosing scope's access has to be lesser than</param>
	<param name="isOutsideAssembly"></param>
</member><member name="M:Roslyn.Compilers.VisualBasic.AccessCheck.VerifyAccessExposureOfBaseClassOrInterface(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Returns false if there were errors reported due to access exposure, true otherwise.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AccessCheck">
	<summary>
 Contains the code for determining VB accessibility rules.
 </summary>
</member><member name="M:Roslyn.Scripting.VisualBasic.ScriptEngine.ValidateReferences(Roslyn.Compilers.Common.CommonCompilation,Roslyn.Compilers.DiagnosticBag)">
	<summary> 
 Checks that the compilation doesn't have any references whose name start with the reserved prefix. 
 </summary>
</member><member name="T:Roslyn.Scripting.VisualBasic.ScriptEngine">
	<summary> 
 Represents a runtime execution context for C# scripts. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.TryCrumbleOnce">
	<summary>
 Crumbles currenlty available node (if available) into its components.
 The leftmost child becomes the current node.
 If operation is not possible (node has no children, there is no node), then returns false.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.GetCurrentSyntaxNode">
	<summary>
 Gets current reusable syntax node.
 If node is returned its start will be aligned with the start of current token. 
 NOTE: Line offset may not match start of current token because of lookahead. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.MoveToNextSyntaxNode">
	<summary>
 Indicates that previously returned node has been consumed
 and scanner needs to advance by the size of the node.
 
 NOTE: the advancement is done relative to the start of the current token.
 Line offset may not match start of current token because of lookahead. 
 
 This operation will discard lookahead tokens and reset preprocessor state 
 to the state of current token. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.MoveToNextSyntaxNodeInTrivia">
	<summary>
 Indicates that previously returned node has been consumed
 and scanner needs to advance by the size of the node.
 
 NOTE: the advancement is done relative to the _lineBufferOffset.
 Line offset will likely not match start of current token because this operation
 is done while constructing the content of current token.
 
 NOTE: This operation assumes that there is no tokens read ahead.
 
 NOTE: This operation does not change preprocessor state. 
 The assumption is that it is resposibility of the node consumer to update preprocessor
 state if needed when using nodes that change preprocessor state.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.PeekToken(System.Int32,Roslyn.Compilers.VisualBasic.InternalSyntax.ScannerState)">
	<summary>
 note that state is applied only to the token #1
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.ScanSurrogatePair(System.Char,System.Int32)">
	<summary>
 0 - not a surrogate, 2 - is valid surrogate 
 1 is an error
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.Page._pageStart">
	<summary>
 where page maps in the stream. Used to validate pages
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.Page._arr">
	<summary>
 page's buffer
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.Page">
	<summary>
 page represents a cached array of chars.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner._curPage">
	<summary>
 current page we are reading.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.GetPage(System.Int32)">
	<summary>
 gets a page for the position.
 will initialize it if we have cache miss
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner._sb">
	<summary>
 DO NOT USE DIRECTLY. 
 USE GetScratch() 
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.GetDisabledTextAt(Roslyn.Compilers.TextSpan)">
	<summary>
 Gets a chunk of text as a DisabledCode node.
 </summary>
	<param name="span">The range of text.</param>
	<returns>The DisabledCode node.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.ScanNewlineAsStatementTerminator(System.Char,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode})">
	<summary>
 Accept a CR/LF pair or either in isolation as a newline.
 Make it a statement separator
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.ScanNewlineAsTrivia(System.Char)">
	<summary>
 Accept a CR/LF pair or either in isolation as a newline.
 Make it a whitespace
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.ScanMultilineTrivia">
	<summary>
 Consumes all trivia until a nontrivia char is found
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.TryScanSinglePieceOfMultilineTrivia(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxListBuilder)">
	<summary>
 Scans a single piece of trivia
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.ScanSingleLineTrivia">
	<summary>
 Scan trivia on one LOGICAL line
 Will check for whitespace, comment, EoL, implicit line break
 EoL may be consumed as whitespace only as a part of line continuation ( _ )
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.TryIdentifierAsContextualKeyword(Roslyn.Compilers.VisualBasic.InternalSyntax.IdentifierTokenSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax@)">
	<summary>
 Try to convert an Identifier to a Keyword.  Called by the parser when it wants to force
 an identifer to be a keyword.
 </summary>
	<param name="id"></param>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner">
	<summary>
 Creates red tokens for a stream of text
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.QuickTokenTable.Entry">
	<summary>
 Matches token with its spelling.
 Used in shared token cache.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.QuickTokenTable.EqualText(System.String,System.Char[],System.Int32,System.Int32)">
	<summary>
 Compare a string and a char array/length for exact equality.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.AccumulatorState">
	<summary>
 The possible states that the mini scanning can be in.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.ProcessDirective(Roslyn.Compilers.VisualBasic.InternalSyntax.DirectiveTriviaSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxListBuilder)">
	<summary>
 Entry point to directive processing for Scanner.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.ApplyDirectives(Roslyn.Compilers.VisualBasic.InternalSyntax.Scanner.PreprocessorState,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Gets an initial preprocessor state and applies all directives from a given node.
 Entry point for blender
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CharacterInfo.IsWhitespace(System.Char)">
	<summary>
 Returns true if the Unicode character represents a whitespace.
 </summary>
	<param name="c">The Unicode character.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.CharacterInfo.IsNewLine(System.Char)">
	<summary>
 Returns true if the Unicode character is a newline character.
 </summary>
	<param name="c">The Unicode character.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.CharacterInfo.IsIdentifierStartCharacter(System.Char)">
	<summary>
 Returns true if the Unicode character can be the starting character of a VB identifier.
 </summary>
	<param name="c">The Unicode character.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.CharacterInfo.IsIdentifierPartCharacter(System.Char)">
	<summary>
 Returns true if the Unicode character can be a part of a VB identifier.
 </summary>
	<param name="c">The Unicode character.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.CharacterInfo.IsValidIdentifier(System.String)">
	<summary>
 Check that the name is a valid identifier.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CharacterInfo.MatchOneOrAnother(System.Char,System.Char,System.Char)">
	<summary>
 matches one char or another.
 Typical usage is for matching lowercase and uppercase.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CharacterInfo.MatchOneOrAnotherOrFullwidth(System.Char,System.Char,System.Char)">
	<summary>
 matches one char or another.
 it will try normal width and then fullwidth variations.
 Typical usage is for matching lowercase and uppercase.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.InternalSyntax.Blender._nodeStack">
	<summary>
 Candidate nodes that may be reused.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.InternalSyntax.Blender._change">
	<summary>
 we currently support only one change.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.InternalSyntax.Blender._currentNode">
	<summary>
 Current node. Not necessarily reusable or even a NonTerminal.
 Can be null if we are out of nodes.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.InternalSyntax.Blender._affectedRangeOld">
	<summary>
 Affected ranges are ranges from which we cannot reuse nodes.
 Old and New are actually the same range defined in terms of old text and new text.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.InternalSyntax.Blender._currentPreprocessorState">
	<summary>
 preprocessor state before _currentNode
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.InternalSyntax.Blender._nextPreprocessorStateGetter">
	<summary>
 preprocessor state getter after _currentNode
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Blender.SetAffectedRanges(Roslyn.Compilers.TextChangeRange[])">
	<summary>
 Sets affected ranges. 
 Because of look-aheads the actual range from which nodes canot be used is 
 slightly bigger than region that was actually edited.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Blender.CollapseChanges(Roslyn.Compilers.TextChangeRange[])">
	<summary>
 API currently allows for multiple changes, but we can handle only one, 
 so we will collapse them into one big change for now.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Blender.TryPopNode">
	<summary>
 Moving to the next node on the stack.
 returns false if we are out of nodes.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Blender.TryCrumbleOnce">
	<summary>
 Crumbles current node onto the stack and pops one node into current.
 Returns false if current node cannot be crumbled.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Blender.GetCurrentNode(System.Int32)">
	<summary>
 Advances to given position if needed (note: no way back)
 Gets a nonterminal that can be used for incremental.
 May return Nothing if such node is not available.
 Typically it is _currentNode.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Blender.GetCurrentSyntaxNode">
	<summary>
 Returns current candidate for reuse if there is one.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Blender.CanReuseNode(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
 Checks if node is reusable.
 The reasons for it not be usable are typically that it intersects affected range.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.VerifyExpectedToken``1(Roslyn.Compilers.VisualBasic.SyntaxKind,``0@)">
	<summary>
 Check that the current token is the expected kind, the curren node is consumed and optionally a new line
 after the token.
 </summary>
	<param name="kind">Theexpected node kind.</param>
	<returns>A token of the expected kind.  This node may be an empty token with an error attached to it</returns>
	<remarks>Since nodes are immutable, the only way to create nodes with errors attached is to create a node without an error,
 then add an error with this method to create another node.</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ParseStringLiteral">
	<summary>
 Parses StringLiteral
 </summary>
	<returns>LiteralNode</returns>
	<remarks>If the current Token is not StringLiteral then returns LiteralNode with missing token.</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ResyncAtStatementTerminator">
	<summary>
 Resyncs to next statement terminator. Used in Preprocessor
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.TryEatNewLine(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode@,Roslyn.Compilers.VisualBasic.InternalSyntax.ScannerState)">
	<summary>
 If the current token is a newline statement terminator then convert it to trivia and return 
 the trivia.
 <Returns>Trivia or nothing if the statement terminator is not consumed</Returns>
	</summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ReportUnrecognizedStatementError(Roslyn.Compilers.VisualBasic.ERRID,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeListSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax},System.Boolean,System.Boolean)">
	<summary>
 Create a bad statement.  Report an error only if the statement doesn't have one already
 </summary>
	<param name="ErrorId"></param>
	<param name="attributes"></param>
	<param name="modifiers"></param>
	<param name="createMissingIdentifier">If set to true a new missing identifier will be created and added to the incomplete member.</param>
	<param name="forceErrorOnFirstToken">If set to true the error will be attached to the first skipped token of the incomplete member.</param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ParseCollectionInitializer">
	<summary>
  Parses a CollectionInitializer 
         CollectionInitializer -&gt; "{" CollectionInitializerList "}"
         CollectionInitializerList -&gt;  CollectionElement {"," CollectionElement}*
         CollectionElement -&gt; Expression | CollectionInitializer
 </summary>
	<returns>CollectionInitializerSyntax</returns>
	<remarks>In the grammar ArrayLiteralExpression is a rename of CollectionInitializer</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ParseObjectInitializerList(System.Boolean,System.Boolean)">
	<summary>
 Parses
 "With "{" FieldInitializerList "}"
 FieldInitializerList -&gt; FieldInitializer {"," FieldInitializer}*
 FieldInitializer -&gt; {Key? "." IdentifierOrKeyword "="}? Expression
 
  e.g.
  Dim x as new Customer With {.Id = 1, .Name = "A"}
 </summary>
	<returns>ObjectMemberInitializer</returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ParseObjectCollectionInitializer(Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax,Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxNode)">
	<summary>
   Parses an ObjectCollectionInitializer
         ObjectCollectionInitializer -&gt; "from" CollectionInitializer
 
 </summary>
	<returns>ObjectCollectionInitializer</returns>
	<remarks>In Dev10 this was called ParseInitializerList.  It also took several boolean parameters.  
  These were always set as 
       AllowExpressionInitializers = true
       AllowAssignmentInitializers = false
       AnonymousTypeInitializer = false
       RequireAtleastOneInitializer = false
 
  While the grammar uses the nonterminal CollectionInitializer is modeled as an
  AnnonymousArrayCreationExpression which has the identical syntax "{" Expression {"," Expression }* "}"
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ParseAssignmentInitializer(System.Boolean)">
	<summary>
 Parses a FieldInitializer
 
 FieldInitializer -&gt; ("key"? "." IdentifierOrKeyword "=")? Expression
 </summary>
	<param name="anonymousTypeInitializer">If true then allow the keyword "key" to prefix the field initializer</param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ParseTypeName(System.Boolean,System.Boolean@)">
	<summary>
 Parse and return a TypeName.  Assumes the CurrentToken is on the name.
 </summary>
	<param name="AllowEmptyGenericArguments">Controls generic argument parsing</param>
	<param name="AllowedEmptyGenericArguments">Controls generic argument parsing</param>
	<returns>TypeName</returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ParseParameter(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeListSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax})">
	<summary>
     Parameter -&gt; Attributes? ParameterModifiers* ParameterIdentifier ("as" TypeName)? ("=" ConstantExpression)?
 </summary>
	<param name="attributes"></param>
	<param name="modifiers"></param>
	<returns></returns>
	<remarks>&gt;This replaces both ParseParameter and ParseOptionalParameter in Dev10</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ParseCustomEventDefinition(Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.AttributeListSyntax},Roslyn.Compilers.VisualBasic.InternalSyntax.SyntaxList{Roslyn.Compilers.VisualBasic.InternalSyntax.KeywordSyntax})">
	<summary>
 Parse a CustomEventMemberDeclaration
 </summary>
	<param name="attributes"></param>
	<param name="modifiers"></param>
	<returns></returns>
	<remarks>This code used to be in ParseEventDefinition.</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.PeekToken(System.Int32)">
	<summary>
 Peeks in a stream of VB tokens.
 Note that the first token will be picked according to _allowLeadingMultilineTrivia
 The rest will be picked as regular VB as scanner does not always know what to do with
 line terminators and we assume that multiple token lookahead makes sense inside a single statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.GetNextToken(Roslyn.Compilers.VisualBasic.InternalSyntax.ScannerState)">
	<summary>
 Consumes current token and gets the next one with desired state.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.GetNextSyntaxNode">
	<summary>
 Consumes current node and gets next one. 
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ParseGetType">
	<summary>
 Parse GetType, 
 GetTypeExpression -&gt; GetType OpenParenthesis GetTypeTypeName CloseParenthesis 
 </summary>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ParseTypeOf">
	<summary>
 Parse TypeOf ... Is ... or TypeOf ... IsNot ...
 TypeOfExpression -&gt; "TypeOf" Expression "Is|IsNot" LineTerminator? TypeName
 </summary>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InternalSyntax.Parser.ParseCast">
	<summary>
 ParseCast parses CType, DirectCast, TryCast.
 CCCastExpression -&gt;   DirectCast ( CCExpression , TypeName ) 
                     | TryCast ( CCExpression , TypeName ) 
                     | CType ( CCExpression , TypeName ) 
                     { | CastTarget ( CCExpression ) }
 </summary>
	<returns>Cast</returns>
	<remarks>Dev10 ParseCType does not parse exact grammar in the spec, since dev10 accepts Epxression whereas the grammar uses CCExpression.
 This function only does not parse CastTarget ( ... ), it is parsed in ParseTerm
 </remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ParseOptions.PreprocessorSymbols">
	<summary>
 The preprocessor symbols to parse with.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.OptionStrict.Off">
	<summary>
 Option Strict is Off. No Option Strict checks are in effect.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.OptionStrict.Custom">
	<summary>
 The Option Strict checks generate warnings. (Note that other
 compile options may hide these warnings, or turn them into errors.)
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.OptionStrict.On">
	<summary>
 Option Strict is On. All Option Strict checks are in effect and produce errors.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.OptionStrict">
	<summary>
 Represents the state of Option Strict checking.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.WithExpressionRewriter.Result.Expression">
	<summary> Expression to be used instead of With statement expression placeholder </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.WithExpressionRewriter.Result.Locals">
	<summary> Locals being used </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.WithExpressionRewriter.Result.Initializers">
	<summary> Locals initialization expressions </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.WithExpressionRewriter.AnalyzeWithExpression(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.BoundExpression,System.Boolean,Roslyn.Compilers.VisualBasic.Binder,System.Boolean)">
	<summary>
 Given an expression specified for With statement produces:
   1) Expression - an expression to be used instead of expression placeholder
   2) Locals - a set of locals used to capture parts of Expression
   3) Initializers - initializers for Locals
 
 To be used in With statement only!
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.VBSemanticsRewriter.ReportMissingOrBadRuntimeHelper(Roslyn.Compilers.VisualBasic.BoundNode,Roslyn.Compilers.WellKnownMember,Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Checks for well known member and reports diagnostics if the member is Nothing or has UseSiteError.
 Returns True in case diagnostics was actually reported
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.VBSemanticsRewriter.ReportMissingOrBadRuntimeHelper(Roslyn.Compilers.VisualBasic.BoundNode,Roslyn.Compilers.SpecialMember,Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Checks for special member and reports diagnostics if the member is Nothing or has UseSiteError.
 Returns True in case diagnostics was actually reported
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.VBSemanticsRewriter.VisitAssignmentOperator(Roslyn.Compilers.VisualBasic.BoundAssignmentOperator)">
	<summary>
 Make sure GetObjectValue calls are injected.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.VBSemanticsRewriter.VisitCall(Roslyn.Compilers.VisualBasic.BoundCall)">
	<summary>
 Make sure GetObjectValue calls are injected.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.VBSemanticsRewriter.VisitObjectCreationExpression(Roslyn.Compilers.VisualBasic.BoundObjectCreationExpression)">
	<summary>
 Make sure GetObjectValue calls are injected.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.VBSemanticsRewriter.VisitAndGenerateObjectClone(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Visit expression node and apply GetObjectValue call if needed.
 
 Why we are doing this rewrite during this phase?
 It would be OK to do this rewrite during earlier phase, but not after this phase
 because:
   - This phase introduces various helper calls, which should not be affected by 
     GetObjectValue injection.
   - This is the last phase where we can see operators not yet replaced with helper calls, 
     this simplifies logic that determines if GetObjectValue call can be omitted.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.VBSemanticsRewriter.InitWithParameterlessValueTypeConstructor(Roslyn.Compilers.VisualBasic.BoundConversion,Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary> Given bound conversion node and the type the conversion is being done to initializes 
 bound conversion node with the reference to parameterless value type constructor and returns 
 modified bound node.
 In case the constructor is not accessible from current context, or there is no parameterless
 constructor found in the type (which should never happen, because in such cases a synthesized 
 constructor is supposed to be generated)
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.VBSemanticsRewriter">
	<summary>
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !!! Within this particular rewriter there is a contract:               !!!
 !!! newly produced nodes (this doesn't include nodes updated in place) !!!
 !!! should be in their final form, i.e. shouldn't require any other    !!!
 !!! rewrites handled by this rewriter.                                 !!!
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 
 Rewrites Decimal/Date constant expressions into 
 field references/constructor invocations.
 
 Rewrites VB intrinsic conversion into a helper call,
 if one is required. 
 
 Injects GetObjectValue calls for assignments and for arguments 
 passed to method calls. See VisitAndGenerateObjectClone for more information. 
 TODO: Note, that Dev10 compiler injects GetObjectValue during IL generation, which means that
 LINQ expression trees do not contain those calls.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.UseTwiceRewriter.UseTwice(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.TempLocalSymbol})">
	<summary>
 Given an expression that produces some result and 
 has some observable evaluation side effects, return two expressions:
   1) First - produces the same result with the same observable side effects,
   2) Second - produces the same result, but without observable side effects, whenever possible.
 
 This is used for compound assignment, method call ByRef parameter copy back, etc.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyntheticBoundNodeFactory">
	<summary> 
 A helper class for synthesizing quantities of code. 
 </summary>
	<remarks>
 Code if the #If False out is code ported from C# that isn't currently used, and
 hence has no code coverage. It may or may not work correctly, but should be a useful
 starting point.
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.SynthesizedSubmissionFields">
	<summary>
 Tracks synthesized fields that are needed in a submission being compiled.
 </summary>
	<remarks>
 For every other submission referenced by this submission we add a field, so that we can access members of the target submission.
 A field is also needed for the host object, if provided.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Rewriter.AfterLambdasRewrite(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.BoundNode,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Lambda bodies may be rewritten as methods or quoted as expression trees.
 There are certain reductions that are not supposed to be done if expression trees are
 generated. For example operators should be represented as operators in ETs and should 
 not be lowered to method calls.
 
 This step contains rewrites that are applicable only to bound trees with no lambdas
 Rewrite pass calls this for the outer method body after doing the lambda reduction pass.
 Lambda rewriter will also apply this rewrite to lambda bodies when they are 
 rewritten as synthetic methods.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.CreateTempLocal(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.BoundExpression})">
	<summary>
 Create a temp local of the given type and initial value.
 The resulting local is treated as an rvalue, and the
 initialization assignment is added to 'sideEffects'.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LocalRewriter._valueTypesCleanUpCache">
	<summary>
 Cache of value types which were already calculated by LocalOrFieldNeedsToBeCleanedUp 
 in this lowering, serves as an optimization 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.VisitUsingStatement(Roslyn.Compilers.VisualBasic.BoundUsingStatement)">
	<summary>
 A using statement of the form:
      using Expression
          list_of_statements
      end using

 will be rewritten into:

      temp = Expression
      Try
          list_of_statements
      Finally
          If Temp IsNot Nothing Then
              CType(temp, IDisposable).Dispose()
          End If
      End Try

 when the resource is a using locally declared variable no temporary is generated but the variable is read-only
 A using statement of the form:
      Using v As New MyDispose()
          list_of_statements
      End Using

 is rewritten to:
 
      Dim v As New MyDispose()
      Try
         list_of_statements
      Finally
          If v IsNot Nothing Then
              CType(v, IDisposable).Dispose()
          End If
      End Try

 A using with multiple variable resources are equivalent to a nested using statement.
 So a using statement of the form:
      Using v1 As New MyDispose(), v2 As myDispose = New MyDispose()
          list_of_statements
      end using

 is rewritten to:
      Dim v1 As New MyDispose
      Try
          Dim v2 As MyDispose = new MyDispose()
          Try
              list_of_statements
          Finally
              If v2 IsNot Nothing Then
                  CType(v2, IDisposable).Dispose()
              End If
          End Try
      Finally
          If v1 IsNot Nothing Then
              CType(v1, IDisposable).Dispose()
          End If
      end try
</summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.RewriteSingleUsingToTryFinally(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.LocalSymbol,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Utilities.ValueTuple{Roslyn.Compilers.VisualBasic.BoundRValuePlaceholder,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression}@,Roslyn.Compilers.VisualBasic.BoundBlock)">
	<summary>
 Creates a TryFinally Statement for the given resource.
 
 This method creates the following for the arguments:
      &lt;localSymbol&gt; = &lt;initializationExpression&gt;
      Try
         &lt;currentBody&gt;
      Finally
          If &lt;disposeCondition&gt; Then
              &lt;disposeConversion&gt;.Dispose()
          End If
      End Try
 
 Note: this is used for both kinds of using statements (resource locals and resource expressions).
 
 </summary>
	<returns>The new bound block containing the assignment of the initialization and the try/finally statement with
 the passed body.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.RewriteReturnStatement(Roslyn.Compilers.VisualBasic.BoundReturnStatement)">
	<summary>
 Rewrites Return as a GoTo is needed (if not the last statement in a method)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.RewriteCollectionInitializerExpression(Roslyn.Compilers.VisualBasic.BoundCollectionInitializerExpression,Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Rewrites a CollectionInitializerExpression to a list of Add calls and returns the temporary.
 E.g. the following code:
     Dim x As New CollectionType(param1) From {1, {2, 3}, {4, {5, 6, 7}}}
 gets rewritten to 
     Dim temp as CollectionType 
     temp = new CollectionType(param1)
     temp.Add(1)
     temp.Add(2, 3)
     temp.Add(4, {5, 6, 7})
     x = temp
 where the last assignment is not part of this rewriting, because the BoundCollectionInitializerExpression
 only represents the object creation expression with the initialization.
 </summary>
	<param name="node">The BoundCollectionInitializerExpression that should be rewritten.</param>
	<returns>A bound sequence for the object creation expression containing the invocation expressions.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.RewriteObjectInitializerExpression(Roslyn.Compilers.VisualBasic.BoundObjectInitializerExpression,Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Rewrites a ObjectInitializerExpression to either a statement list (in case the there is no temporary used) or a bound
 sequence expression (in case there is a temporary used). The information whether to use a temporary or not is 
 stored in the bound object member initializer node itself.
 
 E.g. the following code:
     Dim x = New RefTypeName(param1) With {.FieldName1 = 23, .FieldName2 = .FieldName3, .FieldName4 = x.FieldName1}
 gets rewritten to 
     Dim temp as RefTypeName 
     temp = new RefTypeName(param1)
     temp.FieldName1 = 23
     temp.FieldName2 = temp.FieldName3
     temp.FieldName4 = x.FieldName1
     x = temp
 where the last assignment is not part of this rewriting, because the BoundObjectInitializerExpression
 only represents the object creation expression with the initialization.
 
 In a case where no temporary is used the following code:
     Dim x As New ValueTypeName(param1) With {.FieldName1 = 23, .FieldName2 = .FieldName3, .FieldName4 = x.FieldName1}
 gets rewritten to 
     x = new ValueTypeName(param1)
     x.FieldName1 = 23
     x.FieldName2 = x.FieldName3
     x.FieldName4 = x.FieldName1
 </summary>
	<param name="node">The BoundObjectInitializerExpression that should be rewritten.</param>
	<returns>A bound sequence for the object creation expression containing the invocation expressions, or a 
 bound statement list if no temporary should be used.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.ProcessNullableOperand(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.LocalSymbol}@,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.BoundExpression}@,System.Boolean)">
	<summary>
 Splits nullable operand into a hasValueExpression and an expression that represents underlying value (returned).
 
 Underlying value can be called after calling hasValueExpr without duplicated sideeffects.
 Note that hasValueExpr is guaranteed to have NO SIDEEFFECTS, while result value is 
 expected to be called exactly ONCE. That is the normal pattern in operator lifting.
 
 All necessary temps and sideeffecting initializations are appended to temps and inits
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.CaptureNullableIfNeeded(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TempLocalSymbol@,Roslyn.Compilers.VisualBasic.BoundExpression@,System.Boolean)">
	<summary>
 Returns a NOT-SIDEEFFECTING expression that represents results of the operand
 If such transformation requires a temp, the temp and its initialising expression
 are returned in temp/init
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.NullableValueOrDefault(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Returns expression that -
 a) evaluates the operand if needed
 b) produces it's ValueOrDefault.
 The helper is familiar with wrapping expressions and will go directly after the value 
 skipping wrap/unwrap steps.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.NullableHasValue(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Evaluates expr and calls HasValue on it.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.NullableNull(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Checks that candidate Null expression is a simples expression that produces Null of the desired type
 (not a conversion or anything like that) and returns it.
 Otherwise creates "New T?()" expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.HasNoValue(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 returns true when expression has NO SIDEEFFECTS and is known to produce nullable NULL
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.HasValue(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Returns true when expression is known to produce nullable NOT-NULL
 NOTE: unlike HasNoValue case, HasValue expressions may have sideeffects.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.MakeBinaryExpression(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.BinaryOperatorKind,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression,System.Boolean,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Helper to generate binary expressions.
 Performs some trivial constant folding.
 TODO: Perhaps belong to a different file
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.MakeBooleanBinaryExpression(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.BinaryOperatorKind,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Simpler helper for binary expressions.
 When operand are boolean, the result type is same as operand's and is never checked 
 so do not need to pass that in.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.MakeSequence(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Takes two expressions and makes sequence.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.MakeSequence(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Takes two expressions and makes sequence.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.MakeTernaryConditionalExpression(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Takes two expressions and makes sequence.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.GetSideeffects(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Returns an expression that can be used instead of the original one when
 we want to run the expression for sideeffects only (i.e. we intend to ignore result).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.RewriteLocalDeclarationAsInitializer(Roslyn.Compilers.VisualBasic.BoundLocalDeclaration,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean)">
	<summary>
 Replaces local declaration with its initializer
 Also marks resulting statement with seq point that matches original declaration.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.VisitForToStatement(Roslyn.Compilers.VisualBasic.BoundForToStatement)">
	<summary>
 Rewrites ForTo loop.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.NegateIfStepNegative(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Negates the value if step is negative
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.RewriteForLoopCondition(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundForToUserDefinedOperators,Roslyn.Compilers.VisualBasic.TempLocalSymbol)">
	<summary>
 Given the control variable, limit and step, produce the loop condition.
 The principle is simple - 
       if step is negative (stepping "Up") then it is "control &gt;= limit"
       otherwise it is "control &lt;= limit"
 
 It gets more complicated when step is not a constant or not a numeric or 
 involves overloaded comparison/IsTrue operators
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.CacheToTempIfNotConst(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.LocalSymbol},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.BoundExpression})">
	<summary>
 If value is const, returns the value unchanged.
 
 In a case if value is not a const, a proxy temp is created and added to "locals"
 In addition to that, code that evaluates and stores the value is added to "expressions"
 The access expression to the proxy temp is returned.
 
 Purpose:
 Limit and Step are supposed to be captured for the duration of the loop.
 To ensure that behavior non-constant values are hoisted into temps before entering the loop
 which avoids re-fetching potentially changed values.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.VisitForEachStatement(Roslyn.Compilers.VisualBasic.BoundForEachStatement)">
	<summary>
 Rewrites a for each statement.
 </summary>
	<param name="node">The node.</param><returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.RewriteForEachArrayOrString(Roslyn.Compilers.VisualBasic.BoundForEachStatement,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.BoundStatement},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.LocalSymbol},System.Boolean,Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Rewrites a for each over an one dimensional array or a string.
 
 As an optimization, if c is an array type of rank 1, the form becomes:

     Dim collectionCopy As C = c
     Dim collectionIndex As Integer = 0
     Do While collectionIndex &lt; len(collectionCopy)    ' len(a) represents the LDLEN opcode
         dim controlVariable = DirectCast(collectionCopy(collectionIndex), typeOfControlVariable)
         &lt;loop body&gt;
     continue:
         collectionIndex += 1
     postIncrement:
     Loop

 An iteration over a string becomes
     Dim collectionCopy As String = c
     Dim collectionIndex As Integer = 0
     Dim limit as Integer = s.Length
     Do While collectionIndex &lt; limit
         dim controlVariable = DirectCast(collectionCopy.Chars(collectionIndex), typeOfControlVariable)
         &lt;loop body&gt;
     continue:
         collectionIndex += 1
     postIncrement:
     Loop
 </summary>
	<param name="node">The node.</param>
	<param name="statements">The statements.</param>
	<param name="locals">The locals.</param>
	<param name="isArray">if set to <c>true</c> [is array].</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.CreateLocalAndAssignment(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundLocal@,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.LocalSymbol})">
	<summary>
 Creates the a local and assigns it the given bound expression.
 </summary>
	<param name="syntaxNode">The syntax node.</param>
	<param name="initExpression">The initialization expression.</param>
	<param name="boundLocal">The bound local.</param>
	<param name="locals">The locals.</param><returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.CreateIndexIncrement(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.BoundLocal)">
	<summary>
 Creates the index increment statement.
 </summary>
	<param name="syntaxNode">The syntax node.</param>
	<param name="boundIndex">The bound index expression (bound local).</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.CreateLoweredWhileStatements(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.BoundForEachStatement,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundLocal,Roslyn.Compilers.VisualBasic.BoundStatement,Roslyn.Compilers.VisualBasic.BoundStatement)">
	<summary>
 Creates the while statement for the for each rewrite
 </summary>
	<param name="syntaxNode">The syntax node.</param>
	<param name="limit">The limit to check the index against.</param>
	<param name="index">The index.</param>
	<param name="currentAssignment">The assignment statement of the current value.</param>
	<param name="incrementAssignment">The increment statement.</param>
	<param name="node">The bound for each node.</param>
	<returns>The lowered statement list for the while statement.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.RewriteForEachIEnumerable(Roslyn.Compilers.VisualBasic.BoundForEachStatement,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.BoundStatement},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.LocalSymbol})">
	<summary>
 Rewrite a for each that uses IEnumerable. It's basic form is:

     Dim e As E = c.GetEnumerator()
     Do While e.MoveNext()
        controlVariable = e.Current
        &lt;loop body&gt;
     Loop

 To support disposable enumerators, the compiler will generate code to dispose the
 enumerator after loop termination.  Only when E implements IDisposable can this be done.
 The one exception to this rule is when E is specifically IEnumerator, in which case
 the compiler will generate code to dynamically query the enumerator to determine
 if it implements IDisposable.

 If E is IEnumerator the loop becomes:

     Dim e As IEnumerator = c.GetEnumerator()
     Try
         Do While e.MoveNext()
            dim controlVariable = e.Current
            &lt;loop body&gt;
         Loop
     Finally
         If TryCast(e, IDisposable) IsNot Nothing then
             CType(e, IDisposable).Dispose()
         End If
     End Try

 If E is known at compile time to implement IDisposable the loop becomes:

     Dim e As E = c.GetEnumerator()
     Try
         Do While e.MoveNext()
            dim controlVariable = e.Current
            &lt;loop body&gt;
         Loop
     Finally
         If Not e Is Nothing Then
             CType(e, IDisposable).Dispose()
         End If
     End Try

 The exception to these forms is the existence of On Error in which case the Try/Finally
 block will be eliminated (instead the body of the Finally will immediately follow
 the end of the loop).
 </summary>
	<param name="node"></param>
	<param name="statements"></param>
	<param name="locals"></param>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.GenerateDisposeCallForForeachAndUsing(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression,System.Boolean,System.Boolean,Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Depending on whether the bound local's type is, implements or inherits IDisposable for sure, or might implement it,
 this function returns the statements to call Dispose on the bound local.
 
 If it's known to implement IDisposable, the generated code looks like this for reference types:
     If e IsNot Nothing Then
       CType(e, IDisposable).Dispose()
     End If
 or
 e.Dispose()
 for value types (including type parameters with a value constraint).
 Otherwise it looks like the following
     If TryCast(e, IDisposable) IsNot Nothing then
       CType(e, IDisposable).Dispose()
     End If
 </summary>
	<remarks>This method is used by the for each rewriter and the using rewriter. The latter should only call 
 this method with both IsOrInheritsFromOrImplementsIDisposable and needToDispose set to true, as using is not
 pattern based and must implement IDisposable.
 </remarks>
	<param name="syntaxNode">The syntax node.</param>
	<param name="boundLocal">The bound local.</param>
	<param name="boundCondition">The condition used in the if statement around the dispose call</param>
	<param name="needToDispose">A flag indicating whether calling IDisposable.Dispose() is needed or not.</param>
	<param name="IsOrInheritsFromOrImplementsIDisposable">A flag indicating whether the bound local's type is,
 inherits or implements IDisposable or not.</param>
	<param name="disposeConversion">Conversion from the local type to IDisposable</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.LocalRewriter.LocalVariableSubstitutor">
	<summary>
 Internal helper class to replace local symbols in bound locals of a given bound tree.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.VisitFieldOrPropertyInitializer(Roslyn.Compilers.VisualBasic.BoundFieldOrPropertyInitializer)">
	<summary>
 Field initializers need to be rewritten multiple times in case of an AsNew declaration with multiple field names because the 
 initializer may contain references to the current field like in the following example:
 Class C1
     Public x, y As New RefType() With {.Field1 = .Field2}
 End Class 
 
 in this example .Field2 references the temp that is created for x and y.
 
 We moved the final rewriting for field initializers to the local 
 rewriters because here we already have the infrastructure to replace placeholders. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.LocalRewriter.PlaceholderReplacement(Roslyn.Compilers.VisualBasic.BoundValuePlaceholderBase)">
	<summary>
 Returns substitution currently used by the rewriter for a placeholder node.
 Each occurance of the placeholder node is replaced with the node returned.
 Throws if there is no substitution.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.AddPlaceholderReplacement(Roslyn.Compilers.VisualBasic.BoundValuePlaceholderBase,Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Sets substitution used by the rewriter for a placeholder node.
 Each occurance of the placeholder node is replaced with the node returned.
 Throws if there is already a substitution.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.UpdatePlaceholderReplacement(Roslyn.Compilers.VisualBasic.BoundValuePlaceholderBase,Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Replaces substitution currently used by the rewriter for a placeholder node with a different substitution.
 Asserts if there isn't already a substitution.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.RemovePlaceholderReplacement(Roslyn.Compilers.VisualBasic.BoundValuePlaceholderBase)">
	<summary>
 Removes substitution currently used by the rewriter for a placeholder node.
 Asserts if there isn't already a substitution.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.GetSpecialType(Roslyn.Compilers.SpecialType)">
	<summary>
 Gets the special type.
 </summary>
	<param name="specialType">Special Type to get.</param><returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.GetSpecialTypeMember(Roslyn.Compilers.SpecialMember)">
	<summary>
 Gets the special type member.
 </summary>
	<param name="specialMember">Member of the special type.</param><returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.CacheToTempIfNotConst(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.LocalSymbol},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.BoundExpression})">
	<summary>
 If value is const, returns the value unchanged.
 
 In a case if value is not a const, a proxy temp is created and added to "locals"
 In addition to that, code that evaluates and stores the value is added to "expressions"
 The access expression to the proxy temp is returned.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.GenerateSequenceValueSideEffects(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.LocalSymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression})">
	<summary>
 Helper method to create a bound sequence to represent the idea:
 "compute this value, and then compute this side effects while discarding results"

 A Bound sequence is generated for the the provided expr and sideeffects, say {se1, se2, se3}, as follows:

 If expr is of void type:
     BoundSequence { sideeffects: { expr, se1, se2, se3 }, valueOpt: Nothing }
 
 ElseIf expr is a constant:
     BoundSequence { sideeffects: { se1, se2, se3 }, valueOpt: expr }
 
 Else
     BoundSequence { sideeffects: { tmp = expr, se1, se2, se3 }, valueOpt: tmp }
 </summary>
	<remarks>
 NOTE: Supporting cases where sideeffects change the value (or to detects such cases)
 NOTE: could be complicated. We do not support this currently and instead require
 NOTE: value expr to be not LValue.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalRewriter.VisitExpressionNode(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Helper function that visits the given expression and returns a BoundExpression.
 Please use this instead of DirectCast(Visit(expression), BoundExpression)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.Rewrite(Roslyn.Compilers.VisualBasic.BoundBlock,Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.Emit.Module,Roslyn.Compilers.VisualBasic.TypeCompilationState,System.Collections.Generic.ISet{Roslyn.Compilers.VisualBasic.Symbol},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Rewrite the given node to eliminate lambda expressions.  Also returned are the method symbols and their
 bound bodies for the extracted lambda bodies. These would typically be emitted by the caller such as
 MethodBodyCompiler.  See this class' documentation
 for a more thorough explanation of the algorithm and its use by clients.
 </summary>
	<param name="node">The bound node to be rewritten</param>
	<param name="method">The containing method of the node to be rewritten</param>
	<param name="emitModule">The emit module in which compiler-generated symbols are to be placed</param>
	<param name="compilationState">The caller's buffer into which we produce additional methods to be emitted by the caller</param>
	<param name="symbolsCapturedWithoutCopyCtor">Set of symbols that should not be captured using a copy constructor</param>
	<param name="diagnostics">The caller's buffer into which we place any diagnostics for problems encountered</param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.MakeFrames">
	<summary>
 Create the frame types.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.FrameOfType(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Produces a bound expression representing a pointer to a frame of a particular frame type.
 </summary>
	<param name="syntax">The syntax to attach to the bound nodes produced</param>
	<param name="frameType">The type of frame to be returned</param>
	<returns>A bound node that computes the pointer to the required frame</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.FramePointer(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Produce a bound expression representing a pointer to a frame of a particular frame class.
 Note that for generic frames, the frameClass parameter is the generic definition, but
 the resulting expression will be constructed with the current type parameters.
 </summary>
	<param name="syntax">The syntax to attach to the bound nodes produced</param>
	<param name="frameClass">The class type of frame to be returned</param>
	<returns>A bound node that computes the pointer to the required frame</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.ConstructFrameType``1(Roslyn.Compilers.VisualBasic.LambdaRewriter.Frame,Roslyn.Compilers.ReadOnlyArray{``0})">
	<summary>
 Constructs a concrete frame type if needed.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.IntroduceFrame(Roslyn.Compilers.VisualBasic.BoundNode,Roslyn.Compilers.VisualBasic.LambdaRewriter.Frame,System.Func{Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.LocalSymbol},Roslyn.Compilers.VisualBasic.BoundNode},Roslyn.Compilers.VisualBasic.LambdaSymbol)">
	<summary>
 Introduce a frame around the translation of the given node.
 </summary>
	<param name="node">The node whose translation should be translated to contain a frame</param>
	<param name="frame">The frame for the translated node</param>
	<param name="F">A function that computes the translation of the node.  It receives lists of added statements and added symbols</param>
	<returns>The translated statement, as returned from F</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.InitParameterProxy(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.ParameterSymbol,Roslyn.Compilers.VisualBasic.LocalSymbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.BoundExpression})">
	<summary>
 If parameter is lifted, initializes its proxy
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.BlockDepth(Roslyn.Compilers.VisualBasic.BoundNode)">
	<summary>
 Compute the nesting depth of a given block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.RewriteMethodSymbol(Roslyn.Compilers.VisualBasic.MethodSymbol)">
	<summary>
 Rewrites method.
 TODO: consider making this more general VisitMethod like VisitType above.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.RewriteLambdaAsMethod(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.BoundLambda)">
	<summary>
 Rewrites lambda body into a body of a method.
 </summary>
	<param name="method">Method symbol for the rewritten lambda body.</param>
	<param name="lambda">Original lambda node.</param>
	<returns>Lambda body rewritten as a body of the given method symbol.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.IsLegalBranch(Roslyn.Compilers.VisualBasic.BoundNode,Roslyn.Compilers.VisualBasic.BoundNode)">
	<summary>
 It is illegal to jump into blocks that reference lifted variable
 as that could leave closure frames of the target block uninitialized.
 
 The fact that closure could be created as high as the declaration level of the variable
 and well above goto block (thus making the jump safe) is considered an optional optimization 
 and ignored. 
 For the purpose of this analysis just having lifting lambdas already means 
 that block may require initialization and cannot be jumped into.
 
 Note that when you are jumping into a block you are essentially jumping into ALL blocks
 on the path from LowestCommonAncestor(goto, label) to the actual label block.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaRewriter">
	<summary>
 The rewriter for removing lambda expressions from method bodies and introducing closure classes
 as containers for captured variables along the lines of the example in section 6.5.3 of the
 C# language specification.
 
 The entry point is the public method Rewrite.  It operates as follows:
 
 First, an analysis of the whole method body is performed that determines which variables are
 captured, what their scopes are, and what the nesting relationship is between scopes that
 have captured variables.  The result of this analysis is left in LambdaRewriter.analysis.
 
 Then we make frame, or compiler-generated class, represented by an instance of
 LambdaRewriter.Frame for each scope with captured variables.  The generated frames are kept
 in LambdaRewriter.frames.  Each frame is given a single field for each captured
 variable in the corresponding scope.  These are are maintained in LambdaRewriter.proxies.
 
 Finally, we walk and rewrite the input bound tree, keeping track of the following:
 (1) The current set of active frame pointers, in LambdaRewriter.framePointers
 (2) The current method being processed (this changes within a lambda's body), in LambdaRewriter.currentMethod
 (3) The "this" symbol for the current method in LambdaRewriter.currentFrameThis, and
 (4) The symbol that is used to access the innermost frame pointer (it could be a local variable or "this" parameter)
 
 There are a few key transformations done in the rewriting.
 (1) Lambda expressions are turned into delegate creation expressions, and the body of the lambda is
     moved into a new, compiler-generated method of a selected frame class.
 (2) On entry to a scope with captured variables, we create a frame object and store it in a local variable.
 (3) References to captured variables are transformed into references to fields of a frame class.
 
 In addition, the rewriting deposits into the field LambdaRewriter.generatedMethods a (MethodSymbol, BoundStatement)
 pair for each generated method.
 
 LambdaRewriter.Rewrite produces its output in two forms.  First, it returns a new bound statement
 for the caller to use for the body of the original method.  Second, it returns a collection of
 (MethodSymbol, BoundStatement) pairs for additional method that the lambda rewriter produced.
 These additional methods contain the bodies of the lambdas moved into ordinary methods of their
 respective frame classes, and the caller is responsible for processing them just as it does with
 the returned bound node.  For example, the caller will typically perform iterator method and
 asynchronous method transformations, and emit IL instructions into an assembly.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.SynthesizedWrapperMethod.#ctor(Roslyn.Compilers.VisualBasic.Compilation,Roslyn.Compilers.VisualBasic.InstanceTypeSymbol,Roslyn.Compilers.VisualBasic.MethodSymbol,System.String,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Creates a symbol for a synthesized lambda method.
 </summary>
	<param name="containingType">Type that contains wrapper method.</param>
	<param name="methodToWrap">Method to wrap</param>
	<param name="wrapperName">Wrapper method name</param>
	<param name="syntax">Syntax node.</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaRewriter.SynthesizedWrapperMethod">
	<summary>
 A method that wraps the call to a method through MyBase/MyClass receiver.
 </summary>
	<remarks>
		<example>
 Class A
     Protected Overridable Sub F(a As Integer)
     End Sub
 End Class
 
 Class B
     Inherits A
 
     Public Sub M()
         Dim b As Integer = 1
         Dim f As System.Action = Sub() MyBase.F(b)
     End Sub
 End Class
 </example>
	</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.Frame.#ctor(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.MethodSymbol,System.Boolean,System.Int32)">
	<summary>
 Creates a Frame definition
 </summary>
	<param name="containingType">Type that contains Frame type.</param>
	<param name="enclosingMethod">Method that contains lambda expression for which we do the rewrite.</param>
	<param name="copyConstructor">Specifies whether the Frame needs a copy-constructor.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.Frame.GenerateAllDeclarationErrors(System.Threading.CancellationToken)">
	<summary>
 Force all declaration errors to be generated.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaRewriter.Frame">
	<summary>
 A class that represents the set of variables in a scope that have been
 captured by lambdas within that scope.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaRewriter.CapturedVariable">
	<summary>
 A field of a frame class that represents a variable that has been captured in a lambda.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaRewriter.FrameReference">
	<summary>
 A local variable used to store a reference to the frame objects in which captured
 local variables have become fields.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaRewriter.SynthesizedLambdaCopyConstructor">
	<summary>
 Copy constructor has one parameter of the same type as the enclosing type.
 The purpose is to copy all the lifted values from previous version of the 
 frame if there was any into the new one.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.SynthesizedLambdaMethod.#ctor(Roslyn.Compilers.VisualBasic.InstanceTypeSymbol,Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.VisualBasic.BoundLambda,System.Boolean,System.Int32)">
	<summary>
 Creates a symbol for a synthesized lambda method
 </summary>
	<param name="containingType">Type that contains lambda method 
 - it is either Frame or enclosing class in a case if we do not lift anything.</param>
	<param name="enclosingMethod">Method that contains lambda expression for which we do the rewrite.</param>
	<param name="syntaxTree">Syntax tree. Used for diagnostics.</param>
	<param name="lambdaNode">Lambda expression which is represented by this method.</param>
	<param name="isShared">Specifies whether lambda method should be shared.</param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.SynthesizedLambdaMethod.WithNewContainerAndType(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.ParameterSymbol)">
	<summary>
 Creates a clone of the local with a new containing symbol and type.
 Note that the new parameter gets no syntaxRef as it is supposed to get 
 all the values it needs from the original parameter.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaRewriter.SynthesizedLambdaMethod">
	<summary>
 A method that results from the translation of a single lambda expression.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaRewriter.SynthesizedMethod">
	<summary>
 Base for synthesised Lambda methods. 
 Just provides a bunch of defaults
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaRewriter.MappedTypeParameterSymbol">
	<summary>
 Type parameter that represents another type parameter 
 while being applied on a different symbol
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.seenLambda">
	<summary>
 Set to true of any lambda expressions were seen in the analyzed method body.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.seenBackBranches">
	<summary>
 Set to true if method body contains any back branches (loops).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.blockParent">
	<summary>
 For each statement with captured variables, identifies the nearest enclosing statement with captured variables.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.variableBlock">
	<summary>
 For each captured variable, identifies the statement in which it will be moved to a frame class.  This is
 normally the block where the variable is introduced, but method parameters are moved
 to a frame class within the body of the method.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.labelBlock">
	<summary>
 For a given label, the nearest enclosing block that captures variables
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.gotoBlock">
	<summary>
 For a given goto, the nearest enclosing block that captures variables
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.containsLiftingLambda">
	<summary>
 Blocks that contain (recursively) a lambda that is lifting. 
 Such blocks are considered as potentially needing closure initialization when doing jump verification.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.needsParentFrame">
	<summary>
 Blocks that are positioned between a block declaring some lifted variables
 and a block that contains the lambda that lifts said variables.
 If such block itself requires a closure, then it must lift parent frame pointer into the closure
 in addition to whatever else needs to be lifted.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.captured">
	<summary>
 The set of captured variables seen in the method body.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.captures">
	<summary>
 For each lambda in the code, the set of variables that it captures.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.symbolsCapturedWithoutCopyCtor">
	<summary>
 All symbols that should never be captured with a copy constructor of a closure.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.AnalyzeMethodBody(Roslyn.Compilers.VisualBasic.BoundBlock,Roslyn.Compilers.VisualBasic.MethodSymbol,System.Collections.Generic.ISet{Roslyn.Compilers.VisualBasic.Symbol},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Analyses method body that belongs to the given method symbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.RecordCaptureInIntermediateBlocks(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Once we see a lambda lifting something
 We mark all blocks from the current up to the one that declares lifted symbol as
 containing a lifting lambda.
 This is needed so that we could reject jumps that might jump over frame allocations.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.ReferenceVariable(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 This method is called on every variable reference.
 It checks for cases where variable is declared outside of the lambda in which it is being accessed
 If capture is detected, than it marks variable as capturED and all lambdas involved as capturING
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis.MayParticipateInIllegalBranch(Roslyn.Compilers.VisualBasic.BoundGotoStatement)">
	<summary>
 For performance reason we may not want to check if synthetic gotos are legal.
 Those are the majority, but should not be ever illegal (how user would fix them?).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaRewriter.Analysis">
	<summary>
 Perform a first analysis pass in preparation for removing all lambdas from a method body.  The entry point is Analyze.
 The results of analysis are placed in the fields seenLambda, blockParent, variableBlock, captured, and captures.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExpressionLambdaRewriter.RewriteLambda(Roslyn.Compilers.VisualBasic.BoundLambda,Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.TypeCompilationState,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Rewrite a bound lambda into a bound node that will create the corresponding expression tree at run time.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExpressionLambdaRewriter.ExprFactory(System.String,Roslyn.Compilers.VisualBasic.BoundExpression[])">
	<summary>
 Create an Expression node with the given name and arguments.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExpressionLambdaRewriter.ExprFactory(System.String,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol},Roslyn.Compilers.VisualBasic.BoundExpression[])">
	<summary>
 Create an Expression node with the given name, type arguments, and arguments.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ExpressionLambdaRewriter">
	<summary>
 Rewrite lambda that are being converted to LINQ expression trees (Expresssion(Of T))
 </summary>
	<remarks>
 A lot of code is #If False disabled until it can be tested. 
 </remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.SpeculativeLocation">
	<summary>
 A program location in speculative bound code. Right now, speculatively bound code
 doesn't have a syntax tree associated with it. This probably will change in the future, but
 for now this works.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceLocation">
	<summary>
 A program location in source code.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.NoLocation">
	<summary>
 A class that represents no location at all. Useful for errors in command line options, for example.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MetadataLocation">
	<summary>
 A program location in metadata.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Location">
	<summary>
 Represents a VB location in source code or metadata.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.EmbeddedTreeLocation">
	<summary>
 A program location in source code.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.GlobalImport.Clause">
	<summary>
 The import clause (a namespace name, an alias, or an XML namespace alias).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LocalizableErrorArgument">
	<summary>
 Message IDs may refer to strings that need to be localized.
 This struct makes an IFormattable wrapper around a MessageID
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.CompoundDiagnosticInfo">
	<summary>
 Concatenates messages for a set of DiagnosticInfo.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DiagnosticBagExtensions.SealDiagnostics(Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Get all the diagnostics in the diagnostic bag, as an enumerable of Diagnostic. DiagnosticBag
 implements IEnumerable&lt;CommonDiagnostic&gt; instead of IEnumerable&lt;Diagnostic&gt;.
 </summary>
	<param name="diagBag"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.DiagnosticBagExtensions.GetDiagnostics(Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Get all the diagnostics in the diagnostic bag, as an enumerable of Diagnostic. DiagnosticBag
 implements IEnumerable&lt;CommonDiagnostic&gt; instead of IEnumerable&lt;Diagnostic&gt;.
 </summary>
	<param name="diagBag"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.DiagnosticBagExtensions.Add(Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.ERRID,Roslyn.Compilers.VisualBasic.Location,System.Object[])">
	<summary>
 Add a diagnostic to the bag.
 </summary>
	<param name="diagnostics"></param>
	<param name="code"></param>
	<param name="location"></param>
	<param name="args"></param>
	<returns></returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.BadSymbolDiagnostic">
	<summary>
 This diagnostic indicates when a symbol is not good for binding against.
 
 Client code can obtain the bad symbol via the BadSymbol property.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AmbiguousSymbolDiagnostic">
	<summary>
 This diagnostics indicates when a lookup is ambiguous between multiple
 equally good symbols, for example in different imported namespaces, or different
 modules.
 
 Client code can obtain the set of ambiguous symbols via the AmbiguousSymbols property.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Emit.Module._addedEmbeddedSymbols">
	<summary> Stores collection of all embedded symbols referenced from IL </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Emit.Module.ProcessReferencedSymbol(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary> Adds a symbol to the collection of referenced embedded symbols </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Emit.Module.GetCompilerGeneratedTypes(Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Returns null if there are no compiler generated types.
 </summary>
	<param name="container"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Emit.Module.AddCompilerGeneratedPrivateImplMethod(Microsoft.Cci.IMethodDefinition)">
	<summary>
 Adds compiler generated method to PrivateImplementationDetails class
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Emit.Module.GetCompilerGeneratedMethods(Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Returns null if there are no compiler generated methods.
 </summary>
	<param name="container"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Emit.Module.GetCompilerGeneratedProperties(Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Returns null if there are no compiler generated properties.
 </summary>
	<param name="container"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Emit.Module.GetCompilerGeneratedFields(Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Returns null if there are no compiler generated fields.
 </summary>
	<param name="container"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.IsDefinitionOrDistinct">
	<summary>
 Return whether the symbol is either the original definition
 or distinct from the original. Intended for use in Debug.Assert
 only since it may include a deep comparison.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.GetCustomAttributesToEmit(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.AttributeData},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.SynthesizedAttributeData},System.Boolean)">
	<summary> 
 Returns a list of attributes to emit to CustomAttribute table.
  </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Symbol.CheckDefinitionInvariant">
	<summary>
 Checks if this symbol is a definition and its containing module is a SourceModuleSymbol.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Emit.SpecializedNestedTypeReference">
	<summary>
 Represents a reference to a type nested in an instantiation of a generic type.
 e.g. 
 A{int}.B
 A.B{int}.C.D
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Emit.SpecializedMethodReference">
	<summary>
 Represents a method of a generic type instantiation.
 e.g. 
 A{int}.M()
 A.B{int}.C.M()
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Emit.SpecializedGenericNestedTypeInstanceReference">
	<summary>
 Represents a reference to an instantiation of a generic type nested in an instantiation of another generic type.
 e.g. 
 A{int}.B{string}
 A.B{int}.C.D{string}
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Emit.SpecializedGenericMethodInstanceReference">
	<summary>
 Represents a generic method of a generic type instantiation, closed over type parameters.
 e.g. 
 A{T}.M{S}()
 A.B{T}.C.M{S}()
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Emit.SpecializedFieldReference">
	<summary>
 Represents a reference to a field of a generic type instantiation.
 e.g.
 A{int}.Field
 A{int}.B{string}.C.Field
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeSymbol.GetSynthesizedImplements">
	<summary>
 Should return Nothing if there are none.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Emit.Module.m_MetadataName">
	<summary>
 This value will override m_SourceModule.MetadataName.
 </summary>
	<remarks>
 This functionality exists for parity with C#, which requires it for
 legacy reasons (see Roslyn.Compilers.CSharp.Emit.Assembly.metadataName).
 </remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Emit.Module.m_assemblySymbolMapper">
	<summary>
 Used to translate assembly symbols to assembly references in scenarios when the physical assemblies 
 being emitted don't correspond to the assembly symbols 1:1. This happens, for example, in interactive sessions where
 multiple code submissions might be compiled into a single dynamic assembly or into multiple assemblies 
 depending on properties of the code being emitted. If null we map assembly symbol exactly to its assembly name.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Emit.Module.CompilerGeneratedDefinitions">
	<summary>
 Captures the set of compiler generated definitions that should be added to a type
 during emit process.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Emit.GenericTypeInstanceReference">
	<summary>
 Represents a reference to a generic type instantiation.
 Subclasses represent nested and namespace types.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Emit.GenericNestedTypeInstanceReference">
	<summary>
 Represents a reference to a generic type instantiation that is nested in a non-generic type.
 e.g. A.B{int}
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Emit.GenericNamespaceTypeInstanceReference">
	<summary>
 Represents a reference to a generic type instantiation that is not nested.
 e.g. MyNamespace.A{int}
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Emit.GenericMethodInstanceReference">
	<summary>
 Represents a reference to a generic method instantiation, closed over type parameters, 
 e.g. MyNamespace.Class.Method{T}()
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Emit.Assembly.m_MetadataName">
	<summary>
 This value will override m_SourceModule.MetadataName.
 </summary>
	<remarks>
 This functionality exists for parity with C#, which requires it for
 legacy reasons (see Roslyn.Compilers.CSharp.Emit.Assembly.metadataName).
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SingleNamespaceOrTypeDeclaration.BestName``1(Roslyn.Compilers.ReadOnlyArray{``0},System.Boolean@)">
	<summary>
 This function is used to determine the best name of a type or namespace when there are multiple declarations that
 have the same name but with different spellings.
 If this declaration is part of the rootnamespace (specified by /rootnamespace:&lt;nsname&gt; this is considered the best name.
 Otherwise the best name of a type or namespace is the one that String.Compare considers to be less using a Ordinal.
 In practice this prefers uppercased or camelcased identifiers.
 </summary>
	<typeparam name="T"></typeparam>
	<param name="singleDeclarations">The single declarations.</param>
	<param name="multipleSpellings">Set to true if there were multiple distinct spellings.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SingleNamespaceDeclaration.BestName``1(Roslyn.Compilers.ReadOnlyArray{``0},System.Boolean@)">
	<summary>
 This function is used to determine the best name of a type or namespace when there are multiple declarations that
 have the same name but with different spellings.
 If this declaration is part of the rootnamespace (specified by /rootnamespace:&lt;nsname&gt; this is considered the best name.
 Otherwise the best name of a type or namespace is the one that String.Compare considers to be less using a Ordinal.
 In practice this prefers uppercased or camelcased identifiers.
 </summary>
	<typeparam name="T"></typeparam>
	<param name="singleDeclarations">The single declarations.</param>
	<param name="multipleSpellings">Set to true if there were multiple distinct spellings.</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.GlobalNamespaceDeclaration">
	<summary>
 Represents global namespace. Namespace's name is always empty
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.DeclarationTableEntry">
	<summary>
 A wrapper around RootSingleNamespaceDeclaration. The namespace declaration
 is evaluated lazily to avoid evaluating the namespace and associated SyntaxTree
 for embedded syntax trees before we can determine whether the syntax tree is needed.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.DeclarationTable">
	<summary>
 A declaration table is a device which keeps track of type and namespace declarations from
 parse trees. It is optimized for the case where there is one set of declarations that stays
 constant, and a specific root namespace declaration corresponding to the currently edited
 file which is being added and removed repeatedly. It maintains a cache of information for
 "merging" the root declarations into one big summary declaration; this cache is efficiently
 re-used provided that the pattern of adds and removes is as we expect.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Declaration">
	<summary>
 A Declaration summarizes the declaration structure of a source file. Each entity declaration
 in the program that is a container (specifically namespaces, classes, interfaces, structs,
 and delegate declarations) is represented by a node in this tree.  At the top level, the
 compilation unit is treated as a declaration of the unnamed namespace.

 Special treatment is required for namespace declarations, because a single namespace
 declaration can declare more than one namespace.  For example, in the declaration

namespace A.B.C {}

we see that namespaces A and B and C are declared.  This declaration is represented as three
 declarations. All three of these ContainerDeclaration objects contain a reference to the
 syntax tree for the declaration.

 A "single" declaration represents a specific namespace or type declaration at a point in
 source code. A "root" declaration is a special single declaration which summarizes the
 contents of an entire file's types and namespaces.  Each source file is represented as a tree
 of single declarations.

 A "merged" declaration merges together one or more declarations for the same symbol.  For
 example, the root namespace has multiple single declarations (one in each source file) but
 there is a single merged declaration for them all.  Similarly partial classes may have
 multiple declarations, grouped together under the umbrella of a merged declaration.  In the
 common trivial case, a merged declaration for a single declaration contains only that single
 declaration.  The whole program, consisting of the set of all declarations in all of the
 source files, is represented by a tree of merged declarations.'''
</summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationOptions.GlobalImports">
	<summary>
 The list of global imports.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationOptions.RootNamespace">
	<summary>
 The default namespace for all source code in the project. Corresponds to the 
 "RootNamespace" project option or the "/rootnamespace" command line option.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationOptions.OptionStrict">
	<summary>
 True if Option Strict On is in effect by default. False if Option Strict Off is in effect by default.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationOptions.OptionInfer">
	<summary>
 True if Option Infer On is in effect by default. False if Option Infer Off is in effect by default.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationOptions.OptionExplicit">
	<summary>
 True if Option Explicit On is in effect by default. False if Option Explicit Off is in
 effect by default.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationOptions.OptionCompareText">
	<summary>
 True if Option Compare Text is in effect by default. False if Option Compare Binary is
 in effect by default.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationOptions.EmbedVbCoreRuntime">
	<summary>
 True if VB core runtime should be embedded in the compilation. Equal to '/vbruntime*'
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeInfo.Type">
	<summary>
 The type of the expression represented by the syntax node. For expressions that do not
 have a type, null is returned. If the type could not be determined due to an error, than
 an object derived from ErrorTypeSymbol is returned.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeInfo.ConvertedType">
	<summary>
 The type of the expression after it has undergone an implicit conversion. If the type
 did not undergo an implicit conversion, returns the same as Type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeInfo.ImplicitConversion">
	<summary>
 If the expression underwent an implicit conversion, return information about that
 conversion. Otherwise, returns an identity conversion.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeInfo.GetPossibleGuessForErrorType(Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Guess the non-error type that the given type was intended to represent, or return
 the type itself. If a single, non-ambiguous type is a guess-type inside the type symbol, 
 return that; otherwise return the type itself (even if it is an error type).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeCompilationState.MethodWithBody">
	<summary> Method's information </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCompilationState._methods">
	<summary> Flat array of created methods, non-empty if not-nothing </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.TypeCompilationState._methodWrappers">
	<summary> 
 Map of 'MyBase' or 'MyClass' call wrappers; actually each method symbol will 
 only need one wrapper to call it non-virtually; 
 
 Indeed, if the type have a virtual method M1 overridden, MyBase.M1 will use 
 a wrapper for base type's method and MyClass.M1 a wrapper for this type's method.
 
 And if the type does not override a virtual method M1, both MyBase.M1 
 and MyClass.M1 will use a wrapper for base type's method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeCompilationState.HasAnyMethods">
	<summary> Is there any content in the methods collection </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.TypeCompilationState.Methods">
	<summary> Method created with their bodies </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypeCompilationState.Free">
	<summary> Free resources </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypeCompilationState">
	<summary>
 Represents the state of compilation of one particular type.
 This includes, for example, a collection of synthesized methods created during lowering.
 WARNING: Note that the underlying collection classes are not thread-safe and this will 
 need to be revised if emit phase is changed to support multithreading when
 translating a particular type.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.Compilation">
	<summary> 
 The compilation associated with this binding.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.Root">
	<summary> 
 The root node of the syntax tree that this binding is based on.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.SyntaxTree">
	<summary> 
 The SyntaxTree that is bound
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDiagnostics(System.Threading.CancellationToken)">
	<summary>
 Get all the errors within the syntax tree associated with this object. Includes errors involving compiling
 method bodies or initializers, in addition to the errors returned by GetDeclarationDiagnostics.
 </summary>
	<param name="cancellationToken">A cancellation token that can be used to cancel the process of obtaining the
 diagnostics.</param>
	<remarks>
 Because this method must semantically all method bodies and initializers to check for diagnostics, it may
 take a significant amount of time. Unlike GetDeclarationDiagnostics, diagnostics for method bodies and
 initializers are not cached, the any semantic information used to obtain the diagnostics is discarded.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclarationDiagnostics(System.Threading.CancellationToken)">
	<summary>
 Get all the syntax and declaration errors within the syntax tree associated with this object. Does not get
 errors involving compiling method bodies or initializers.
 </summary>
	<param name="cancellationToken">A cancellation token that can be used to cancel the process of obtaining the
 diagnostics.</param>
	<remarks>The declaration errors for a syntax tree are cached. The first time this method is called, a ll
 declarations are analyzed for diagnostics. Calling this a second time will return the cached diagnostics.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.CheckSymbolLocationsAgainstSyntax(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Checks all symbol locations against the syntax provided and rreturn symbol if any of the locations is 
 inside the syntax span. Returns Nothing otherwise.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.DelegateStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a delegate declaration, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a type.</param>
	<returns>The type symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.TypeStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a type declaration, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a type.</param>
	<returns>The type symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.EnumStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a enum declaration, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares an enum.</param>
	<returns>The type symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.NamespaceStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a namespace declaration, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a namespace.</param>
	<returns>The namespace symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a method, property, or event declaration, get the corresponding symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a method, property, or event.</param>
	<returns>The method, property, or event symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.ParameterSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a parameter declaration, get the corresponding parameter symbol.
 </summary>
	<param name="parameter">The syntax node that declares a parameter.</param>
	<returns>The parameter symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.TypeParameterSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a type parameter declaration, get the corresponding type parameter symbol.
 </summary>
	<param name="typeParameter">The syntax node that declares a type parameter.</param>
	<returns>The type parameter symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a variable declaration, get the corresponding  symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a variable.</param>
	<returns>The symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.FieldInitializerSyntax,System.Threading.CancellationToken)">
	<summary>
 Given an FieldInitializerSyntax, get the corresponding symbol of anonymous type creation.
 </summary>
	<param name="fieldInitializerSyntax">The anonymous object creation field initializer syntax.</param>
	<returns>The symbol that was declared, or Nothing if no such symbol exists.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.AnonymousObjectCreationExpressionSyntax,System.Threading.CancellationToken)">
	<summary>
 Given an AnonymousObjectCreationExpressionSyntax, get the corresponding symbol of anonymous type.
 </summary>
	<param name="anonymousObjectCreationExpressionSyntax">The anonymous object creation syntax.</param>
	<returns>The symbol that was declared, or Nothing if no such symbol exists.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax,System.Threading.CancellationToken)">
	<summary>
 Given an ExpressionRangeVariableSyntax, get the corresponding symbol.
 </summary>
	<param name="rangeVariableSyntax">The range variable syntax that declares a variable.</param>
	<returns>The symbol that was declared, or Nothing if no such symbol exists.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax,System.Threading.CancellationToken)">
	<summary>
 Given an CollectionRangeVariableSyntax, get the corresponding symbol.
 </summary>
	<param name="rangeVariableSyntax">The range variable syntax that declares a variable.</param>
	<returns>The symbol that was declared, or Nothing if no such symbol exists.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax,System.Threading.CancellationToken)">
	<summary>
 Given an AggregationRangeVariableSyntax, get the corresponding symbol.
 </summary>
	<param name="rangeVariableSyntax">The range variable syntax that declares a variable.</param>
	<returns>The symbol that was declared, or Nothing if no such symbol exists.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.AliasImportsClauseSyntax,System.Threading.CancellationToken)">
	<summary>
 Given an import clause get the corresponding symbol for the import alias that was introduced.
 </summary>
	<param name="declarationSyntax">The import statement syntax node.</param>
	<returns>The alias symbol that was declared or Nothing if no alias symbol was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.ClassifyConversion(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Determines what type of conversion, if any, would be used if a given expression was converted to a given
 type.
 </summary>
	<param name="expression">An expression which much occur within the syntax tree associated with this
 object.</param>
	<param name="destination">The type to attempt conversion to.</param>
	<returns>Returns a Conversion object that summarizes whether the conversion was possible, and if so, what
 kind of conversion it was. If no conversion was possible, a Conversion object with a false "Exists "
 property is returned.</returns>
	<remarks>To determine the conversion between two types (instead of an expression and a type), use
 Compilation.ClassifyConversion.</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.AnalyzeControlFlow(Roslyn.Compilers.VisualBasic.StatementSyntax,Roslyn.Compilers.VisualBasic.StatementSyntax)">
	<summary>
 Analyze control-flow within a part of a method body.
 </summary>
	<param name="firstStatement">The first statement to be included in the analysis.</param>
	<param name="lastStatement">The last statement to be included in the analysis.</param>
	<returns>An object that can be used to obtain the result of the control flow analysis.</returns>
	<exception cref="T:System.ArgumentException">The two statements are not contained within the same statement list.</exception>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.AnalyzeDataFlow(Roslyn.Compilers.VisualBasic.StatementSyntax,Roslyn.Compilers.VisualBasic.StatementSyntax)">
	<summary>
 The first statement to be included in the analysis.
 </summary>
	<param name="firstStatement">The first statement to be included in the analysis.</param>
	<param name="lastStatement">The last statement to be included in the analysis.</param>
	<returns>An object that can be used to obtain the result of the data flow analysis.</returns>
	<exception cref="T:System.ArgumentException">The two statements are not contained within the same statement list.</exception>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.AnalyzeDataFlow(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Analyze data-flow within an expression. 
 </summary>
	<param name="expression">The expression within the associated SyntaxTree to analyze.</param>
	<returns>An object that can be used to obtain the result of the data flow analysis.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.IsNodeInsideAttributeArguments(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Checks if the node is inside the attribute arguments 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.IsExpressionInValidContext(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Check Expression for being in right context, for example 'For ... Next [x]' 
 is not correct context
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.IsNotUppermostForBlock(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Check ForBlockSyntax for being the uppermost For block. By uppermost 
 For block we mean that if Next clause contains several control variables,
 the uppermost block is the one which includes all the For blocks ending with 
 the same Next clause
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.GetForEachStatementInfoWorker(Roslyn.Compilers.VisualBasic.ForBlockSyntax)">
	<summary>
 Gets the semantic information of a for each statement.
 </summary>
	<param name="node">The for each syntax node.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel.CreateFailedRegionAnalysisContext">
	<summary> Used to create a region analysis context 
 with failed flag set to be used in 'failed' scenarios </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SyntaxTreeSemanticModel">
	<summary>
 Allows asking semantic questions about any node in a SyntaxTree within a Compilation.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SymbolInfo.Symbol">
	<summary>
 The symbol that was referred to by the syntax node, if any. Returns null if the given
 expression did not bind successfully to a single symbol. If null is returned, it may
 still be that case that we have one or more "best guesses" as to what symbol was
 intended. These best guesses are available via the CandidateSymbols property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SymbolInfo.CandidateSymbols">
	<summary>
 If the expression did not successfully resolve to a symbol, but there were one or more
 symbols that may have been considered but discarded, this property returns those
 symbols. The reason that the symbols did not successfully resolve to a symbol are
 available in the CandidateReason property. For example, if the symbol was inaccessible,
 ambiguous, or used in the wrong context.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SymbolInfo.CandidateReason">
	<summary>
 If the expression did not successfully resolve to a symbol, but there were one or more
 symbols that may have been considered but discarded, this property describes why those
 symbol or symbols were not considered suitable.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SemanticModel.Compilation">
	<summary> 
 The compilation associated with this binding.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SemanticModel.Root">
	<summary> 
 The root node of the syntax tree that this binding is based on.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetExpressionSymbolInfo(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.SemanticModel.SymbolInfoOptions,System.Threading.CancellationToken)">
	<summary>
 Gets symbol information about an expression syntax node. This is the worker
 function that is overridden in various derived kinds of Semantic Models. It can assume that 
 CheckSyntaxNode has already been called.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetAttributeSymbolInfo(Roslyn.Compilers.VisualBasic.AttributeSyntax,System.Threading.CancellationToken)">
	<summary>
 Gets symbol information about an attribute syntax node. This is the worker
 function that is overridden in various derived kinds of Semantic Models. It can assume that 
 CheckSyntaxNode has already been called.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetExpressionTypeInfo(Roslyn.Compilers.VisualBasic.ExpressionSyntax,System.Threading.CancellationToken)">
	<summary>
 Gets type information about an expression syntax node. This is the worker
 function that is overridden in various derived kinds of Semantic Models. It can assume that 
 CheckSyntaxNode has already been called.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetAttributeTypeInfo(Roslyn.Compilers.VisualBasic.AttributeSyntax,System.Threading.CancellationToken)">
	<summary>
 Gets type information about an attribute syntax node. This is the worker
 function that is overridden in various derived kinds of Semantic Models. It can assume that 
 CheckSyntaxNode has already been called.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetExpressionConstantValue(Roslyn.Compilers.VisualBasic.ExpressionSyntax,System.Threading.CancellationToken)">
	<summary>
 Gets constant value information about an expression syntax node. This is the worker
 function that is overridden in various derived kinds of Semantic Models. It can assume that 
 CheckSyntaxNode has already been called.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetExpressionMemberGroup(Roslyn.Compilers.VisualBasic.ExpressionSyntax,System.Threading.CancellationToken)">
	<summary>
 Gets member group information about an expression syntax node. This is the worker
 function that is overridden in various derived kinds of Semantic Models. It can assume that 
 CheckSyntaxNode has already been called.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetAttributeMemberGroup(Roslyn.Compilers.VisualBasic.AttributeSyntax,System.Threading.CancellationToken)">
	<summary>
 Gets member group information about an attribute syntax node. This is the worker
 function that is overridden in various derived kinds of Semantic Models. It can assume that 
 CheckSyntaxNode has already been called.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetSymbolInfo(Roslyn.Compilers.VisualBasic.ExpressionSyntax,System.Threading.CancellationToken)">
	<summary>
 Returns what symbol(s), if any, the given expression syntax bound to in the program.
 
 An AliasSymbol will never be returned by this method. What the alias refers to will be
 returned instead. To get information about aliases, call GetAliasInfo.
 
 If binding the type name C in the expression "new C(...)" the actual constructor bound to
 will be returned (or all constructor if overload resolution failed). This occurs as long as C
 unambiguously binds to a single type that has a constructor. If C ambiguously binds to multiple
 types, or C binds to a static class, then type(s) are returned.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetSpeculativeSymbolInfo(System.Int32,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.Common.SpeculativeBindingOption)">
	<summary>
 Binds the expression in the context of the specified location and get semantic
 information such as type, symbols and diagnostics. This method is used to get semantic
 information about an expression that did not actually appear in the source code.
 </summary>
	<param name="position">A character position used to identify a declaration scope and
 accessibility. This character position must be within the FullSpan of the Root syntax
 node in this SemanticModel.
 </param>
	<param name="expression">A syntax node that represents a parsed expression. This syntax
 node need not and typically does not appear in the source code referred to  SemanticModel
 instance.</param>
	<param name="bindingOption">Indicates whether to binding the expression as a full expressions,
 or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
 expression should derive from TypeSyntax.</param>
	<returns>The semantic information for the topmost node of the expression.</returns>
	<remarks>The passed in expression is interpreted as a stand-alone expression, as if it
 appeared by itself somewhere within the scope that encloses "position".</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetSpeculativeSymbolInfo(System.Int32,Roslyn.Compilers.VisualBasic.AttributeSyntax)">
	<summary>
 Bind the attribute in the context of the specified location and get semantic information
 such as type, symbols and diagnostics. This method is used to get semantic information about an attribute
 that did not actually appear in the source code.
 </summary>
	<param name="position">A character position used to identify a declaration scope and accessibility. This
 character position must be within the FullSpan of the Root syntax node in this SemanticModel. In order to obtain
 the correct scoping rules for the attribute, position should be the Start position of the Span of the symbol that
 the attribute is being applied to.
 </param>
	<param name="attribute">A syntax node that represents a parsed attribute. This syntax node
 need not and typically does not appear in the source code referred to SemanticModel instance.</param>
	<returns>The semantic information for the topmost node of the attribute.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetTypeInfo(Roslyn.Compilers.VisualBasic.ExpressionSyntax,System.Threading.CancellationToken)">
	<summary>
 Gets type information about an expression.
 </summary>
	<param name="expression">The syntax node to get type information for.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetSpeculativeTypeInfo(System.Int32,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.Common.SpeculativeBindingOption)">
	<summary>
 Binds the expression in the context of the specified location and gets type information.
 This method is used to get type information about an expression that did not actually
 appear in the source code.
 </summary>
	<param name="position">A character position used to identify a declaration scope and
 accessibility. This character position must be within the FullSpan of the Root syntax
 node in this SemanticModel.
 </param>
	<param name="expression">A syntax node that represents a parsed expression. This syntax
 node need not and typically does not appear in the source code referred to by the
 SemanticModel instance.</param>
	<param name="bindingOption">Indicates whether to binding the expression as a full expressions,
 or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
 expression should derive from TypeSyntax.</param>
	<returns>The type information for the topmost node of the expression.</returns>
	<remarks>The passed in expression is interpreted as a stand-alone expression, as if it
 appeared by itself somewhere within the scope that encloses "position".</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetSpeculativeConstantValue(System.Int32,Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Binds the expression in the context of the specified location and gets constant value information. 
 This method is used to get information about an expression that did not actually appear in the source code.
 </summary>
	<param name="position">A character position used to identify a declaration scope and
 accessibility. This character position must be within the FullSpan of the Root syntax
 node in this SemanticModel.
 </param>
	<param name="expression">A syntax node that represents a parsed expression. This syntax
 node need not and typically does not appear in the source code referred to by SemanticModel
 instance.</param>
	<remarks>The passed in expression is interpreted as a stand-alone expression, as if it
 appeared by itself somewhere within the scope that encloses "position".</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetAliasInfo(Roslyn.Compilers.VisualBasic.IdentifierNameSyntax,System.Threading.CancellationToken)">
	<summary>
 If "nameSyntax" resolves to an alias name, return the AliasSymbol corresponding
 to A. Otherwise return null.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetSpeculativeAliasInfo(System.Int32,Roslyn.Compilers.VisualBasic.IdentifierNameSyntax,Roslyn.Compilers.Common.SpeculativeBindingOption)">
	<summary>
 Binds the name in the context of the specified location and sees if it resolves to an
 alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
 </summary>
	<param name="position">A character position used to identify a declaration scope and
 accessibility. This character position must be within the FullSpan of the Root syntax
 node in this SemanticModel.
 </param>
	<param name="nameSyntax">A syntax node that represents a name. This syntax
 node need not and typically does not appear in the source code referred to by the
 SemanticModel instance.</param>
	<param name="bindingOption">Indicates whether to binding the name as a full expression,
 or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
 expression should derive from TypeSyntax.</param>
	<remarks>The passed in name is interpreted as a stand-alone name, as if it
 appeared by itself somewhere within the scope that encloses "position".</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetEnclosingBinder(System.Int32)">
	<summary>
 Gets the binder that encloses the position. See comment on LookupSymbols for how
 positions are interpreted.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.MakeValueIfPossible(Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.BoundNode)">
	<summary>
 When doing speculative binding, we don't have any context information about expressions or the
 context that is expected. We try to interpret as a value, but
 only if it doesn't cause additional errors (indicating that it wasn't value to interpret it
 that way). This should get us the most "liberal" interpretation
 for semantic information.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetSpeculativelyBoundAttribute(System.Int32,Roslyn.Compilers.VisualBasic.AttributeSyntax,Roslyn.Compilers.VisualBasic.Binder@)">
	<summary>
 Bind the given attribute speculatively at the given position, and return back
 the resulting bound node. May return null in some error cases.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.LookupSymbols(System.Int32,Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol,System.String,System.Nullable{System.Int32},Roslyn.Compilers.VisualBasic.LookupOptions)">
	<summary>
 Gets the available named symbols in the context of the specified location and optional
 container. Only symbols that are accessible and visible from the given location are
 returned.
 </summary>
	<param name="position">The character position for determining the enclosing declaration
 scope and accessibility.</param>
	<param name="container">The container to search for symbols within. If null then the
 enclosing declaration scope around position is used.</param>
	<param name="name">The name of the symbol to find. If null is specified then symbols
 with any names are returned.</param>
	<param name="arity">The number of generic type parameters the symbol has. If null is
 specified then symbols with any arity are returned.</param>
	<param name="options">Additional options that affect the lookup process.</param>
	<returns>A list of symbols that were found. If no symbols were found, an empty list is
 returned.</returns>
	<remarks>
 The "position" is used to determine what variables are visible and accessible. Even if
 "container" is specified, the "position" location is significant for determining which
 members of "containing" are accessible. 
 
 Locations are character locations, just as used as the Syntax APIs such as FindToken, or 
 returned from the Span property on tokens and syntax node.
 
 The text of the program is divided into scopes, which nest but don't otherwise
 intersect. When doing an operation such as LookupSymbols, the code first determines the
 smallest scope containing the position, and from there all containing scopes. 
 
 Scopes that span an entire block statement start at the beginning of the first token of 
 the block header, and end immediately before the statement terminator token following
 the end statement of the block. If the end statement of the block is missing, it ends
 immediately before the next token. Examples of these include members and type parameters
 of a type, type parameters of a method, and variables declared in a For statement.
 
 Scopes that span the interior of a block statement start at the statement terminator of 
 the block header statement, and end immediately before the first token of the end
 statement of the block. If the end statement of the block is missing, it ends
 immediately before the next statement. Examples of these include local variables, method
 parameters, and members of a namespace.
 
 Scopes of variables declared in a single-line If statement start at the beginning of the
 "Then" token, and end immediately before the Else token or statement terminator. 
 
 Scopes of variables declared in the Else part of a single-line If start at the beginning
 of the "Else" token, and end immediately before the statement terminator.
 
 Some specialized binding rules are in place for a single statement, like Imports or
 Inherits. These specialized binding rules begin at the start of the first token of the
 statement, and end immediately before the statement terminator of that statement.
 
 In all of the above, the "start" means the start of a token without considering leading
 trivia. In other words, Span.Start, not FullSpan.Start. With the exception of
 documentation comments, all scopes begin at the start of a token, and end immediately
 before the start of a token.
 
 The scope of the default namespace, and all symbols introduced via Imports statements,
 is the entire file.
 
 Positions within a documentation comment that is correctly attached to a symbol take on
 the binding scope of that symbol. 
 </remarks>
	<exception cref="T:System.ArgumentException">Throws an argument exception if the passed lookup options are invalid.</exception>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.AddLookupSymbolsInfo(System.Int32,Roslyn.Compilers.VisualBasic.LookupSymbolsInfo,Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol,Roslyn.Compilers.VisualBasic.LookupOptions)">
	<summary>
 Gets the names of the available named symbols in the context of the specified location
 and optional container. Only symbols that are accessible and visible from the given
 location are returned.
 </summary>
	<param name="position">A character position used to identify a declaration scope and
 accessibility. This character position must be within the FullSpan of the Root syntax
 node in this SemanticModel.
 </param>
	<param name="container">The container to search for symbols within. If null then the
 enclosing declaration scope around position is used.</param>
	<param name="options">Additional options that affect the lookup process.</param>
	<remarks>
 The "position" is used to determine what variables are visible and accessible. Even if
 "container" is specified, the "position" location is significant for determining which
 members of "containing" are accessible.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.IsAccessible(System.Int32,Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Determines if the symbol is accessible from the specified location.
 </summary>
	<param name="position">A character position used to identify a declaration scope and
 accessibility. This character position must be within the FullSpan of the Root syntax
 node in this SemanticModel.
 </param>
	<param name="symbol">The symbol that we are checking to see if it accessible.</param>
	<returns>
 True if "symbol is accessible, false otherwise.</returns>
	<remarks>
 This method only checks accessibility from the point of view of the accessibility
 modifiers on symbol and its containing types. Even if true is returned, the given symbol
 may not be able to be referenced for other reasons, such as name hiding.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.ResolveOverloads``1(System.Int32,Roslyn.Compilers.ReadOnlyArray{``0},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.ArgumentSyntax})">
	<summary>
 Resolves the set of provided arguments against set of provided methods or properties to determine the
 appropriate overload.  The arguments are bound as if they were at 'position' within this
 binding.  An OverloadResolutionResult is returned that gives the result of the compiler's
 overload resolution analysis.
 </summary>
	<param name="position">A character position used to identify a declaration scope and
 accessibility. This character position must be within the FullSpan of the Root syntax
 node in this SemanticModel. This position is used when binding the arguments.
 </param>
	<param name="members">The set of methods or properties to resolve overloads among.</param>
	<param name="arguments">The list of arguments, in order, to use when resolving the
 overloads. The arguments are interpreted as if they occurred within the declaration
 scope that encloses "position".</param>
	<param name="typeArguments">If present, the type argument provided. If not provided,
 type inference is done. May not be provided if TMember is PropertySymbol</param>
	<typeparam name="TMember">Must be MethodSymbol to resolve overloads on methods, or
 PropertySymbol to resolve overloads on properties.</typeparam>
	<remarks>
 This can be used to resolve constructors as well as methods.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.AnalyzeControlFlow(Roslyn.Compilers.VisualBasic.StatementSyntax,Roslyn.Compilers.VisualBasic.StatementSyntax)">
	<summary>
 Analyze control-flow within a part of a method body.
 </summary>
	<param name="firstStatement">The first statement to be included in the analysis.</param>
	<param name="lastStatement">The last statement to be included in the analysis.</param>
	<returns>An object that can be used to obtain the result of the control flow analysis.</returns>
	<exception cref="T:System.ArgumentException">The two statements are not contained within the same statement list.</exception>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.AnalyzeControlFlow(Roslyn.Compilers.VisualBasic.StatementSyntax)">
	<summary>
 Analyze control-flow within a part of a method body.
 </summary>
	<param name="statement">The statement to be included in the analysis.</param>
	<returns>An object that can be used to obtain the result of the control flow analysis.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.AnalyzeDataFlow(Roslyn.Compilers.VisualBasic.ExpressionSyntax)">
	<summary>
 Analyze data-flow within an expression. 
 </summary>
	<param name="expression">The expression within the associated SyntaxTree to analyze.</param>
	<returns>An object that can be used to obtain the result of the data flow analysis.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.AnalyzeDataFlow(Roslyn.Compilers.VisualBasic.StatementSyntax,Roslyn.Compilers.VisualBasic.StatementSyntax)">
	<summary>
 Analyze data-flow within a set of contiguous statements.
 </summary>
	<param name="firstStatement">The first statement to be included in the analysis.</param>
	<param name="lastStatement">The last statement to be included in the analysis.</param>
	<returns>An object that can be used to obtain the result of the data flow analysis.</returns>
	<exception cref="T:System.ArgumentException">The two statements are not contained within the same statement list.</exception>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.AnalyzeDataFlow(Roslyn.Compilers.VisualBasic.StatementSyntax)">
	<summary>
 Analyze data-flow within a statement.
 </summary>
	<param name="statement">The statement to be included in the analysis.</param>
	<returns>An object that can be used to obtain the result of the data flow analysis.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.ClassifyConversion(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Determines what type of conversion, if any, would be used if a given expression was
 converted to a given type.
 </summary>
	<param name="expression">An expression which must occur within the syntax tree
 associated with this object.</param>
	<param name="destination">The type to attempt conversion to.</param>
	<returns>Returns a Conversion object that summarizes whether the conversion was
 possible, and if so, what kind of conversion it was. If no conversion was possible, a
 Conversion object with a false "Exists " property is returned.</returns>
	<remarks>To determine the conversion between two types (instead of an expression and a
 type), use Compilation.ClassifyConversion.</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.ClassifyConversion(System.Int32,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Determines what type of conversion, if any, would be used if a given expression was
 converted to a given type.
 </summary>
	<param name="position">The character position for determining the enclosing declaration scope and accessibility.</param>
	<param name="expression">An expression to classify. This expression does not need to be
 present in the syntax tree associated with this object.</param>
	<param name="destination">The type to attempt conversion to.</param>
	<returns>Returns a Conversion object that summarizes whether the conversion was
 possible, and if so, what kind of conversion it was. If no conversion was possible, a
 Conversion object with a false "Exists " property is returned.</returns>
	<remarks>To determine the conversion between two types (instead of an expression and a
 type), use Compilation.ClassifyConversion.</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclarationDiagnostics(System.Threading.CancellationToken)">
	<summary>
 Get all the syntax and declaration errors within the syntax tree associated with this
 object. Does not get errors involving compiling method bodies or initializers.
 </summary>
	<param name="cancellationToken">A cancellation token that can be used to cancel the
 process of obtaining the diagnostics.</param>
	<remarks>The declaration errors for a syntax tree are cached. The first time this method
 is called, a ll declarations are analyzed for diagnostics. Calling this a second time
 will return the cached diagnostics.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDiagnostics(System.Threading.CancellationToken)">
	<summary>
 Get all the errors within the syntax tree associated with this object. Includes errors
 involving compiling method bodies or initializers, in addition to the errors returned by
 GetDeclarationDiagnostics.
 </summary>
	<param name="cancellationToken">A cancellation token that can be used to cancel the
 process of obtaining the diagnostics.</param>
	<remarks>
 Because this method must semantically all method bodies and initializers to check for
 diagnostics, it may take a significant amount of time. Unlike GetDeclarationDiagnostics,
 diagnostics for method bodies and initializers are not cached, the any semantic
 information used to obtain the diagnostics is discarded.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,System.Threading.CancellationToken)">
	<summary>
 Given an modified identifier that is part of a variable declaration, get the
 corresponding symbol.
 </summary>
	<param name="identifierSyntax">The modified identifier that declares a variable.</param>
	<returns>The symbol that was declared, or Nothing if no such symbol exists.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.FieldInitializerSyntax,System.Threading.CancellationToken)">
	<summary>
 Given an FieldInitializerSyntax, get the corresponding symbol of anonymous type property.
 </summary>
	<param name="fieldInitializerSyntax">The anonymous object creation field initializer syntax.</param>
	<returns>The symbol that was declared, or Nothing if no such symbol exists or 
 if the field initializer was not part of an anonymous type creation.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.AnonymousObjectCreationExpressionSyntax,System.Threading.CancellationToken)">
	<summary>
 Given an AnonymousObjectCreationExpressionSyntax, get the corresponding symbol of anonymous type.
 </summary>
	<param name="anonymousObjectCreationExpressionSyntax">The anonymous object creation syntax.</param>
	<returns>The symbol that was declared, or Nothing if no such symbol exists.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax,System.Threading.CancellationToken)">
	<summary>
 Given an ExpressionRangeVariableSyntax, get the corresponding symbol.
 </summary>
	<param name="rangeVariableSyntax">The range variable syntax that declares a variable.</param>
	<returns>The symbol that was declared, or Nothing if no such symbol exists.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax,System.Threading.CancellationToken)">
	<summary>
 Given an CollectionRangeVariableSyntax, get the corresponding symbol.
 </summary>
	<param name="rangeVariableSyntax">The range variable syntax that declares a variable.</param>
	<returns>The symbol that was declared, or Nothing if no such symbol exists.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax,System.Threading.CancellationToken)">
	<summary>
 Given an AggregationRangeVariableSyntax, get the corresponding symbol.
 </summary>
	<param name="rangeVariableSyntax">The range variable syntax that declares a variable.</param>
	<returns>The symbol that was declared, or Nothing if no such symbol exists.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.LabelStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a label statement, get the corresponding label symbol.
 </summary>
	<param name="declarationSyntax">The label statement.</param>
	<returns>The label symbol, or Nothing if no such symbol exists.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a declarationSyntax that is part of a enum constant declaration, get the
 corresponding symbol.
 </summary>
	<param name="declarationSyntax">The declarationSyntax that declares a variable.</param>
	<returns>The symbol that was declared, or Nothing if no such symbol exists.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.TypeStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a type declaration, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a type.</param>
	<returns>The type symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.TypeBlockSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a type block, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a type block.</param>
	<returns>The type symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.EnumStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a enum declaration, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares an enum.</param>
	<returns>The type symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.EnumBlockSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a enum block, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares an enum block.</param>
	<returns>The type symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.NamespaceStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a namespace declaration, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a namespace.</param>
	<returns>The namespace symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.NamespaceBlockSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a namespace block, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a namespace block.</param>
	<returns>The namespace symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a method, property, or event declaration, get the corresponding symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a method, property, or event.</param>
	<returns>The method, property, or event symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.ParameterSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a parameter declaration, get the corresponding parameter symbol.
 </summary>
	<param name="parameter">The syntax node that declares a parameter.</param>
	<returns>The parameter symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.TypeParameterSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a type parameter declaration, get the corresponding type parameter symbol.
 </summary>
	<param name="typeParameter">The syntax node that declares a type parameter.</param>
	<returns>The type parameter symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.DelegateStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a delegate statement syntax get the corresponding named type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a delegate.</param>
	<returns>The named type that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a constructor statement syntax get the corresponding method symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a constructor.</param>
	<returns>The method symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.MethodStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a method statement syntax get the corresponding method symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a method.</param>
	<returns>The method symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.DeclareStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a method statement syntax get the corresponding method symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a method.</param>
	<returns>The method symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.OperatorStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a operator statement syntax get the corresponding method symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares an operator.</param>
	<returns>The method symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.MethodBlockSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a method block syntax get the corresponding method, property or event symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares method, property or event.</param>
	<returns>The method, property or event symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.PropertyStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a property statement syntax get the corresponding property symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a property.</param>
	<returns>The property symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.EventStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given an event statement syntax get the corresponding event symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares an event.</param>
	<returns>The event symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.PropertyBlockSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a property block syntax get the corresponding property symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares property.</param>
	<returns>The property symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.EventBlockSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a custom event block syntax get the corresponding event symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares the custom event.</param>
	<returns>The event symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.CatchStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a catch statement syntax get the corresponding local symbol.
 </summary>
	<param name="declarationSyntax">The catch statement syntax node.</param>
	<returns>The local symbol that was declared by the Catch statement or Nothing if statement does not declare a local variable.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.AccessorStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a property block syntax get the corresponding property symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares property.</param>
	<returns>The property symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.AliasImportsClauseSyntax,System.Threading.CancellationToken)">
	<summary>
 Given an import clause get the corresponding symbol for the import alias that was introduced.
 </summary>
	<param name="declarationSyntax">The import statement syntax node.</param>
	<returns>The alias symbol that was declared or Nothing if no alias symbol was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetInvokeSummaryForRaiseEvent(Roslyn.Compilers.VisualBasic.RaiseEventStatementSyntax)">
	<summary>
 Gets bound node summary of the underlying invocation in a case of RaiseEvent
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetNamedArgumentSymbolInfoInRaiseEvent(System.String,Roslyn.Compilers.VisualBasic.RaiseEventStatementSyntax,Roslyn.Compilers.VisualBasic.IdentifierNameSyntax)">
	<summary>
 RaiseEvent situation is very special: 
 1) Unlike other syntaxes that take named arguments, RaiseEvent is a statement. 
 2) RaiseEvent is essentially a wrapper aroung underlying call to the event rising method.
    Note that while event itself may have named parameters in its syntax, their names could be irrelevant
    For the purpose of fetching named parameters, it is the target of the call that we are interested in.
    
    === Example:
 
 Interface I1
    Event E(qwer As Integer)  
 End Interface
 
 Class cls1 : Implements I1
    Event E3(bar As Integer) Implements I1.E   '  "bar" means nothing here. Only type matters.

    Sub moo()
        RaiseEvent E3(qwer:=123)  ' qwer binds to parameter on I1.EEventhandler.invoke(foo)
    End Sub
End Class
 
 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SemanticModel.SyntaxTree">
	<summary> 
 The SyntaxTree that is bound
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetForEachStatementInfo(Roslyn.Compilers.VisualBasic.ForEachStatementSyntax)">
	<summary>
 Gets the semantic information of a for each statement.
 </summary>
	<param name="node">The for each syntax node.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetForEachStatementInfo(Roslyn.Compilers.VisualBasic.ForBlockSyntax)">
	<summary>
 Gets the semantic information of a for each statement.
 </summary>
	<param name="node">The for block syntax node.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetForEachStatementInfoWorker(Roslyn.Compilers.VisualBasic.ForBlockSyntax)">
	<summary>
 Gets the semantic information of a for each statement.
 </summary>
	<param name="node">The for each syntax node.</param>
</member><member name="F:Roslyn.Compilers.VisualBasic.SemanticModel.SymbolInfoOptions.PreferTypeToConstructors">
	<summary>
 When binding "C" new C(...), return the type C and do not return information about
 which constructor was bound to. Bind "new C(...)" to get information about which constructor
 was chosen.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SemanticModel.SymbolInfoOptions.PreferConstructorsToType">
	<summary>
 When binding "C" new C(...), return the constructor of C that was bound to, if C unambiguously
 binds to a single type with at least one constructor. 
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SemanticModel.SymbolInfoOptions.ResolveAliases">
	<summary>
 When binding a name X that was declared with a "using X=OtherTypeOrNamespace", return OtherTypeOrNamespace.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.SemanticModel.SymbolInfoOptions.PreserveAliases">
	<summary>
 When binding a name X that was declared with a "using X=OtherTypeOrNamespace", return the alias symbol X.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SemanticModel.SymbolInfoOptions">
	<summary>
 Options to control the internal working of GetSemanticInfoWorker. Not currently exposed
 to public clients, but could be if desired.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetEnclosingSymbol(System.Int32,System.Threading.CancellationToken)">
	<summary>
 Given a position in the SyntaxTree for this ISemanticModel returns the innermost Symbol
 that the position is considered inside of. 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SemanticModel.OptionStrict">
	<summary>
 Get the state of Option Strict for the code covered by this semantic model.
 This takes into effect both file-level "Option Strict" statements and the project-level
 defaults.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.SemanticModel.OptionInfer">
	<summary>
 Get the state of Option Infer for the code covered by this semantic model.
 This takes into effect both file-level "Option Infer" statements and the project-level
 defaults.
 </summary>
	<value>True if Option Infer On, False if Option Infer Off.</value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SemanticModel.OptionExplicit">
	<summary>
 Get the state of Option Explicit for the code covered by this semantic model.
 This takes into effect both file-level "Option Explicit" statements and the project-level
 defaults.
 </summary>
	<value>True if Option Explicit On, False if Option Explicit Off.</value>
</member><member name="P:Roslyn.Compilers.VisualBasic.SemanticModel.OptionCompareText">
	<summary>
 Get the state of Option Compare for the code covered by this semantic model.
 This takes into effect both file-level "Option Compare" statements and the project-level
 defaults.
 </summary>
	<value>True if Option Compare Text, False if Option Compare Binary.</value>
</member><member name="T:Roslyn.Compilers.VisualBasic.SemanticModel">
	<summary>
 Allows asking semantic questions about a tree of syntax nodes in a Compilation. Typically,
 an instance is obtained by a call to Compilation.GetBinding. 
 </summary>
	<remarks>
		<para>An instance of SemanticModel caches local symbols and semantic information. Thus, it
 is much more efficient to use a single instance of SemanticModel when asking multiple
 questions about a syntax tree, because information from the first question may be reused.
 This also means that holding onto an instance of SemanticModel for a long time may keep a
 significant amount of memory from being garbage collected.
 </para>
		<para>
 When an answer is a named symbol that is reachable by traversing from the root of the symbol
 table, (that is, from an AssemblySymbol of the Compilation), that symbol will be returned
 (i.e. the returned value will be reference-equal to one reachable from the root of the
 symbol table). Symbols representing entities without names (e.g. array-of-int) may or may
 not exhibit reference equality. However, some named symbols (such as local variables) are
 not reachable from the root. These symbols are visible as answers to semantic questions.
 When the same SemanticModel object is used, the answers exhibit reference-equality.  
 </para>
	</remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.CollectionRangeVariableSymbolInfo.ToQueryableCollectionConversion">
	<summary>
 Optional AsQueryable/AsEnumerable/Cast(Of Object) method used 
 to "convert" CollectionRangeVariableSyntax.Expression to queryable
 collection.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.CollectionRangeVariableSymbolInfo.AsClauseConversion">
	<summary>
 Optional Select method to handle AsClause.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.CollectionRangeVariableSymbolInfo.SelectMany">
	<summary>
 SelectMany method for CollectionRangeVariableSyntax, which is not the first
 CollectionRangeVariableSyntax in a QueryExpressionSyntax, and is not the first 
 CollectionRangeVariableSyntax in AggregateClauseSyntax.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.AggregateClauseSymbolInfo.Select1">
	<summary>
 The first of the two optional Select methods associated with AggregateClauseSyntax.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AggregateClauseSymbolInfo.Select2">
	<summary>
 The second of the two optional Select methods associated with AggregateClauseSyntax.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetCollectionRangeVariableSymbolInfo(Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax,System.Threading.CancellationToken)">
	<summary>
 Returns information about methods associated with CollectionRangeVariableSyntax.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetAggregateClauseSymbolInfo(Roslyn.Compilers.VisualBasic.AggregateClauseSyntax,System.Threading.CancellationToken)">
	<summary>
 Returns information about methods associated with AggregateClauseSyntax.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetSymbolInfo(Roslyn.Compilers.VisualBasic.QueryClauseSyntax,System.Threading.CancellationToken)">
	<summary>
 DistinctClauseSyntax -       Returns Distinct method associated with DistinctClauseSyntax.
 
 WhereClauseSyntax -          Returns Where method associated with WhereClauseSyntax.
 
 PartitionWhileClauseSyntax - Returns TakeWhile/SkipWhile method associated with PartitionWhileClauseSyntax.
 
 PartitionClauseSyntax -      Returns Take/Skip method associated with PartitionClauseSyntax.
 
 GroupByClauseSyntax -        Returns GroupBy method associated with GroupByClauseSyntax.
 
 JoinClauseSyntax -           Returns Join/GroupJoin method associated with JoinClauseSyntax/GroupJoinClauseSyntax.
 
 SelectClauseSyntax -         Returns Select method associated with SelectClauseSyntax, if needed.
 
 FromClauseSyntax -           Returns Select method associated with FromClauseSyntax, which has only one 
                              CollectionRangeVariableSyntax and is the only query clause within 
                              QueryExpressionSyntax. NotNeeded SymbolInfo otherwise. 
                              The method call is injected by the compiler to make sure that query is translated to at 
                              least one method call. 
 
 LetClauseSyntax -            NotNeeded SymbolInfo.
 
 OrderByClauseSyntax -        NotNeeded SymbolInfo.
 
 AggregateClauseSyntax -      Empty SymbolInfo. GetAggregateClauseInfo should be used instead.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetSymbolInfo(Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax,System.Threading.CancellationToken)">
	<summary>
 Returns Select method associated with ExpressionRangeVariableSyntax within a LetClauseSyntax, if needed.
 NotNeeded SymbolInfo otherwise.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetSymbolInfo(Roslyn.Compilers.VisualBasic.FunctionAggregationSyntax,System.Threading.CancellationToken)">
	<summary>
 Returns aggregate function associated with FunctionAggregationSyntax.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SemanticModel.GetSymbolInfo(Roslyn.Compilers.VisualBasic.OrderingSyntax,System.Threading.CancellationToken)">
	<summary>
 Returns OrdrBy/OrderByDescending/ThenBy/ThenByDescending method associated with OrderingSyntax.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverloadResolutionResult`1.Succeeded">
	<summary>
 True if overload resolution successfully selected a single best method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverloadResolutionResult`1.ValidResult">
	<summary>
 If overload resolution successfully selected a single best method, returns information
 about that method. Otherwise returns Nothing.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverloadResolutionResult`1.BestResult">
	<summary>
 If there was a method that overload resolution considered better than all others,
 returns information about that method. A method may be returned even if that method was
 not considered a successful overload resolution, as long as it was better than any other
 potential method considered.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.OverloadResolutionResult`1.Results">
	<summary>
 Returns information about each method that was considered during overload resolution,
 and what the results of overload resolution were for that method.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.OverloadResolutionResult`1">
	<summary>
 Summarizes the results of an overload resolution analysis. Describes whether overload resolution 
 succeeded, and which method was selected if overload resolution succeeded.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.NamespaceScopeBuilder">
	<summary>
 This class is used to generate the namespace scopes used by CCI when writing out the import lists.
 Because the content is nearly the same for each method (most of it is file and project level) this class
 has an internal cache.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MemberResolutionKind">
	<summary>
 Indicates whether the compiler accepted or rejected the method during overload resolution.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MemberResolutionResult`1.Member">
	<summary>
 The method or property considered during overload resolution.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MemberResolutionResult`1.Resolution">
	<summary>
 Indicates why the compiler accepted or rejected the method during overload resolution.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MemberResolutionResult`1.IsValid">
	<summary>
 Returns true if the compiler accepted this method as the sole correct result of overload resolution.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.MemberResolutionResult`1.IsExpandedParamArrayForm">
	<summary>
 Returns true if the method is considered in its expanded param array form.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MemberResolutionResult`1">
	<summary>
 Represents the results of overload resolution for a single method.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForEachStatementInfo.#ctor(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.PropertySymbol,Roslyn.Compilers.VisualBasic.MethodSymbol)">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.ForEachStatementInfo"/> structure.
 </summary>
	<param name="getEnumeratorMethod">The GetEnumerator method.</param>
	<param name="moveNextMethod">The MoveNext method.</param>
	<param name="currentProperty">The Current property.</param>
	<param name="disposeMethod">The Dispose method.</param>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForEachStatementInfo.GetEnumeratorMethod">
	<summary>
 Gets the "GetEnumerator" method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForEachStatementInfo.MoveNextMethod">
	<summary>
 Gets the "MoveNext" method.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForEachStatementInfo.CurrentProperty">
	<summary>
 Gets the "Current" property.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ForEachStatementInfo.DisposeMethod">
	<summary>
 Gets the "Dispose" method.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ForEachStatementInfo">
	<summary>
  Structure containing all semantic information about a for each statement.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.EmitResult">
	<summary> 
 The result of the Compilation Emit operation. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ReflectionEmitResult">
	<summary> 
 The result of emitting a compilation to a dynamic module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CompilationReference.Compilation">
	<summary>
 Returns the referenced <see cref="P:Roslyn.Compilers.VisualBasic.CompilationReference.Compilation"/>.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CompilationReference.#ctor(Roslyn.Compilers.VisualBasic.Compilation,System.String,System.Boolean)">
	<summary>
 Create a metadata reference to a compilation.
 </summary>
	<param name="compilation">The compilation to reference.</param>
	<param name="embedInteropTypes">Should interop types be embedded in the created assembly?</param>
	<param name="alias">A namespace alias for this reference.</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.CompilationReference">
	<summary>
 Represents a reference to another Visual Basic compilation. 
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_lazyAssemblySymbol">
	<summary>
 The SourceAssemblySymbol for this compilation. Do not access directly, use Assembly
 property instead. This field is lazily initialized by AssemblyManager,
 AssemblyManager.CacheLockObject must be locked while AssemblyManager "calculates" the
 value and assigns it, several threads must not perform duplicate "calculation"
 simultaneously.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_Options">
	<summary>
 The options passed to the constructor of the Compilation
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_lazyReferencedAssembliesMap">
	<summary>
 A map from a metadata reference to an AssemblySymbol used for it.
 Do not access directly, use ReferencedAssembliesMap property instead.
 This field is lazily initialized by AssemblyManager when it creates
 SourceAssemblySymbol, AssemblyManager.CacheLockObject must be locked while
 AssemblyManager "calculates" the value and assigns it, several threads
 must not perform duplicate "calculation" simultaneously.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_lazyReferencedModulesMap">
	<summary>
 A map from a net-module metadata reference to a ModuleSymbol used for it.
 The ModuleSymbol is one of the modules contained in m_AssemblySymbol.Modules list.
 Do not access directly, use ReferencedModulesMap property instead.
 This field is lazily initialized by AssemblyManager when it creates
 SourceAssemblySymbol, AssemblyManager.CacheLockObject must be locked while
 AssemblyManager "calculates" the value and assigns it, several threads
 must not perform duplicate "calculation" simultaneously.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_lazyGlobalNamespace">
	<summary>
 The global namespace symbol. Lazily populated on first access.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_syntaxTrees">
	<summary>
 The syntax trees explicitly given to the compilation at creation, in ordinal order.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_lazyAllSyntaxTrees">
	<summary>
 The syntax trees of this compilation plus all 'hidden' trees
 added to the compilation by compiler, e.g. Vb Core Runtime.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_rootNamespaces">
	<summary>
 A map between syntax trees and the root declarations in the declaration table.
 Incrementally updated between compilation versions when source changes are made.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Compilation.EmbeddedTreeAndDeclaration">
	<summary>
 A SyntaxTree and the associated RootSingleNamespaceDeclaration for an embedded
 syntax tree in the Compilation. Unlike the entries in m_rootNamespaces, the
 SyntaxTree here is lazy since the tree cannot be evaluated until the references
 have been resolved (as part of binding the source module), and at that point, the
 SyntaxTree may be Nothing if the embedded tree is not needed for the Compilation.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_lazyAssemblyManagerDiagnostics">
	<summary>
 reference through AssemblyManagerDiagnostics
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_declarationTable">
	<summary>
 The declaration table that holds onto declarations from source. Incrementally updated
 between compilation versions when source changes are made.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_anonymousTypeManager">
	<summary>
 Manages anonymous types declared in this compilation. Unifies types that are structurally equivalent.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_lazyEmbeddedSymbolManager">
	<summary>
 Manages automatically embedded content.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Compilation.m_lazyEntryPoint">
	<summary>
 Contains the main method of this assembly, if there is one.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.Create(System.String,Roslyn.Compilers.VisualBasic.CompilationOptions,System.Collections.Generic.IEnumerable{Roslyn.Compilers.VisualBasic.SyntaxTree},System.Collections.Generic.IEnumerable{Roslyn.Compilers.MetadataReference},Roslyn.Compilers.FileResolver,Roslyn.Compilers.MetadataFileProvider)">
	<summary>
 Create a new compilation from scratch.
 </summary>
	<param name="outputName">The name of the compilation, file name and extension.</param>
	<param name="options">The compiler options to use.</param>
	<param name="syntaxTrees">The syntax trees with the source code for the new compilation.</param>
	<param name="references">The references for the new compilation.</param>
	<param name="fileResolver">Resolves file references for the compilation.</param>
	<param name="metadataFileProvider">Translates a resolved assembly reference path to a path to the file that can be opened by the compiler.</param>
	<returns>A new compilation.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.CreateSubmission(System.String,Roslyn.Compilers.VisualBasic.CompilationOptions,Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.VisualBasic.Compilation,System.Collections.Generic.IEnumerable{Roslyn.Compilers.MetadataReference},Roslyn.Compilers.FileResolver,Roslyn.Compilers.MetadataFileProvider,System.Type,System.Type)">
	<summary>
 Creates a new compilation that can be used in scripting.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.Clone">
	<summary>
 Create a duplicate of this compilation with different symbol instances
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.WithPreviousSubmission(Roslyn.Compilers.VisualBasic.Compilation)">
	<summary>
 Returns a new compilation with the given compilation set as the previous submission.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.GetSubmissionResultType(System.Boolean@)">
	<summary>
 Returns the type of the submission return value.
 </summary>
	<param name="hasValue">
 Whether the submission is considered to have a value.
 This information can be used for example in a REPL implementation to determine whether to print out the result of a submission execution.
 </param>
	<returns>
 Returns a static type of the expression of the last expression or call statement if there is any,
 a symbol for <see cref="T:System.Void"/> otherwise.
 </returns>
	<remarks>
 Note that the return type is System.Void for both compilations "System.Console.WriteLine()" and "?System.Console.WriteLine()",
 and <paramref name="hasValue"/> is <c>False</c> for the former and <c>True</c> for the latter.
 </remarks>
	<exception cref="T:System.InvalidOperationException">The compilation doesn't represent a submission (<see cref="P:Roslyn.Compilers.Common.CommonCompilation.IsSubmission"/> return false).</exception>
</member><member name="P:Roslyn.Compilers.VisualBasic.Compilation.SyntaxTrees">
	<summary>
 Get a read-only list of the syntax trees that this compilation was created with.
 The ordering of the trees is arbitrary and may be different than the order the
 trees were supplied to the compilation.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Compilation.AllSyntaxTrees">
	<summary>
 Get a read-only list of the syntax trees that this compilation was created with PLUS
 the trees that were automatically added to it, i.e. Vb Core Runtime tree.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.ContainsSyntaxTree(Roslyn.Compilers.VisualBasic.SyntaxTree)">
	<summary>
 Is the passed in syntax tree in this compilation?
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.IncludeInternalXmlHelper">
	<summary>
 Returns True if the set of references contains those assemblies needed for XML
 literals (specifically System.Core.dll, System.Xml.dll, and System.Xml.Linq.dll).
 If those assemblies are included, we should include the InternalXmlHelper
 SyntaxTree in the Compilation so the helper methods are available for binding XML.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.CompareSourceLocations(Roslyn.Compilers.Common.CommonLocation,Roslyn.Compilers.Common.CommonLocation)">
	<summary>
 Compare two source locations, using their containing trees, and then by Span.First within a tree.
 Can be used to get a total ordering on declarations, for example.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.GetReferencedAssemblySymbol(Roslyn.Compilers.MetadataReference)">
	<summary>
 Gets the AssemblySymbol that represents the assembly that was references with the given reference. If the reference
 was a Module reference, then this assembly is returned.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.GetReferencedModuleSymbol(Roslyn.Compilers.MetadataReference)">
	<summary>
 Gets the ModuleSymbol that represents an added metadata module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Compilation.Assembly">
	<summary>
 Gets the AssemblySymbol that represents the assembly being created.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Compilation.SourceModule">
	<summary>
 Get a ModuleSymbol that refers to the module being created by compiling all of the code. By
 getting the GlobalNamespace property of that module, all of the namespace and types defined in source code
 can be obtained.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Compilation.GlobalNamespace">
	<summary>
 Gets the merged root namespace that contains all namespaces and types defined in source code or in
 referenced metadata, merged into a single namespace hierarchy. This namespace hierarchy is how the compiler
 binds types that are referenced in code.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.GetCompilationNamespace(Roslyn.Compilers.Common.INamespaceSymbol)">
	<summary>
 Given a namespace symbol, returns the corresponding namespace symbol with Compilation extent
 that refers to that namespace in this compilation. Returns Nothing if there is no corresponding
 namespace. This should not occur if the namespace symbol came from an assembly referenced by this
 compilation.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Compilation.MemberImports">
	<summary>
 Returns the list of member imports that apply to all syntax trees in this compilation.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Compilation.AliasImports">
	<summary>
 Returns the list of alias imports that apply to all syntax trees in this compilation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.ClassifyConversion(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Determine what kind of conversion, if any, there is between the types
 "source" and "destination".
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Compilation.ScriptClass">
	<summary>
 A symbol representing the implicit Script class. This is null if the class is not
 defined in the compilation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.BindScriptClass">
	<summary>
 Resolves a symbol that represents script container (Script class).
 Uses the full name of the container class stored in <see cref="P:CommonCompilationOptions.ScriptClassName"/>  to find the symbol.
 </summary>
	<returns>
 The Script class symbol or null if it is not defined.
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.GetSpecialType(Roslyn.Compilers.SpecialType)">
	<summary>
 Get symbol for predefined type from Cor Library referenced by this compilation.
 </summary>
	<param name="typeId"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.GetTypeByMetadataName(System.String)">
	<summary>
 Lookup a type within the compilation's assembly and all referenced assemblies
 using its canonical CLR metadata name (names are compared case-sensitively).
 </summary>
	<param name="metadataName">
	</param>
	<returns>
 Symbol for the type or null if type cannot be found or is ambiguous.
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.GetSemanticModel(Roslyn.Compilers.VisualBasic.SyntaxTree)">
	<summary>
 Get a fresh SemanticModel.  Note that each invocation gets a fresh SemanticModel, each of
 which has a cache.  Therefore, one effectively clears the cache by discarding the
 SemanticModel.
</summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.GetDiagnostics(System.Threading.CancellationToken)">
	<summary>
 Get all diagnostics for the entire compilation. This includes diagnostics from parsing, declarations, and
 the bodies of methods. Getting all the diagnostics is potentially a length operations, as it requires parsing and
 compiling all the code. The set of diagnostics is not caches, so each call to this method will recompile all
 methods.
 </summary>
	<param name="cancellationToken">Cancellation token to allow cancelling the operation.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.GetParseDiagnostics(System.Threading.CancellationToken)">
	<summary>
 Get parse diagnostics for the entire compilation. This includes diagnostics from parsing BUT NOT from declarations and
 the bodies of methods or initializers. The set of parse diagnostics is cached, so calling this method a second time
 should be fast.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.GetDeclarationDiagnostics(System.Threading.CancellationToken)">
	<summary>
 Get parse and declarations diagnostics for the entire compilation. This includes diagnostics from parsing, declarations, BUT NOT
 the bodies of methods or initializers. The set of declaration diagnostics is cached, so calling this method a second time
 should be fast.
 </summary>
	<param name="cancellationToken">Cancellation token to allow cancelling the operation.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.GetDiagnostics(Roslyn.Compilers.CompilationStage,System.Threading.CancellationToken)">
	<summary>
 Get all errors in the compilation, up through the given compilation stage. Note that this may
 require significant work by the compiler, as all source code must be compiled to the given
 level in order to get the errors. Errors on Options should be inspected by the user prior to constructing the compilation.
 </summary>
	<returns>
 Returns all errors. The errors are not sorted in any particular order, and the client
 should sort the errors as desired.
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.Emit(System.IO.Stream,System.String,System.String,System.IO.Stream,System.IO.Stream,System.Threading.CancellationToken,System.IO.Stream,System.Collections.Generic.IEnumerable{Roslyn.Compilers.ResourceDescription})">
	<summary>
 Attempts to emit the assembly to the given stream. If there are
 compilation errors, false is returned. In this case, some bytes
 might have been written to the stream. The compilation errors can be
 obtained by called GetDiagnostics(CompilationStage.Emit). If true is
 returned, the compilation proceeded without error and a valid
 assembly was written to the stream.
 </summary>
	<param name="outputStream">Stream to which the compilation will be written.</param>
	<param name="outputName">Name of the compilation: file name and extension.  Null to use the existing output name.
 CAUTION: If this is set to a (non-null) value other than the existing compilation output name, then internals-visible-to
 and assembly references may not work as expected.  In particular, things that were visible at bind time, based on the
 name of the compilation, may not be visible at runtime and vice-versa.
 </param>
	<param name="pdbFileName">The name of the PDB file - embedded in the output.  Null to infer from the stream or the compilation.
 Ignored unless pdbStream is non-null.
 </param>
	<param name="pdbStream">Stream to which the compilation's debug info will be written.  Null to forego PDB generation.</param>
	<param name="xmlDocStream">Stream to which the compilation's XML documentation will be written.  Null to forego XML generation.</param>
	<param name="cancellationToken">To cancel the emit process.</param>
	<param name="win32ResourcesInRESFormat">Stream from which the compilation's Win32 resources will be read (in RES format).
 Null to indicate that there are none.</param>
	<param name="manifestResources">List of the compilation's managed resources.  Null to indicate that there are none.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.Emit(System.String,System.String,System.String,System.Threading.CancellationToken,System.String,System.Collections.Generic.IEnumerable{Roslyn.Compilers.ResourceDescription})">
	<summary>
 Attempts to emit the assembly to the given stream. If there are
 compilation errors, false is returned. In this case, some bytes
 might have been written to the stream. The compilation errors can be
 obtained by called GetDiagnostics(CompilationStage.Emit). If true is
 returned, the compilation proceeded without error and a valid
 assembly was written to the stream.
 </summary>
	<param name="outputPath">Path of the file to which the compilation will be written.</param>
	<param name="pdbPath">Path of the file to which the compilation's debug info will be written.
 Also embedded in the output file.  Null to forego PDB generation.
 </param>
	<param name="xmlDocPath">Path of the file to which the compilation's XML documentation will be written.  Null to forego XML generation.</param>
	<param name="cancellationToken">To cancel the emit process.</param>
	<param name="win32ResourcesInRESFormatPath">Path of the file from which the compilation's Win32 resources will be read (in RES format).
 Null to indicate that there are none.</param>
	<param name="manifestResources">List of the compilation's managed resources.  Null to indicate that there are none.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.EmitMetadataOnly(System.IO.Stream,System.String,System.IO.Stream,System.Threading.CancellationToken)">
	<summary>
 Attempts to emit just the metadata parts of the compilation, without compiling any executable code
 (method bodies). No debug info can be produced.
 </summary>
	<param name="metadataStream">Stream to which the compilation's metadata will be written.</param>
	<param name="outputName">Name of the compilation: file name and extension.  Null to use the existing output name.
 CAUTION: If this is set to a (non-null) value other than the existing compilation output name, then internals-visible-to
 and assembly references may not work as expected.  In particular, things that were visible at bind time, based on the
 name of the compilation, may not be visible at runtime and vice-versa.
 </param>
	<param name="xmlDocStream">Stream to which the compilation's XML documentation will be written.  Null to forego XML generation.</param>
	<param name="cancellationToken">To cancel the emit process.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.Emit(System.Reflection.Emit.ModuleBuilder,Roslyn.Compilers.IAssemblyLoader,System.Func{Roslyn.Compilers.VisualBasic.AssemblySymbol,Roslyn.Compilers.AssemblyIdentity},System.Threading.CancellationToken)">
	<summary>
 Emits the compilation into given <see cref="T:System.Reflection.Emit.ModuleBuilder"/>  using Reflection.Emit APIs.
 </summary>
	<param name="moduleBuilder">
 The module builder to add the types into. Can be reused for multiple compilation units.
 </param>
	<param name="assemblyLoader"> Loads an assembly given an <see cref="T:Roslyn.Compilers.AssemblyIdentity"/>.
 This callback is used for loading assemblies referenced by the compilation.
 <see cref="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)"/> is used if not specified.
 </param>
	<param name="assemblySymbolMapper">
 Applied when converting assembly symbols to assembly references. <see cref="T:Roslyn.Compilers.VisualBasic.AssemblySymbol"/> is mapped to its <see cref="P:Roslyn.Compilers.VisualBasic.AssemblySymbol.Identity"/> by default.
 </param>
	<param name="cancellationToken">
 Can be used to cancel the emit process.
 </param>
	<returns>
 An instance of <see cref="T:Roslyn.Compilers.VisualBasic.ReflectionEmitResult"/>  that indicates whether or not the call succeeded and includes the list of errors and the entry point if there is any.
 </returns>
	<remarks>
 Reflection.Emit doesn't support all metadata constructs. If an unsupported construct is encountered a metadata writer that procudes uncollectible code is used instead.
 This is indicated by  <see cref="P:CommonReflectionEmitResult.IsUncollectible"/>  flag on the result. Reusing <see cref="T:System.Reflection.Emit.ModuleBuilder"/>
 may be beneficial in certain scenarios. For example, when emitting a sequence of code snippets one at a time (like in REPL). All the snippets can be compiled
 into a single module as long as the types being emitted have unique names. Reusing a single module/assembly reduces memory overhead. On the other hand,
 collectible assemblies are units of collection. Defining too many unrelated types in a single assemly might prevent the unused types to be collected.

 No need to provide a name override when using Reflection.Emit, since the assembly already exists.
 </remarks>
	<exception cref="T:System.InvalidOperationException">Referenced assembly can't be resolved.</exception>
</member><member name="T:Roslyn.Compilers.VisualBasic.Compilation">
	<summary>
 The Compilation object is an immutable representation of a single invocation of the
 compiler. Although immutable, a Compilation is also on-demand, in that a compilation can be
 created quickly, but will that compiler parts or all of the code in order to respond to
 method or properties. Also, a compilation can produce a new compilation with a small change
 from the current compilation. This is, in many cases, more efficient than creating a new
 compilation from scratch, as the new compilation can share information from the old
 compilation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.MethodCompiler.GetCompileDiagnostics(Roslyn.Compilers.VisualBasic.Compilation,Roslyn.Compilers.VisualBasic.NamespaceSymbol,Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.DiagnosticBag,System.Boolean,System.Threading.CancellationToken)">
	<summary>
 Completes binding and performs analysis of bound trees for the purpose of obtaining diagnostics.
 
 NOTE: This method does not perform lowering/rewriting/emit. 
       Errors from those stages require complete compile, 
       but generally are not interesting during editing.
 
 NOTE: the bound tree produced by this method are not stored anywhere
       and immediately lost after diagnostics of a particular tree is done.
       
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.MethodCompiler.CompileMethodBodies(Roslyn.Compilers.VisualBasic.Compilation,Roslyn.Compilers.VisualBasic.Emit.Module,System.Boolean,Roslyn.Compilers.DiagnosticBag,System.Threading.CancellationToken)">
	<summary>
 Compiles given compilation into provided module.
 
 NOTE: it is ok for moduleBeingBuilt to be Nothing. 
       In such case the only results of this method would be diagnostics for complete compile.
 
 NOTE: the bound/lowered trees produced by this method are not stored anywhere and
       immediately lost after obtaining method bodies and diagnostics for a particular
       tree.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.MethodCompiler.DetectAndReportCyclesInConstructorCalls(System.Collections.Generic.Dictionary{Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.MethodSymbol},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Detects cycles in constructor invocations based on the 'constructor-calls-constructor' 
 map provided in 'constructorCallMap', reports errors if found.
 
 NOTE: 'constructorCallMap' is being mutated by this method
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.MethodCompiler.ReportConstructorCycles(System.Int32,System.Int32,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.MethodSymbol},Roslyn.Compilers.DiagnosticBag)">
	<summary> All the constructors in the cycle will be reported </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.MethodCompiler.CompileMethod(Roslyn.Compilers.VisualBasic.MethodSymbol,System.Predicate{Roslyn.Compilers.VisualBasic.Symbol},Roslyn.Compilers.VisualBasic.TypeCompilationState,Roslyn.Compilers.VisualBasic.Binder.ProcessedFieldOrPropertyInitializers,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.SynthesizedSubmissionFields,Roslyn.Compilers.VisualBasic.MethodSymbol@)">
	<summary>
 Compiles the method.
 </summary>
	<param name="referencedConstructor">
 If the method being compiled is a constructor, CompileMethod returns in this parameter 
 the symbol of the constructor called from the one being compiled either explicitly or implicitly. 
 For structure constructors calling parameterless constructor returns the synthesized constructor symbol.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.MethodCompiler.CreateSyntheticWithEventOverridesIfNeeded(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.HandledEvent},Roslyn.Compilers.VisualBasic.TypeCompilationState,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.SynthesizedSubmissionFields)">
	<summary> 
 If any of the "Handles" in the list have synthetic WithEvent override
 as a container, then this method will (if not done already) inject 
 property/accessors symbol into the emit module and assign bodies to the accessors.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Compilation.MethodCompiler.TryGetMethodCalledInBoundExpressionStatement(Roslyn.Compilers.VisualBasic.BoundExpressionStatement)">
	<summary> 
 Assuming the statement is a constructor call wrapped in bound expression 
 statement, get the method symbol being called 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.BoundNodeSummary">
	<summary>
 This structure holds the relevant bound node information relating to a particular syntax
 node, used temporarily for GetSemanticInfo and similar APIs. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CommandLineParser.ParseConditionalCompilationSymbols(System.String,System.Collections.Generic.List{Roslyn.Compilers.DiagnosticInfo},System.Collections.Generic.IDictionary{System.String,System.Object})">
	<summary>
 Given the string of conditional compilation symbols from the project system, parse them into an IDictionary
 ready to be given to the compilation.
 </summary>
	<param name="symbolList">
 The conditional compilation string. This takes the form of a comma delimited list
 of NAME=Value pairs, where Value may be a quoted string or integer.
 </param>
	<param name="symbols">
 Existing symbols. Symbols parsed from <paramref name="symbolList"/> are added into this dictionary. 
 If not specified a new dictionary is created, filled with parsed symbols and returned.
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.CommandLineParser.ParsePlatform(System.String,System.String,System.Collections.Generic.List{Roslyn.Compilers.DiagnosticInfo})">
	<summary>
 Parses the given platform option. Legal strings are "anycpu", "x64", "x86", "itanium", "anycpu32bitpreferred", "arm".
 In case an invalid value was passed, anycpu is returned.
 </summary>
	<param name="value">The value for platform.</param>
	<param name="errors">The error bag.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.CommandLineParser.ParseFileAlignment(System.String,System.String,System.Collections.Generic.List{Roslyn.Compilers.DiagnosticInfo})">
	<summary>
 Parses the file alignment option.
 In case an invalid value was passed, nothing is returned.
 </summary>
	<param name="name">The name of the option.</param>
	<param name="value">The value for the option.</param>
	<param name="errors">The error bag.</param><returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.CommandLineParser.ParseBaseAddress(System.String,System.String,System.Collections.Generic.List{Roslyn.Compilers.DiagnosticInfo})">
	<summary>
 Parses the base address option.
 In case an invalid value was passed, nothing is returned.
 </summary>
	<param name="name">The name of the option.</param>
	<param name="value">The value for the option.</param>
	<param name="errors">The error bag.</param><returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.CommandLineParser.ParseWarnings(System.String,System.String,System.Collections.Generic.List{Roslyn.Compilers.DiagnosticInfo})">
	<summary>
 Parses the wanring option.
 </summary>
	<param name="name">The name of the option.</param>
	<param name="value">The value for the option.</param>
	<param name="errors">The error bag.</param><returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.CommandLineCompiler.GetOutputFileNameOrFallback">
	<summary>
 In VB, if the output file name isn't specified explicitly, then it is derived from the name of the
 first input file.
 </summary>
	<remarks>
 http://msdn.microsoft.com/en-us/library/std9609e(v=vs.110)
 Specify the full name and extension of the file to create. If you do not, the .exe file takes 
 its name from the source-code file containing the Sub Main procedure, and the .dll file takes
 its name from the first source-code file.
 
 However, vbc.cpp has: 
 <![CDATA[
   // Calculate the output name and directory
   dwCharCount = GetFullPathName(pszOut ? pszOut : g_strFirstFile, &wszFileName);
 ]]>
	</remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.CodeGen.StackScheduler.Rewriter">
	<summary>
 Rewrites the tree to account for destructive nature of stack local reads.
 
 Typically, last read stays as-is and local is destroyed by the read.
 Intermediate reads are rewritten as Dups -
 
       NotLastUse(X_stackLocal) ===&gt; NotLastUse(Dup)
       LastUse(X_stackLocal) ===&gt; LastUse(X_stackLocal)
 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.StackScheduler.LocalDefUseSpan.ConflictsWith(Roslyn.Compilers.VisualBasic.CodeGen.StackScheduler.LocalDefUseSpan)">
	<summary>
 That said, when current and other use spans are regular spans we can have 
 only 2 conflict cases:
      [1, 3) conflicts with [0, 2) 
      [1, 3) conflicts with [2, 4) 
 
 specifically: 
      [1, 3) does not conflict with [0, 1) 
 
 NOTE: with regular spans, it is not possible to have start1 == start2 or 
 end1 == end2 since at the same node we can access only one real local.
 
 However at the same node we can access one or more dummy locals. So we can 
 have start1 == start2 and end1 == end2 scenarios, but only if the other span 
 is a span of a dummy. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.CodeGen.StackScheduler.LocalDefUseSpan">
	<summary>
 Represents a span of a value between definition and use. Start/end positions are 
 specified in terms of global node count as visited by StackOptimizer visitors. 
 (i.e. recursive walk not looking into constats)
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.CodeGen.StackScheduler.LocalDefUseInfo.StackAtDeclaration">
	<summary>
 stack at variable declaration, may be &gt; 0 in sequences.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.CodeGen.StackScheduler.LocalDefUseInfo.localDefs">
	<summary>
 value definitions for this variable
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.CodeGen.StackScheduler.LocalDefUseInfo.CannotSchedule">
	<summary>
 once this goes to true we are no longer interested in this variable.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.CodeGen.StackScheduler.LocalDefUseInfo">
	<summary>
 Represents a local and its Def-Use-Use chain
 
 NOTE: stack local reads are destructive to the locals so 
 if the read is not last one, it must be immediately followed by another definition. 
 For the rewriting purposes it is irrelevant if definition was created by a write or 
 a subsequent read. These cases are not ambiguous because when rewriting, definition 
 will match to a single node and  we always know if given node is reading or writing.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.CodeGen.StackScheduler.Analyzer.ExprContext">
	<summary>
 context of expression evaluation. 
 it will affect inference of stack behavior
 it will also affect when expressions can be dup-reused
     Example:
         Foo(x, ref x)     x cannot be duped as it is used in different context  
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.CodeGen.StackScheduler.Analyzer.empty">
	<summary>
 fake local that represents the eval stack. when we need to ensure that eval
 stack is not blocked by stack Locals, we record an access to empty.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.StackScheduler.Analyzer.ReuseOrVisit(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.CodeGen.StackScheduler.Analyzer.ExprContext)">
	<summary>
 Recursively rewrites the node or simply replaces it with a dup node
 if we have just seen exactly same node.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.StackScheduler.Analyzer.LhsUsesStackWhenAssignedTo(Roslyn.Compilers.VisualBasic.BoundNode,Roslyn.Compilers.VisualBasic.CodeGen.StackScheduler.Analyzer.ExprContext)">
	<summary>
 here we have a case of indirect assignment:  *t1 = expr;
 normally we would need to push t1 and that will cause spilling of t2
 
 TODO: an interesting case arises in unused x[i]++  and ++x[i] :
       we have trees that look like:

    t1 = &amp;(x[0])
    t2 = *t1
   *t1 = t2 + 1

    t1 = &amp;(x[0])
    t2 = *t1 + 1
   *t1 = t2

  in these cases, we could keep t2 on stack (dev10 does).
  we are dealing with exactly 2 locals and access them in strict order 
  t1, t2, t1, t2  and we are not using t2 after that.
  We may consider detecting exactly these cases and pretend that we do not need 
  to push either t1 or t2 in this case.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.StackScheduler.Analyzer.IsIndirectAssignment(Roslyn.Compilers.VisualBasic.BoundAssignmentOperator)">
	<summary>
 indirect assignment is assignment to a value referenced indirectly
 it may only happen if lhs is a reference (must be a parameter or a local)
       1) lhs is a reference (must be a parameter or a local)
       2) it is not a ref/out assignment where the reference itself would be assigned
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.StackScheduler.Analyzer.EnsureOnlyEvalStack">
	<summary>
 Ensures that there are no stack locals. It is done by accessing 
 virtual "empty" local that is at the bottom of all stack locals.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.CodeGen.StackScheduler.Analyzer">
	<summary>
 Analyses the tree trying to figure which locals may live on stack. It is 
 a fairly delicate process and must be very familiar with how CodeGen works. 
 It is essentially a part of CodeGen.
 
 NOTE: It is always safe to mark a local as not eligible as a stack local 
 so when situation gets complicated we just refuse to schedule and move on.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.CodeGen.Optimizer">
	<summary>
 Optimizer performs optimization of the bound tree performed before passing it to a codegen. Generally it may
 include several phases like stack scheduling of local variables, etc...
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.ShouldNoteProjectErrors">
	<summary>
 Tells if we should emit [Set/Clear]ProjectErrors when entering/leaving handlers
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.LabelFinder">
	<summary>
 tells if given node contains a label statement that defines given label symbol
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.EmitStringCompareAndBranch(Roslyn.Compilers.CodeGen.LocalDefinition,Roslyn.Compilers.ConstantValue,System.Object,System.Object[])">
	<summary>
 Delegate to emit string compare call and conditional branch based on the compare result.
 </summary>
	<param name="key">Key to compare</param>
	<param name="stringConstant">Case constant to compare the key against</param>
	<param name="targetLabel">Target label to branch to if key = stringConstant</param>
	<param name="arguments">Additional arguments for the delegate</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.GetLocal(Roslyn.Compilers.VisualBasic.BoundLocal)">
	<summary>
 Gets already declared and initialized local.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.AllocateTemp(Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Allocates a temp without identity.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.FreeTemp(Roslyn.Compilers.CodeGen.LocalDefinition)">
	<summary>
 Frees a temp without identity.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.FreeOptTemp(Roslyn.Compilers.CodeGen.LocalDefinition)">
	<summary>
 Frees an optional temp.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.CanUseCallOnRefTypeReceiver(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Used to decide if we need to emit call or callvirt.
 It basically checks if the receiver expression cannot be null, but it is not 100% precise. 
 There are cases where it really can be null, but we do not care.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.MayUseCallForStructMethod(Roslyn.Compilers.VisualBasic.MethodSymbol)">
	<summary>
 Used to decide if we need to emit 'call' or 'callvirt' for structure method.
 It basically checks if the method overrides any other and method's defining type
 is not a 'special' or 'special-by-ref' type. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.EmitVectorElementStore(Roslyn.Compilers.VisualBasic.ArrayTypeSymbol)">
	<summary>
 Emit an element store instruction for a single dimensional array.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.EmitArrayInitializers(Roslyn.Compilers.VisualBasic.ArrayTypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression})">
	<summary>
 Entry point to the array initialization.
 Assumes that we have newly created array on the stack.
 
 inits could be an array of values for a single dimensional array
 or an   array (of array)+  of values for a multidimensional case
 
 in either case it is expected that number of leaf values will match number 
 of elements in the array and nesting level should match the rank of the array.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.IndexDesc">
	<summary>
 To handle array initialization of arbitrary rank it is convenient to 
 approach multidimensional initialization as a recursively nested.
 
 ForAll{i, j, k} Init(i, j, k) ===&gt; 
 ForAll{i} ForAll{j, k} Init(i, j, k) ===&gt;
 ForAll{i} ForAll{j} ForAll{k} Init(i, j, k)
 
 This structure is used for capturing initializers of a given index and 
 the index value itself.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.EmitAllElementInitializersRecursive(Roslyn.Compilers.VisualBasic.ArrayTypeSymbol,System.Collections.Generic.List{Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.IndexDesc},System.Boolean)">
	<summary>
 Emits all initializers that match indices on the stack recursively.
 
 Example: 
  if array has [0..2, 0..3, 0..2] shape
  and we have {1, 2} indices on the stack
  initializers for 
              [1, 2, 0]
              [1, 2, 1]
              [1, 2, 2]
 
  will be emitted and the top index will be pushed off the stack 
  as at that point we would be completely done with emitting initializers 
  corresponding to that index.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.InitializerCountRecursive(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression})">
	<summary>
 Count of all initializers.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.ConstInitializerCountRecursive(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression})">
	<summary>
 Count of initializers that are constants.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.GetRawData(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression})">
	<summary>
 Produces a serialized blob of all constant initializers.
 Nonconstat initializers are matched with a zero of corresponding size.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.IsMultidimensionalInitializer(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression})">
	<summary>
 Check if it is a regular collection of expressions or there are nested initializers.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.EmitAddress(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.AddressKind)">
	<summary>
 Emits address as in &amp; 
 
 May introduce a temp which it will return. (otherwise returns null)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.EmitAddressOfTempClone(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Emits address of a temp.
 Used in cases where taking address directly is not possible 
 (typically because expression does not have a home)
 
 Will introduce a temp which it will return.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.HasHome(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Checks if expression represents directly or indirectly a value with its own home.
 In such cases it is possible to get a reference without loading into a temporary.
 
 This is a CLR concept which is weaker than VB's IsLValue.
 For example all locals are homed even if VB may consider some locals read-only.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.HasHome(Roslyn.Compilers.VisualBasic.BoundFieldAccess)">
	<summary>
 Special HasHome for fields. Fields have homes when they are writeable.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.AllowedToTakeRef(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.AddressKind)">
	<summary>
 Checks if it is allowed to take a writeable reference to expression according to VB rules.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.AllowedToTakeRef(Roslyn.Compilers.VisualBasic.BoundLocal)">
	<summary>
 Checks if it is allowed to take a writeable reference to expression according to VB rules.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.AllowedToTakeRef(Roslyn.Compilers.VisualBasic.BoundFieldAccess,Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.AddressKind)">
	<summary>
 Can take a reference.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.EmitReceiverRef(Roslyn.Compilers.VisualBasic.BoundExpression,System.Boolean,Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.AddressKind)">
	<summary>
 Emits receiver in a form that allows member accesses ( O or &amp; ). For verifiably
 reference types it is the actual reference. For generic types it is a address of the
 receiver with readonly intent. For the value types it is an address of the receiver.
 
 isAccessConstrained indicates that receiver is a target of a constrained callvirt
 in such case it is unnecessary to box a receier that is typed to a type parameter
 
 May introduce a temp which it will return. (otherwise returns null)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.EmitInstanceFieldAddress(Roslyn.Compilers.VisualBasic.BoundFieldAccess,Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator.AddressKind)">
	<summary>
 May introduce a temp which it will return. (otherwise returns null)
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator._tryStatementsNestingLevel">
	<summary> Keeps track on current nesting level of try statements </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.CodeGen.CodeGenerator._currentCatchBlock">
	<summary> Current enclosing Catch block if there is any. </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.UnboundLambda.IsSingleLine">
	<summary>
 Should this lambda be treated as a single line lambda?
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.UnboundLambda.IsFunctionLambda">
	<summary>
 Is this a function lambda
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.UnboundLambda.AllowRelaxationSemantics">
	<summary>
 Should delegate relaxation behavior be allowed for this lambda.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.UnboundLambda.InferReturnType(Roslyn.Compilers.VisualBasic.UnboundLambda.TargetSignature)">
	<summary>
 target.ReturnType is ignored and must be Void, only parameter types are taken into consideration.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.UnboundLambda.UnboundLambdaBindingCache">
	<summary>
 This class is used to cache various information about a lambda in the course of binding an expression/statement
 containing the lambda. Even though the members are public, they shouldn't be accessed directly by any code
 outside of the UnboundLambda class.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BoundWithStatement.ExpressionPlaceholder">
	<summary> Returns the placeholder used in this With statement to 
 substitute the expression in initial binding </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BoundWithStatement.DraftInitializers">
	<summary>
 A draft version of initializers which will be used in this With statement. 
 Initializers are expressinos which are used to capture expression in the current
 With statement; they can be empty in some cases like if the expression is a local 
 variable of value type.
 
 Note, the initializers returned by this property are 'draft' because they are 
 generated based on initial bound tree, the real initializers will be generated 
 in lowering based on lowered expression form.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BoundWithStatement.DraftPlaceholderSubstitute">
	<summary>
 A draft version of placeholder substitute which will be used in this With statement. 
 
 Note, the placeholder substitute returned by this property is 'draft' because it is
 generated based on initial bound tree, the real substitute will be generated in lowering 
 based on lowered expression form.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BoundRedimClause.IsPreserve">
	<summary> Whether or not the clause has 'Preserve' option </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundPropertyAccess.SetAccessKind(Roslyn.Compilers.VisualBasic.PropertyAccessKind)">
	<summary>
 Updates property access kind. To clear the access kind,
 'newAccessKind' should be Unknown. Otherwise, the current
 access kind should be Unknown or equal to 'newAccessKind'.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundNodeExtensions.GetBinderFromLambda(Roslyn.Compilers.VisualBasic.BoundNode)">
	<summary>
 Get the Binder from a lambda node, or return Nothing if this isn't 
 a lambda node.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BoundNode.WasCompilerGenerated">
	<summary>
 The node should not be treated as a direct semantical representation of the syntax it is associated with. 
 Some examples: 
 - implicit call for base constructor is associated with the constructor syntax.
 - code in compiler generated constructor is associated with the type declaration.
 
 Nodes marked this way are likely to be skipped by SemanticModel, Sequence Point rewriter, etc.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BoundMethodOrPropertyGroup.MemberName">
	<summary>
 returns name used to lookup the method/property in the group.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BoundMethodOrPropertyGroup.ContainerOfFirstInGroup">
	<summary>
 returns the container of the first member in the group.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundLateMemberAccess.SetAccessKind(Roslyn.Compilers.VisualBasic.LateboundAccessKind)">
	<summary>
 Updates property access kind. To clear the access kind,
 'newAccessKind' should be Unknown. Otherwise, the current
 access kind should be Unknown or equal to 'newAccessKind'.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundLateInvocation.SetAccessKind(Roslyn.Compilers.VisualBasic.LateboundAccessKind)">
	<summary>
 Updates access kind. To clear the access kind,
 'newAccessKind' should be Unknown. Otherwise, the current
 access kind should be Unknown or equal to 'newAccessKind'.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BoundLambda.IsSingleLine">
	<summary>
 Should this lambda be treated as a single line lambda?
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.IsInstanceReference(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary> Returns True if the node specified is one of Me/MyClass/MyBase </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.IsPropertyOrXmlPropertyAccess(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Returns True if the expression is a property access expression,
 either directly or wrapped in an XML member access expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.IsPropertySupportingAssignment(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Does this node represent a property with Set accessor and AccessKind not yet bound to Get?
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.IsSupportingAssignment(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Does this node represent a property or latebound access not yet determied to be Get?
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.GetAccessKind(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Get the access kind from property access expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.SetAccessKind(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.PropertyAccessKind)">
	<summary>
 Sets the access kind on the property access expression. To clear the access
 kind, 'newAccessKind' should be Unknown. Otherwise, the current property
 access kind should be Unknown or equal to 'newAccessKind'.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.Update(Roslyn.Compilers.VisualBasic.BoundXmlMemberAccess,Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Return a BoundXmlMemberAccess node with
 updated MemberAccess property.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.IsIntegerZeroLiteral(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Return true if and only if an expression is a integral literal with a value of zero.
 Non-literal constant value zero does not qualify.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.IsIntegerZeroLiteral(Roslyn.Compilers.VisualBasic.BoundLiteral)">
	<summary>
 Return true if and only if an expression is a integral literal with a value of zero.
 Non-literal constant value zero does not qualify.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.IsDefaultValueConstant(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Checks if the expression is a default value (0 or Nothing)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.IsTrueConstant(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Checks if the expression is a constant and that constant is False
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.IsFalseConstant(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Checks if the expression is a constant and that constant is True
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.IsNegativeIntegerConstant(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Checks if the expression is a negative integer constant value.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.GetIntegerConstantValue(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Return the integer constant value (if any) from a BoundExpression
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.IsNothingLiteral(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Return true if and only if an expression is a semantical Nothing literal, 
 which is defined as follows (the definition is consistent with 
 definition used by Dev10 compiler):
 - A Nothing literal according to the language grammar, or
 - A parenthesized expression, for which IsNothingLiteral returns true, or
 - An expression of type Object with constant value == Nothing.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.IsNothingLiteral(Roslyn.Compilers.VisualBasic.BoundLiteral)">
	<summary>
 Return true if target BoundLiteral represents Nothing literal as defined by the language grammar.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.IsStrictNothingLiteral(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Return true if and only if an expression represents optionally 
 parenthesized Nothing literal as defined by the language grammar. 
 I.e. implicit conversions are Ok, but explicit conversions aren't.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundExpressionExtensions.TypeArguments(Roslyn.Compilers.VisualBasic.BoundMethodOrPropertyGroup)">
	<summary>
 returns type arguments or Nothing if group does not have type arguments.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BoundExpression.IsLValue">
	<summary>
 Does expression refer to a physical memory location that can be modified?
 
 Note, Dev10 uses SXF_LVALUE flag on bound nodes to represent this concept.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.BoundDoLoopStatement.ConditionIsTop">
	<summary>
 Gets a value indicating whether this do loop is a DoTopLoop or not. In syntax error cases
 where both conditions are used, priority is given to the first one.
 It's recommended to consistently use this property instead of checking the TopConditionOpt and BottomConditionOpt
 directly.
 </summary>
	<value>
		<c>true</c> if this loop is a DoTopLoop; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.BoundDoLoopStatement.ConditionIsUntil">
	<summary>
 Gets a value indicating whether the condition of this do loop is "until" or not. In syntax error cases
 where both conditions are used, priority is given to the first one.
 It's recommended to consistently use this property instead of checking TopConditionIsUntil and BottomConditionIsUntil
 directly.
 </summary>
	<value>
		<c>true</c> if this loop is a DoTopLoop; otherwise, <c>false</c>.
 </value>
</member><member name="P:Roslyn.Compilers.VisualBasic.BoundDoLoopStatement.ConditionOpt">
	<summary>
 Gets the optional bound condition expression for this do loop statement. In syntax error cases
 where both conditions are used, priority is given to the first one.
 It's recommended to consistently use this property instead of accessing TopConditionOpt or BottomConditionOpt
 directly.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundAddressOfOperator.GetDelegateResolutionResult(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder.DelegateResolutionResult@)">
	<summary>
 Gets the <see>Binder.DelegateResolutionResult</see> for the given targetType. 
 </summary>
	<remarks>
 One needs to call <see>GetConversionClassification</see> before in order to fill the cache.
 </remarks>
	<param name="targetType">Type of the target.</param>
	<returns>The <see cref="T:Roslyn.Compilers.VisualBasic.Binder.DelegateResolutionResult">Binder.DelegateResolutionResult</see> for the conversion 
 of the AddressOf operand to the target type
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.BoundAddressOfOperator.GetConversionClassification(Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Gets the conversion classification.
 </summary>
	<param name="targetType">The destination type to convert to.</param>
</member><member name="F:Roslyn.Compilers.VisualBasic.UsingInfo.PlaceholderInfo">
	<summary>
 A dictionary holding a placeholder, a conversion from placeholder to IDisposable and a condition if placeholder IsNot nothing
 per type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.UsingInfo.UsingStatementSyntax">
	<summary>
 Syntax node for the using block.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.UsingInfo.#ctor(Roslyn.Compilers.VisualBasic.UsingBlockSyntax,System.Collections.Generic.Dictionary{Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Utilities.ValueTuple{Roslyn.Compilers.VisualBasic.BoundRValuePlaceholder,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression}})">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.UsingInfo"/> class.
 </summary>
	<param name="usingStatementSyntax">The syntax node for the using block</param>
	<param name="placeholderInfo">A dictionary holding a placeholder, a conversion from placeholder to IDisposable and 
 a condition if placeholder IsNot nothing per type.</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.UsingInfo">
	<summary>
 Holds all information needed to rewrite a bound using block node.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.UsingBlockBinder">
	<summary>
 Binder used to bind using blocks. 
 It hosts the variables declared in the resource list (if they are declared).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedStringSwitchHashMethod.CreateAndAddToModule(Roslyn.Compilers.VisualBasic.Compilation,Roslyn.Compilers.VisualBasic.Emit.Module)">
	<summary>
 Generate synthesized string switch hash function and
 add it to the compiler generated PrivateImplementationDetails class
 </summary>
	<param name="comp"></param>
	<param name="moduleBeingBuilt"></param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.SynthesizedStringSwitchHashMethod.GetBoundMethodBody(Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.Binder@)">
	<summary>
 Construct a body for String Switch Hash Function
 </summary>
	<remarks>
 This method should be kept consistent with SwitchStringJumpTableEmitter.ComputeStringHash
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AnonymousTypeManager.AnonymousType_IEquatable_EqualsMethodSymbol.BuildConditionForField(Roslyn.Compilers.VisualBasic.AnonymousTypeManager.AnonymousTypePropertySymbol,Roslyn.Compilers.VisualBasic.BoundMeReference,Roslyn.Compilers.VisualBasic.BoundParameter,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.LocalSymbol,Roslyn.Compilers.VisualBasic.LocalSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary> 
 Builds a condition in the following form: 
 
 [preaction: localMyFieldBoxed = DirectCast(Me.field, System.Object)]
 [preaction: localOtherFieldBoxed = DirectCast(Other.field, System.Object)]
 IF(localMyFieldBoxed IsNot Nothing AndAlso localOtherFieldBoxed IsNot Nothing,
    localMyFieldBoxed.Equals(localOtherFieldBoxed),
    localMyFieldBoxed Is localOtherFieldBoxed
 ) 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SymbolsInProgress`1">
	<summary>
 This is used while computing the values of constant symbols.  Since they can depend on each other,
 we need to keep track of which ones we are currently computing in order to avoid (and report) cycles.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetUpperBoundNode(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Get the highest bound node in the tree associated with a particular syntax node.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetLowerBoundNode(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Get the lowest bound node in the tree associated with a particular syntax node. Lowest is defined as last
 in a pre-order traversal of the bound tree.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetBindableParent(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 If node has an immediate parent that is an expression or statement or attribute, return
 that (making sure it can be bound on its own). Otherwise return Nothing.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetBoundNodeSummary(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Get a summary of the bound nodes associated with a particular syntax nodes,
 and its parent. This is what the rest of the semantic model uses to determine
 what to return back.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetInvokeSummaryForRaiseEvent(Roslyn.Compilers.VisualBasic.RaiseEventStatementSyntax)">
	<summary>
 Gets a summary of the bound nodes associated with an underlying
 bound call node for a raiseevent statement.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.UnwrapRaiseEvent(Roslyn.Compilers.VisualBasic.BoundNode)">
	<summary>
 if "node" argument is a BoundRaiseEvent, returns its underlying boundcall instesd.
 Otherwise returns "node" unchanged.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.IsStandAloneStatement(Roslyn.Compilers.VisualBasic.StatementSyntax)">
	<summary>
 Return True if the statement can be bound by a Binder on its own.
 For example Catch statement cannot be bound on its own, only 
 as part of Try block. Similarly, Next statement cannot be bound on its own,
 only as part of For statement.
 
 Only handles statements that are in executable code.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetDeclarationDiagnostics(System.Threading.CancellationToken)">
	<summary>
 Get all the syntax and declaration errors within the syntax tree associated with this object. Does not get
 errors involving compiling method bodies or initializers.
 </summary>
	<param name="cancellationToken">A cancellation token that can be used to cancel the process of obtaining the
 diagnostics.</param>
	<remarks>The declaration errors for a syntax tree are cached. The first time this method is called, a ll
 declarations are analyzed for diagnostics. Calling this a second time will return the cached diagnostics.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetDiagnostics(System.Threading.CancellationToken)">
	<summary>
 Get all the errors within the syntax tree associated with this object. Includes errors involving compiling
 method bodies or initializers, in addition to the errors returned by GetDeclarationDiagnostics.
 </summary>
	<param name="cancellationToken">A cancellation token that can be used to cancel the process of obtaining the
 diagnostics.</param>
	<remarks>
 Because this method must semantically all method bodies and initializers to check for diagnostics, it may
 take a significant amount of time. Unlike GetDeclarationDiagnostics, diagnostics for method bodies and
 initializers are not cached, the any semantic information used to obtain the diagnostics is discarded.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.TypeStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a type declaration, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a type.</param>
	<returns>The type symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.EnumStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a enum declaration, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares an enum.</param>
	<returns>The type symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.NamespaceStatementSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a namespace declaration, get the corresponding type symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a namespace.</param>
	<returns>The namespace symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.MethodBaseSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a method, property, or event declaration, get the corresponding symbol.
 </summary>
	<param name="declarationSyntax">The syntax node that declares a method, property, or event.</param>
	<returns>The method, property, or event symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.ParameterSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a parameter declaration, get the corresponding parameter symbol.
 </summary>
	<param name="parameter">The syntax node that declares a parameter.</param>
	<returns>The parameter symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.AliasImportsClauseSyntax,System.Threading.CancellationToken)">
	<summary>
 Given an import clause get the corresponding symbol for the import alias that was introduced.
 </summary>
	<param name="declarationSyntax">The import statement syntax node.</param>
	<returns>The alias symbol that was declared or Nothing if no alias symbol was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.VisualBasic.TypeParameterSyntax,System.Threading.CancellationToken)">
	<summary>
 Given a type parameter declaration, get the corresponding type parameter symbol.
 </summary>
	<param name="typeParameter">The syntax node that declares a type parameter.</param>
	<returns>The type parameter symbol that was declared.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetForEachStatementInfoWorker(Roslyn.Compilers.VisualBasic.ForBlockSyntax)">
	<summary>
 Gets the semantic information of a for each statement.
 </summary>
	<param name="node">The for each syntax node.</param>
</member><member name="P:Roslyn.Compilers.VisualBasic.MemberSemanticModel.SyntaxTree">
	<summary> 
 The SyntaxTree that is bound
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetEnclosingBinder(Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxNode,System.Int32)">
	<summary>
 Get the correct enclosing binder for the given position, taking into account  
 block constructs and lambdas.
 </summary>
	<param name="memberBinder">Binder for the method body, lambda body, or field initializer. The
 returned binder will be nested inside the binder, or be this binder.</param>
	<param name="binderRoot">Syntax node that is the root of the construct associated with "memberBinder".</param>
	<param name="node">Syntax node that position is in.</param>
	<param name="position">Position we are finding the enclosing binder for.</param>
	<returns>The enclosing binder within "memberBinder" for the given position.</returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.InQueryInterior(Roslyn.Compilers.VisualBasic.SyntaxNode,System.Int32,Roslyn.Compilers.VisualBasic.Binder@)">
	<summary>
 If answer is True, the binder is returned via [binder] parameter.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.InAnonymousTypeInitializerInterior(Roslyn.Compilers.VisualBasic.SyntaxNode,System.Int32,Roslyn.Compilers.VisualBasic.Binder@)">
	<summary>
 If answer is True, the binder is returned via [binder] parameter.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetBoundNodes(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Get all bound nodes associated with a node, ordered from highest to lowest in the bound tree.
 Strictly speaking, the order is that of a pre-order traversal of the bound tree.
 As a side effect, caches nodes and binders.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.IsNonExpressionCollectionInitializer(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 A collection initializer syntax node is not always treated as a VB expression syntax node
 in case it's part of a CollectionInitializer (outer most or top level initializer).
 </summary>
	<param name="syntax">The syntax node to check.</param>
	<returns><c>True</c> if the syntax node represents an expression syntax, but it's not 
 an expression from the VB language point of view; otherwise <c>False</c>.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GuardedIncrementalBind(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Incrementally bind bindingRoot (which is always a non-lambda enclosed statement, or the
 root of this model). Side effect is to store nodes into the guarded node map.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.GetBindingRoot(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 In order that any expression level special binders are used, lambdas are fully resolved,
 and that any other binding context is correctly handled, we only use the binder to create bound
 nodes for:
   a) The root syntax of this semantic model (because there's nothing more outer to bind)
   b) A stand-alone statement is that is not inside a lambda.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.IncrementalBinder.GetBinder(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 We override GetBinder so that the BindStatement override is stil
 in effect on nested binders.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.IncrementalBinder.GetBinder(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 We override GetBinder so that the BindStatement override is stil
 in effect on nested binders.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MemberSemanticModel.IncrementalBinder">
	<summary>
 The incremental binder is used when binding statements. Whenever a statement
 is bound, it checks the bound node cache to see if that statement was bound, 
 and returns it instead of rebinding it. 
 
 FOr example, we might have:
    While x &gt; foo()
      y = y * x
      z = z + y
    End While
 
 We might first get semantic info about "z", and thus bind just the statement
 "z = z + y". Later, we might bind the entire While block. While binding the while
 block, we can reuse the binding we did of "z = z + y".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MemberSemanticModel.SemanticModelMapsBuilder.RecordNode(Roslyn.Compilers.VisualBasic.BoundNode,System.Boolean)">
	<summary>
 Should we record bound node mapping for this node? Generally, we ignore compiler generated, but optionally can
 allow.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MemberSemanticModel.SemanticModelMapsBuilder">
	<summary>
 Traverse a tree of bound nodes, and update the following maps inside the SemanticModel:
 
     guardedNodeMap  - a map from syntax node to bound nodes. Bound nodes are added in the order they are bound
                       traversing the tree, so they will be in order from upper to lower node.
 
     guardedQueryBindersMap - a map from query-specific syntax node to an array of binders used to
                              bind various children of the node.
 
     guardedAnonymousTypeBinderMap - a map from Anonymous Type initializer's FieldInitializerSyntax to
                                     Binder.AnonymousTypeFieldInitializerBinder used to bind its expression.
</summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MemberSemanticModel">
	<summary>
 Binding info for expressions and statements that are part of a member declaration.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SingleLookupResult">
	<summary> 
 Represents a result of lookup operation over a 0 or 1 symbol (as opposed to a scope).
 The typical use is to represent that a particular symbol is good/bad/unavailable.

For more explanation of Kind, Symbol, Error - see LookupResult.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LookupResult.SetFrom(Roslyn.Compilers.VisualBasic.SingleLookupResult)">
	<summary>
 Set current result according to another
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LookupResult.SetFrom(Roslyn.Compilers.VisualBasic.LookupResult)">
	<summary>
 Set current result according to another
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LookupResult.SetFrom(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Set current result according to a given symbol    
 </summary>
	<param name="s"></param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.LookupResult.CompareAccessibilityOfSymbolsConflictingInSameContainer(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Returns: negative value - when first lost, 0 - when neither lost, &gt; 0 - when second lost.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LookupResult.ResolveAmbiguityInTheSameNamespace(Roslyn.Compilers.VisualBasic.SingleLookupResult,Roslyn.Compilers.VisualBasic.ModuleSymbol)">
	<summary>
 Returns: negative value - when current lost, 0 - when neither lost, &gt; 0 - when other lost.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LookupResult.ResolveAmbiguityInTheSameNamespace(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.ModuleSymbol)">
	<summary>
 Returns: negative value - when first lost, 0 - when neither lost, &gt; 0 - when second lost.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LookupResult.ResolveAmbiguityBetweenTypeAndMergedNamespaceInTheSameNamespace(Roslyn.Compilers.VisualBasic.NamespaceSymbol,Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Returns: negative value - when namespace lost, 0 - when neither lost, &gt; 0 - when type lost.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LookupResult.ReplaceSymbol(Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Replace the symbol replaced with a new one, but the kind
 and diagnostics retained from the current result. Typically used when constructing
 a type from a symbols and type arguments.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LookupResult">
	<summary>
 A LookupResult summarizes the result of a name lookup, and allows combining name lookups
 from different scopes in an easy way.
 
 A LookupResult can be ONE OF:
    empty - nothing found.
    a non-accessible result - this kind of result means that search continues into further scopes of lower priority for
                      a viable result. An error is attached with the inaccessibility errors. Non-accessible results take priority over
                      non-viable results.
    a non-viable result - a result that that means that the search continues into further scopes of lower priority for
                          a viable or non-accessible result. An error is attached with the error that indicates
                          why the result is non-viable.
    a bad symbol that stops further lookup -  this kind of result prevents lookup into further scopes of lower priority.
                      a diagnostic is attached explaining why the symbol is bad.
    ambiguous symbols.- In this case, an AmbiguousSymbolDiagnostic diagnostic has the other symbols. 
    a good symbol, or set of good overloaded symbols - no diagnostic is attached in this case
 
 Occasionally, good or ambiguous results are referred to as "viable" results.
 
 Multiple symbols can be represented in a single LookupResult. Multiple symbols are ONLY USED for overloadable
 entities, such an methods or properties, and represent all the symbols that overload resolution needs to consider.
 When ambiguous symbols are encountered, a single representative symbols is returned, with an attached AmbiguousSymbolDiagnostic
 from which all the ambiguous symbols can be retrieved. This implies that Lookup operations that are restricted to namespaces
 and/or types always create a LookupResult with 0 or 1 symbol.
 
 Note that the class is poolable so its instances can be obtained from a pool via GetInstance.
 Also it is a good idea to call Free on instances after they no longer needed.
 
 The typical pattern is "caller allocates / caller frees" -
    
    Dim result = LookupResult.GetInstance()
  
    scope.Lookup(result, "foo")
    ... use result ...
         
    result.Clear()
    anotherScope.Lookup(result, "moo")
    ... use result ...
 
    result.Free()   'result and its content is invalid after this
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LookupOptions.Default">
	<summary>
 Consider all symbols, using normal accessibility rules.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LookupOptions.NamespacesOrTypesOnly">
	<summary>
 Consider only namespaces and types.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LookupOptions.LabelsOnly">
	<summary>
 Consider only labels. If this is not set, labels are not considered at all.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LookupOptions.MustBeInstance">
	<summary>
 Do not consider symbols that are shared members.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LookupOptions.MustNotBeInstance">
	<summary>
 Do not consider symbols that are instance members.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LookupOptions.MustNotBeReturnValueVariable">
	<summary>
 Do not consider the return value local variable.
 This is similar to the C# LookupOption.MustBeInvocableMember.
 
 The only non-invocable member in Visual Basic is the function return variable 
 (see language specification 10.1.1). If this flag is set, lookup will not 
 return the function return variable, but instead return the containing function or property,
 and any overloads thereof.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LookupOptions.NoBaseClassLookup">
	<summary>
 Do not do lookup in base classes (similar to how types in Imports are bound).
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.LookupOptions.IgnoreAccessibility">
	<summary>
 Ignore accessibility checking when determining if a symbol is a viable match.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LookupOptions.AllMethodsOfAnyArity">
	<summary>
 Consider methods of any arity (but still consider arity for other types of symbols).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LookupOptions.IgnoreExtensionMethods">
	<summary>
 Do not look for extension methods.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LookupOptions.UseBaseReferenceAccessibility">
	<summary>
 Ignore 'throughType' in accessibility checking. Used in checking accessibility of symbols accessed via 'MyBase'.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.LookupOptions.MustNotBeLocal">
	<summary>
 Do not consider locals symbols during lookup.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LookupOptions">
	<summary>
 Options that can be used to modify the symbol lookup mechanism. Multiple options can be combined together.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.InternalLookupOptions.EagerlyLookupExtensionMethods">
	<summary>
 Ensures that lookup eagerly looks for extension methods and merges them with 
 instance methods, if any. 
 
 If this flag is not set and lookup found viable instance method, it will not look 
 for extension methods that might be in scope. 
 
 It is not an error to combine this flag with LookupOptions.IgnoreExtensionMethods, 
 the LookupOptions.IgnoreExtensionMethods takes precedence. 
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.InternalLookupOptions.MethodsOnly">
	<summary>
 Consider only methods. Used by Query Expressions.
 
 11.21.2 Queryable Types
 When binding well-known method names, non-methods are ignored for the purpose of 
 multiple inheritance in interfaces and extension method binding, although shadowing 
 semantics still apply.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InternalLookupOptions">
	<summary>
 Internal options that can be used to modify the symbol lookup mechanism. 
 Multiple options can be combined together and with public LookupOptions.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LocalInProgressBinder">
	<summary>
 This binder is for binding the initializer of an implicitly typed 
 local variable. While binding an implicitly typed local variable
 this binder is used to break cycles.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.LocalBinderBuilder.VisitCompilationUnit(Roslyn.Compilers.VisualBasic.CompilationUnitSyntax)">
	<summary>
 Creates binders for top-level executable statements.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LocalBinderBuilder">
	<summary>
 The <see cref="T:Roslyn.Compilers.VisualBasic.LocalBinderBuilder"/> is used to build up the map of all <see cref="T:Roslyn.Compilers.VisualBasic.Binder"/>s within a method body, and the associated
 <see cref="T:Roslyn.Compilers.VisualBasic.SyntaxNode"/>. To do so it traverses all the statements, handling blocks and other
 statements that create scopes. For efficiency reasons, it does not traverse into
 expressions. This means that blocks within lambdas and queries are not created. 
 Blocks within lambdas are bound by their own <see cref="T:Roslyn.Compilers.VisualBasic.LocalBinderBuilder"/> when they are 
 analyzed.

 For reasons of lifetime management, this type is distinct from the <see cref="T:Roslyn.Compilers.VisualBasic.BinderFactory"/> 
 which also creates a map from <see cref="T:Roslyn.Compilers.VisualBasic.SyntaxNode"/> to <see cref="T:Roslyn.Compilers.VisualBasic.Binder"/>. That type owns it's binders
 and that type's lifetime is that of the compilation. Therefore we do not store
 binders local to method bodies in that type's cache. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImplicitVariableBinder.#ctor(Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 If Option Explicit is Off for this source file, then implicit variable declaration will be allowed
 in this binder. "containerOfLocals" is the container for implicitly declared variables.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImplicitVariableBinder.DisallowFurtherImplicitVariableDeclaration">
	<summary>
 Disallow additonal local variable declaration (make binder frozen)
 </summary>
	<remarks></remarks>
</member><member name="P:Roslyn.Compilers.VisualBasic.ImplicitVariableBinder.AllImplicitVariableDeclarationsAreHandled">
	<summary>
 True if implicit variable declaration is done (binder is frozen and doesn't
 allow additional implicit variable declaration)
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ImplicitVariableBinder.ImplicitVariableDeclarationAllowed">
	<summary>
 True if we are in a place that allows implicit variable declaration. This binder
 implies that.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ImplicitVariableBinder.ImplicitlyDeclaredVariables">
	<summary>
 Get all implicitly declared variables that were declared in this method body. The binder
 must be frozen before this can be obtained.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImplicitVariableBinder.DeclareImplicitLocalVariable(Roslyn.Compilers.VisualBasic.IdentifierNameSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Declare an implicit local variable. The type of the local is determined
 by the type character (if any) on the variable.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImplicitVariableBinder.RememberPossibleShadowingVariable(System.String,Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken,Roslyn.Compilers.VisualBasic.ERRID)">
	<summary>
 A tricky problem is reporting the "Variable 'x' hides a variable in an enclosing block" message if the variable in
 an enclosing block is an implicit variable that hasn't been declared yet. We handle this by remembering any variable
 declarations in enclosed blocks, and then report the error when the implicit variable is declared.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ImplicitVariableBinder">
	<summary>
 The ImplicitVariableBinder manages implictly declared local variables in VB.
 Unlike other Binders, the ImplicitVariableBinder is observably 
 mutable -- as new implicit local variables are declared, those variables will be
 found by lookup operations on the binder. This mutability requires that use of the 
 ImplicitVariableBinder be treated with somewhat more care than other binders.
 
 The implicit variable binder is placed immediately outside the method body binder
 when the method body binder is created.
 
 Furthermore, the semantics of binding of implicitly declared local variables in VB
 are order dependent because of type characters:
     x$ = "hello": x = "hi"   ' OK
     x = "hi": X$ = "hello"   ' error: x is of type Object.
 
 An ImplicitVariableBinder can be frozen, at which point additional variables cannot
 be declared. This should be done once an entire method body is bound.
 
 Thus, it is important that only one thread at a time be allowed to access the implicit variable binder for
 declaration (once frozen, it is OK for multiple threads to do lookups.)
 
 In Debug, Asserts validate these rules.
 
 Additional assert to make sure that declarations are handled in order is handled by 
 <see cref="M:ExecutableStatementSyntax.CheckSimpleNameBindingOrder"/>
	</summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.GetTypeBinder.OpenTypeVisitor.Visit(Roslyn.Compilers.VisualBasic.ExpressionSyntax,System.Collections.Generic.Dictionary{Roslyn.Compilers.VisualBasic.GenericNameSyntax,System.Boolean}@,System.Boolean)">
	<param name="typeSyntax">The argument to typeof.</param>
	<param name="allowedMap">
 Keys are GenericNameSyntax nodes representing unbound generic types.
 Values are false if the node should result in an error and true otherwise.
 </param>
	<param name="isOpenType">True if no constructed generic type was encountered.</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.GetTypeBinder.OpenTypeVisitor">
	<summary>
 This visitor walks over a type expression looking for open types.
 Open types are allowed if an only if:
   1) There is no constructed generic type elsewhere in the visited syntax; and
   2) The open type is not used as a type argument or array/nullable
        element type.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.GetTypeBinder">
	<summary>
 This binder is for binding the argument to GetType.  It traverses
 the syntax marking each open type ("unbound generic type" in the
 VB spec) as either allowed or not allowed, so that BindType can 
 appropriately return either the corresponding type symbol or an 
 error type.  
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.ForEachEnumeratorInfo.GetEnumerator">
	<summary>
 A bound call to the GetEnumerator method.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.ForEachEnumeratorInfo.MoveNext">
	<summary>
 A bound call to the MoveNext method.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.ForEachEnumeratorInfo.Current">
	<summary>
 A bound access to the Current property.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.ForEachEnumeratorInfo.Dispose">
	<summary>
 The Dispose method that get's eventually called if the collection's enumerator implements it.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.ForEachEnumeratorInfo.NeedToDispose">
	<summary>
 True is the enumerator needs or may need (in case of IEnumerator) to be disposed.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.ForEachEnumeratorInfo.IsOrInheritsFromOrImplementsIDisposable">
	<summary>
 True if the enumerator is, inherits from or implements IDisposable.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.ForEachEnumeratorInfo.DisposeCondition">
	<summary>
 The condition that is used to determine whether to call Dispose or not (contains a placeholder).
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.ForEachEnumeratorInfo.DisposeCast">
	<summary>
 The conversion of the enumerator to the target type on which Dispose is called 
 (contains a placeholder).
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.ForEachEnumeratorInfo.CurrentConversion">
	<summary>
 The conversion of the return value of the current call to the type of the control variable 
 (contains a placeholder).
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.ForEachEnumeratorInfo.EnumeratorPlaceholder">
	<summary>
 Placeholder for the bound enumerator local. 
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.ForEachEnumeratorInfo.CurrentPlaceholder">
	<summary>
 Placeholder for the bound call to the get_Current method.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.ForEachEnumeratorInfo.CollectionPlaceholder">
	<summary>
 Placeholder for the collection; used only when the collection's type 
 is not an one dimensional array or string.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForEachEnumeratorInfo.#ctor(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.MethodSymbol,System.Boolean,System.Boolean,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundLValuePlaceholder,Roslyn.Compilers.VisualBasic.BoundRValuePlaceholder,Roslyn.Compilers.VisualBasic.BoundRValuePlaceholder)">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.ForEachEnumeratorInfo"/> class.
 </summary>
	<param name="getEnumerator">A bound call to the GetEnumerator method.</param>
	<param name="moveNext">A bound call to the MoveNext method.</param>
	<param name="current">A bound access to the Current property.</param>
	<param name="dispose">The Dispose method.</param>
	<param name="needToDispose">if set to <c>true</c> the enumerator needs to be disposed.</param>
	<param name="isOrInheritsFromOrImplementsIDisposable">if set to <c>true</c> the enumerator is or inherits from or implements IDisposable.</param>
	<param name="disposeCondition">The condition whether to call dispose or not.</param>
	<param name="disposeCast">The conversion of the enumerator to call Dispose on.</param>
	<param name="currentConversion">The conversion from Current return type to the type of the controlVariable.</param>
	<param name="enumeratorPlaceholder">The placeholder for the bound enumerator local.</param>
	<param name="currentPlaceholder">The placeholder for the expression that get's the current value.</param>
	<param name="collectionPlaceholder">The placeholder for the collection expression.</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.ForEachEnumeratorInfo">
	<summary>
 Holds all information needed to rewrite a bound for each node.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ForBlockBinder">
	<summary>
 Binder used to bind For and ForEach blocks. 
 It hosts the control variable (if one is declared) 
 and inherits ExitableStatementBinder to provide Continue/Exit labels if needed. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.FinallyBlockBinder">
	<summary>
 Binder for Finally blocks. 
 Its purpose is to hide exit try label of the enclosing try binder.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.EarlyWellKnownAttributeBinder.CanBeValidAttributeArgument(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Check that the syntax can appear in an attribute argument.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.EarlyWellKnownAttributeBinder">
	<summary>
 This is a binder for use when early decoding of well known attributes. The binder will only bind expressions that can appear in an attribute.
 Its purpose is to allow a symbol to safely decode any attribute without the possibility of any attribute related infinite recursion during binding.
 If an attribute and its arguments are valid then this binder returns a BoundAttributeExpression otherwise it returns a BadExpression.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.DescendantBinderFactory">
	<summary>
 Provides a way to obtain binders for descendant scopes in method or lambda body.
 Factory for a method body does not create binders for scopes inside a lambda, 
 contained by the method. A dedicated factory must be created for each lambda body.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.DefaultParametersInProgressBinder">
	<summary>
 This binder keeps track of the set of parameterss that are currently being evaluated
 so that the set can be passed into the next call to ParameterSymbol.DefaultConstantValue (and
 its callers).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SymbolsInProgressBinder`1">
	<summary>
 This binder keeps track of the set of symbols that are currently being evaluated
 so that the set can be passed to methods to support breaking infinite recursion
 cycles.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.DeclarationInitializerBinder.m_symbol">
	<summary>
 Backing field for the ContainingMember property
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.DeclarationInitializerBinder._root">
	<summary> Root syntax node </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DeclarationInitializerBinder.#ctor(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Initializes a new instance of the <see cref="T:Roslyn.Compilers.VisualBasic.DeclarationInitializerBinder"/> class.
 </summary>
	<param name="symbol">The field, property or parameter symbol with an initializer or default value.</param>
	<param name="next">The next binder.</param>
	<param name="root">Root syntax node</param>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclarationInitializerBinder.ContainingMember">
	<summary>
 The member containing the binding context. 
 This property is the main reason for this binder, because the binding context for an initialization 
 needs to be the field or property symbol.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DeclarationInitializerBinder.Root">
	<summary> Field or property declaration statement syntax node </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.DeclarationInitializerBinder">
	<summary>
 Binder used for field, auto property initializations and parameter default values.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ConstantFieldsInProgressBinder">
	<summary>
 This binder keeps track of the set of constant fields that are currently being evaluated
 so that the set can be passed into the next call to SourceFieldSymbol.ConstantValue (and
 its callers).
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.CatchBlockBinder">
	<summary>
 Binder used to bind Catch blocks. 
 It hosts the control variable (if one is declared) 
 and inherits BlockBaseBinder since there are no Exit/Continue for catch blocks. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.BindingLocation">
	<summary>
 A specific location for binding.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.BinderFactory">
	<summary>
 The <see cref="T:Roslyn.Compilers.VisualBasic.BinderFactory"/> class finds the correct Binder to use for a node in a syntax
 tree, down to method level. Within a method, the <see cref="T:Roslyn.Compilers.VisualBasic.ExecutableCodeBinder"/> has a
 cache of further binders within the method.
 
 The <see cref="T:Roslyn.Compilers.VisualBasic.BinderFactory"/> caches results so that binders are efficiently reused between queries.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinderBuilder.CreateBinderForSourceFileImports(Roslyn.Compilers.VisualBasic.SourceModuleSymbol,Roslyn.Compilers.VisualBasic.SyntaxTree)">
	<summary>
 Creates a binder for a binding global imports in a source file. This includes the following binders:
    BackstopBinder
    SourceModuleBinder
    SourceFileBinder
    NamespaceBinder (for the global namespace)
    IgnoreBaseClassesBinder (so that base classes are ignore during binding)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinderBuilder.CreateBinderForProjectImports(Roslyn.Compilers.VisualBasic.SourceModuleSymbol,Roslyn.Compilers.VisualBasic.SyntaxTree)">
	<summary>
 Creates a binder for a binding project-level imports. This includes the following binders:
    BackstopBinder
    SourceModuleBinder
    ProjectImportsBinder
    NamespaceBinder (for the global namespace)
    IgnoreBaseClassesBinder (so that base classes are ignore during binding)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinderBuilder.CreateBinderForSourceFile(Roslyn.Compilers.VisualBasic.SourceModuleSymbol,Roslyn.Compilers.VisualBasic.SyntaxTree)">
	<summary>
 Creates a binder for a source file. This includes the following binders:
    BackstopBinder
    SourceModuleBinder
    TypesOfImportedNamespacesMembersBinder (for modules of project-level imported namespaces)
    ImportedTypesAndNamespacesMembersBinder (for project-level imported namespaces and types)
    ImportAliasesBinder (for project-level import aliases)
    SourceFileBinder
    TypesOfImportedNamespacesMembersBinder (for modules of file-level imported namespaces)
    ImportedTypesAndNamespacesMembersBinder (for file-level imported namespaces and types)
    ImportAliasesBinder (for file-level import aliases)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinderBuilder.CreateBinderForProjectLevelNamespace(Roslyn.Compilers.VisualBasic.SourceModuleSymbol,Roslyn.Compilers.VisualBasic.SyntaxTree)">
	<summary>
 Creates a binder for a project level namespace declaration 
 This includes the following binders:
    BackstopBinder
    SourceModuleBinder
    TypesOfImportedNamespacesMembersBinder (for modules of project-level imported namespaces)
    ImportedTypesAndNamespacesMembersBinder (for project-level imported namespaces and types)
    SourceFileBinder
    TypesOfImportedNamespacesMembersBinder (for modules of file-level imported namespaces)
    ImportedTypesAndNamespacesMembersBinder (for file-level imported namespaces and types)
    ImportAliasesBinder (for file-level import aliases)
    NamespaceBinder... (for each namespace, starting at the global namespace)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinderBuilder.CreateBinderForNamespace(Roslyn.Compilers.VisualBasic.SourceModuleSymbol,Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.VisualBasic.NamespaceSymbol)">
	<summary>
 Creates a binder for a source namespace declaration (the part of a namespace
 in a single namespace declaration). This includes the following binders:
    BackstopBinder
    SourceModuleBinder
    TypesOfImportedNamespacesMembersBinder (for modules of project-level imported namespaces)
    ImportedTypesAndNamespacesMembersBinder (for project-level imported namespaces and types)
    SourceFileBinder
    TypesOfImportedNamespacesMembersBinder (for modules of file-level imported namespaces)
    ImportedTypesAndNamespacesMembersBinder (for file-level imported namespaces and types)
    ImportAliasesBinder (for file-level import aliases)
    NamespaceBinder... (for each namespace, starting at the global namespace)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinderBuilder.CreateBinderForType(Roslyn.Compilers.VisualBasic.SourceModuleSymbol,Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.VisualBasic.NamedTypeSymbol)">
	<summary>
 Creates a binder for a source type declaration (the part of a type in a single
 type declaration. For partial types this include just one part). This includes the following binders:
    BackstopBinder
    SourceModuleBinder
    TypesOfImportedNamespacesMembersBinder (for modules of project-level imported namespaces)
    ImportedTypesAndNamespacesMembersBinder (for project-level imported namespaces and types)
    SourceFileBinder
    TypesOfImportedNamespacesMembersBinder (for modules of file-level imported namespaces)
    ImportedTypesAndNamespacesMembersBinder (for file-level imported namespaces and types)
    ImportAliasesBinder (for file-level import aliases)
    NamespaceBinder... (for each namespace, starting at the global namespace)
    NamedTypeBinder... (for each type, and nested type)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinderBuilder.CreateBinderForAttribute(Roslyn.Compilers.VisualBasic.SourceModuleSymbol,Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Creates a binder for a source attribute block from the containing type or containing namespace.
 This binder is used by the normal compilation code path for source attributes. In this case, no
 containing binder exists.
 </summary>
	<param name="moduleSymbol"></param>
	<param name="tree"></param>
	<param name="target">The symbol which is the target of the attribute.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinderBuilder.CreateBinderForAttribute(Roslyn.Compilers.VisualBasic.SourceModuleSymbol,Roslyn.Compilers.VisualBasic.SyntaxTree,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Creates a binder for a source attribute block when a containing binder is available. Used by semantic model.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinderBuilder.CreateBinderForParameterDefaultValue(Roslyn.Compilers.VisualBasic.ParameterSymbol,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Creates a binder for binding a source parameter's default value.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BinderBuilder.CreateSourceModuleBinder(Roslyn.Compilers.VisualBasic.SourceModuleSymbol)">
	<summary>
 Create a binder for the source module. Includes the following:
    BackstopBinder
    SourceModuleBinder
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.BinderBuilder">
	<summary>
 A BinderBuilder builds a linked list of Binder objects for various typical binders.
 
 Typically the binder chain looks something like this:
    BackstopBinder
    SourceModuleBinder
    TypesOfImportedNamespacesMembersBinder (for modules of project-level imported namespaces)
    ImportedTypesAndNamespacesMembersBinder (for project-level imported namespaces and types)
    ImportAliasesBinder (for project-level import aliases)
    SourceFileBinder
    TypesOfImportedNamespacesMembersBinder (for modules of file-level imported namespaces)
    ImportedTypesAndNamespacesMembersBinder (for file-level imported namespaces and types)
    ImportAliasesBinder (for file-level import aliases)
    NamespaceBinder... (for each namespace, starting at the global namespace)
    TypeBinder... (for each type, and nested type)
  (maybe more)
    DiagnosticBagBinder 
 
  Note: Binders are also built by the BinderCache class. Changes to how namespace and type Binders
  are built may need changes there also.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetPrefixesAndNamespacesInScope(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.ArrayBuilder{System.Collections.Generic.KeyValuePair{System.String,System.String}},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Get the set of prefixes and namespaces, as BoundExpressions,
 for those xmlns declarations in scope.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.CreateCompilerGeneratedArray(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Create a BoundExpression representing an array creation initialized with the given items.
 If there are zero items, the result is a BoundLiteral Nothing. Otherwise, a BoundArrayCreation
 is returned. The resulting node is marked as compiler generated.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MatchesXmlnsImport(System.String,System.String)">
	<summary>
 Returns True if the xmlns { prefix, namespace } pair matches
 an Imports declaration and there aren't any xmlns declarations
 for the same prefix on any outer XElement scopes.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindXmlEmbeddedExpression(Roslyn.Compilers.VisualBasic.XmlEmbeddedExpressionSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Bind the expression within the XmlEmbeddedExpressionSyntax,
 and wrap in a BoundXmlEmbeddedExpression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindInvocationExpressionIfGroupNotNothing(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.BoundMethodOrPropertyGroup,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 If the method or property group is not Nothing, bind as an invocation expression.
 Otherwise return a BoundBadExpression containing the arguments.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.CheckXmlFeaturesAllowed(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Check if XML features are allowed. If not, report an error and return a
 separate DiagnosticBag that can be used for binding sub-expressions.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindXmlnsAttributes(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.XmlNodeSyntax},System.Collections.Generic.Dictionary{Roslyn.Compilers.VisualBasic.Binder.XmlName,Roslyn.Compilers.VisualBasic.BoundXmlAttribute}@,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.BoundXmlAttribute},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.XmlNodeSyntax},Roslyn.Compilers.ArrayBuilder{System.Collections.Generic.KeyValuePair{System.String,System.String}},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Bind any xmlns declaration attributes and return the bound nodes plus a Dictionary
 of { prefix, namespace } pairs that will be used for namespace lookup at and below
 the containing XmlElement. Any xmlns declarations that are redundant with Imports
 in scope (same prefix and namespace) are dropped, and instead, an entry is added
 to the 'importedNamespaces' collection. When the root XmlElement is generated,
 xmlns attributes will be added for all entries in importedNamespaces. Any attributes
 other than xmlns are added to the 'otherAttributes' collection for binding by the caller.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TryGetXmlnsAttribute(Roslyn.Compilers.VisualBasic.XmlAttributeSyntax,System.String@,System.String@,Roslyn.Compilers.VisualBasic.BoundExpression@,System.Boolean@,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 If the attribute represents an xmlns declaration, populate 'prefix' and 'namespace',
 and generate diagnostics and set hasErrors if there are errors. Returns True if this
 is an xmlns declaration, even if there are errors. Unless this attribute is from an
 Imports statement, generate the BoundExpression for the namespace as well.
 (For Imports, binding is skipped, since a BoundNode is not needed, and in the
 invalid case of "xmlns:p=&lt;%= expr %&gt;", expr may result in a cycle.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TryGetXmlnsPrefix(Roslyn.Compilers.VisualBasic.XmlNameSyntax,System.String@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 If name is "xmlns", set prefix to String.Empty and return True.
 If name is "xmlns:p", set prefix to p and return True.
 Otherwise return False.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Binder.XmlElementRootInfo">
	<summary>
 State tracked for the root XmlElement while binding nodes within the
 tree. This state is mutable since it includes the set of namespaces from
 Imports referenced within the tree. Ideally, this state would be part of the
 XmlRootElementBinder, but since this state is mutable, there would be
 issues caching and reusing the Binder. Instead, the state is passed
 explicitly as an argument to each binding method.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.BoundXmlContainerRewriterInfo">
	<summary>
 Binding state used by the rewriter for XContainer derived types.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlNamespaceImportsBinder">
	<summary>
 A binder to expose namespaces from Imports&lt;xmlns:...&gt; statements.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.XmlElementBinder">
	<summary>
 A binder for XmlElement declarations.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ReducedExtensionPropertySymbol">
	<summary>
 An extension property in reduced form, with first parameter
 removed and exposed as an explicit receiver type.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.WithBlockBinder._withBlockSyntax">
	<summary> Reference to a With statement syntax this binder is created for </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WithBlockBinder.Expression">
	<summary> Reference to an expression from With statement </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.WithBlockBinder._withBlockInfo">
	<summary> 
 Holds information needed by With block to properly bind 
 references to With block expression placeholder
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WithBlockBinder.ExpressionIsAccessedFromNestedLambda">
	<summary> 
 True if there were references to the With statement expression 
 placeholder which prevent ByRef local from being used 
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WithBlockBinder.ExpressionPlaceholder">
	<summary>
 With statement expression placeholder is a bound node being used in initial binding
 to represent with statement expression. In lowering it is to be replaced with
 the lowered expression which will actually be emitted.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WithBlockBinder.DraftInitializers">
	<summary>
 A draft version of initializers which will be used in this With statement. 
 Initializers are expressinos which are used to capture expression in the current
 With statement; they can be empty in some cases like if the expression is a local 
 variable of value type.
 
 Note, the initializers returned by this property are 'draft' because they are 
 generated based on initial bound tree, the real initializers will be generated 
 in lowering based on lowered expression form.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WithBlockBinder.DraftPlaceholderSubstitute">
	<summary>
 A draft version of placeholder substitute which will be used in this With statement. 
 
 Note, the placeholder substitute returned by this property is 'draft' because it is
 generated based on initial bound tree, the real substitute will be generated in lowering 
 based on lowered expression form.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.WithBlockBinder.WithBlockInfo.OriginalExpression">
	<summary> Original bound expression from With statement </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.WithBlockBinder.WithBlockInfo.ExpressionPlaceholder">
	<summary> Bound placeholder expression if used, otherwise Nothing </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.WithBlockBinder.WithBlockInfo.Diagnostics">
	<summary> Diagnostics produced while binding the expression </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.WithBlockBinder.WithBlockInfo.DraftInitializers">
	<summary> 
 Draft initializers for With statement, is based on initial binding tree 
 and is only to be used for warnings generation as well as for flow analysis 
 and semantic API; real initializers will be re-calculated in lowering
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.WithBlockBinder.WithBlockInfo.DraftSubstitute">
	<summary> 
 Draft substitute for With expression placeholder, is based on initial 
 binding tree and is only to be used for warnings generation as well as 
 for flow analysis and semantic API; real substite will be re-calculated 
 in lowering
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.WithBlockBinder.WithBlockInfo.ExpressionHasByRefMeReference">
	<summary>
 If With statement expression is being used from nested lambda there are some restrictions
 to the usage of Me reference in this expression. As these restrictions are only to be checked 
 in few scenarios, this flag is being calculated lazily.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.WithBlockBinder.WithBlockInfo">
	<summary> Holds information needed by With block to properly bind 
 references to With block expression, placeholder, etc... </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.WithBlockBinder.#ctor(Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.WithBlockSyntax)">
	<summary> Create a new instance of With statement binder for a statement syntax provided </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.WithBlockBinder.ValueTypedMeReferenceFinder">
	<summary>
 A bound tree walker which search for a bound Me and MyClass references of value type. 
 Is being only used for calculating the value of 'ExpressionHasByRefMeReference'
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.WithBlockBinder.AssertExpressionIsNotFromStatementExpression(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary> Asserts that the node is NOT from With statement expression </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.WithBlockBinder">
	<summary>
 Binder used to bind statements inside With blocks. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DisallowTypeCharacter(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.ERRID)">
	<summary>
 If the identifier has a type character, report an error on it.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.FindFirstKeyword(Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SyntaxKind[])">
	<summary>
 Given a list of keywords and an set of keywords kinds to search, return the first keyword
 in the list, if any, that matches one of the keyword kinds.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MapKeywordToFlag(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Map syntax kind of a modifier keyword to SourceMemberFlags value
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodeModifiers(Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.SourceMemberFlags,Roslyn.Compilers.VisualBasic.ERRID,Roslyn.Compilers.VisualBasic.Accessibility,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Decodes a set of modifier flags, reported any errors with the flags.
 </summary>
	<param name="syntax">The syntax list of the modifiers.</param>
	<param name="allowableModifiers">A bit-flag of the allowable modifiers. If a bit isn't set, an error occurs.</param>
	<param name="errIdBadModifier">Error ID to report if a bad modifier is found.</param>
	<param name="defaultAccessibility">The default accessibility. </param>
	<returns>Flags for the modifiers.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodeParameterModifiers(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.Binder.CheckParameterModifierDelegate,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Decode a list of parameter modifiers, and return the flags associated with it.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.CreateNullableOf(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Create the Nullable version of a type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ApplyArrayRankSpecifersToType(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Possible create the array version of type, given the element type and the array modifier syntax.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ApplyArrayRankSpecifiersAndBoundsToType(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax},Roslyn.Compilers.VisualBasic.ArgumentListSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Possibly create the array version of type, given the element type and the array modifier syntax.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.CreateArrayOf(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax},Roslyn.Compilers.VisualBasic.ArgumentListSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Create the array version of type, given the element type and the array modifier syntax. Throws if
 there aren't any array modifiers and the result is not an array type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.HasDefaultType(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Given an identifier and an As clause, return true if the identifier does not have a type
 declared for it (e.g., no type character and no as clause).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.HasDefaultType(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax)">
	<summary>
 Given an identifier and an As clause, return true if the identifier does not have a type
 declared for it (e.g., no type character and no as clause).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.IsArrayType(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax)">
	<summary>
 Given an identifier, return true if the identifier declares an array.
 (e.g., identifier  specifies ())
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext.None">
	<summary>
 No context given (default).
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext.LambdaType">
	<summary>
 Modified identifier appeared in a lambda declaration.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext.LocalType">
	<summary>
 Modified identifier appeared in a local declaration.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext.FieldType">
	<summary>
 Modified identifier appeared in a field declaration.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext.ParameterType">
	<summary>
 Modified identifier appeared in a parameter.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext.QueryRangeVariableType">
	<summary>
 Modified identifier appeared in a query range variable declaration.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext.LocalOrFieldType">
	<summary>
 Combined flag to express that a modified identifier appeared in a local or field declaration.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext.LambdaParameterType">
	<summary>
 Combined flag to express that a modified identifier appeared in a parameter of a lambda.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext">
	<summary>
 Flags to specify where the decoding of the modified identifier's type happens.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodeModifiedIdentifierType(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.SyntaxNode,System.Func{Roslyn.Compilers.DiagnosticInfo},Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext)">
	<summary>
 Given a modified identifier and a type, return the actual type to use. Applies the type character
 and type modifiers to the given type.
 </summary>
	<param name="modifiedIdentifier">The modified identifier.</param>
	<param name="asClauseOrValueType">Bound type after the As or a type from the initializing value expression. Can be nothing if no type was supplied.</param>
	<param name="asClauseSyntaxOpt">If specified then it is the syntax for the as clause and the type is the bound type from this syntax.</param>
	<param name="getRequireTypeDiagnosticInfoFunc">Delegate to get diagnostic info to generate if a required type is missing (Option Strict On/Custom) </param>
	<returns>The type, as modified by the type character, type modifiers. Uses Object as default if needed.</returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodeModifiedIdentifierType(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.EqualsValueSyntax,System.Func{Roslyn.Compilers.DiagnosticInfo},Roslyn.Compilers.VisualBasic.TypeSymbol@,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext)">
	<summary>
 Given a modified identifier and a type syntax, return the actual type to use. Applies the type character
 and type modifiers to the given type.
 </summary>
	<param name="modifiedIdentifier">The modified identifier.</param>
	<param name="asClauseOpt"> As clause syntax. Can be nothing if no type was supplied.</param>
	<param name="getRequireTypeDiagnosticInfoFunc">Delegate to get diagnostic info to generate if a required type is missing (Option Strict On/Custom) </param>
	<param name="asClauseType">The type of the AsClauseOpt before applying any modifiers</param>
	<returns>The type, as modified by the type character, type modifiers. Uses Object as default if needed.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodeModifiedIdentifierType(Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.EqualsValueSyntax,System.Func{Roslyn.Compilers.DiagnosticInfo},Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext)">
	<summary>
 Given a modified identifier and a type syntax, return the actual type to use. Applies the type character
 and type modifiers to the given type.
 </summary>
	<param name="modifiedIdentifier">The modified identifier.</param>
	<param name="asClauseOpt"> As clause syntax. Can be nothing if no type was supplied.</param>
	<param name="getRequireTypeDiagnosticInfoFunc">Delegate to get diagnostic info to generate if a required type is missing (Option Strict On/Custom) </param>
	<returns>The type, as modified by the type character, type modifiers. Uses Object as default if needed.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodeIdentifierType(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.AsClauseSyntax,System.Func{Roslyn.Compilers.DiagnosticInfo},Roslyn.Compilers.VisualBasic.TypeSymbol@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Given a identifier and as clause syntax, return the actual type to use. Uses the type character or the type syntax.
 </summary>
	<param name="identifier">The identifier.</param>
	<param name="asClauseOpt">Syntax for optional as clause. Can be nothing if no type was supplied.</param>
	<param name="getRequireTypeDiagnosticInfoFunc">Delegate to get diagnostic info to generate if a required type is missing (Option Strict On/Custom) </param>
	<returns>The type, either from the type character or the as clause. Uses Object as default if needed.</returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodeIdentifierType(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.AsClauseSyntax,System.Func{Roslyn.Compilers.DiagnosticInfo},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Given a identifier and as clause syntax, return the actual type to use. Uses the type character or the type syntax.
 </summary>
	<param name="identifier">The identifier.</param>
	<param name="asClauseOpt">Syntax for optional as clause. Can be nothing if no type was supplied.</param>
	<param name="getRequireTypeDiagnosticInfoFunc">Delegate to get diagnostic info to generate if a required type is missing (Option Strict On/Custom) </param>
	<returns>The type, either from the type character or the as clause. Uses Object as default if needed.</returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodeIdentifierType(Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Func{Roslyn.Compilers.DiagnosticInfo},Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.Binder.ModifiedIdentifierTypeDecoderContext)">
	<summary>
 Given a identifier and a type, return the actual type to use. Uses the type character or the given type.
 </summary>
	<param name="identifier">The identifier.</param>
	<param name="asClauseType">Bound type after the As. Can be nothing if no type was supplied.</param>
	<param name="getRequireTypeDiagnosticInfoFunc">Delegate to get diagnostic info to generate if a required type is missing (Option Strict On/Custom) </param>
	<returns>The type, either from the type character or the as clause type. Uses Object as default if needed.</returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodeOnOff(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Decode an option "On" or "Off" values into true or false. Not specified is considered true.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodeTextBinary(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Decode an option "Text" or "Binary" value into true or false. The syntax is not optional.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodeParameterListOfDelegateDeclaration(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Decode a parameter list from a delegate declaration into a list of parameter symbols.
 </summary>
	<param name="container">Containing method declaration.</param>
	<param name="syntaxOpt">Optional parameter list syntax</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodeParameterList(Roslyn.Compilers.VisualBasic.Symbol,System.Boolean,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Decode a parameter list into a list of parameter symbols.
 </summary>
	<param name="container">Containing method declaration.</param>
	<param name="isFromLambda">Parameter is for a lambda expression rather than a regular method.</param>
	<param name="syntaxOpt">Optional parameter list syntax</param>
	<remarks>DO NOT call this to get the parameters of a delegate declaration (<see>DecodeParameterListOfDelegateDeclaration</see>).</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodePropertyParameterList(Roslyn.Compilers.VisualBasic.PropertySymbol,Roslyn.Compilers.VisualBasic.ParameterListSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Decode a parameter list into a list of parameter symbols.
 </summary>
	<param name="container">Containing property declaration.</param>
	<param name="syntaxOpt">Optional parameter list syntax</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ValidateSharedPropertyAndMethodModifiers(Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.VisualBasic.MemberModifiers,System.Boolean,Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Modifier validation code shared between properties and methods.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ExpressionIsConstant(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 This function determines if the given expression is constant from a language point of view. This is different from the 
 fact that the bound node has a constant value. This method also adds the required diagnostics for non const values.
 </summary>
	<param name="boundExpression">The bound expression.</param>
	<param name="diagnostics">The diagnostics.</param>
	<returns>True if the bound expression is compile time constant and can be used for const field/local initializations 
 or enum member initializations.</returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceMemberFlags">
	<summary>
 Holds information about a member in a compact form. Used for all non-type members for simplicity
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.MemberModifiers._foundFlags">
	<summary>
 These are the flags that are found in the syntax.  They must correspond to the modifiers list.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.MemberModifiers._computedFlags">
	<summary>
 These are flags that are implied or computed
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindTypeSyntax(Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.DiagnosticBag,System.Boolean,System.Boolean)">
	<summary>
 Bind a type name using the given binder. Returns a type symbol if the binding bound to something,
 or an error symbol if the binding failed. In either case, errors may be reported via the
 context. For example, if an inaccessible type or type with the wrong arity was found, the best possible
 type is returned, but an error is also generated.
 </summary>
	<param name="typeSyntax">The syntax to bind.</param>
	<param name="diagBag">Place to put diagnostics. If no reasonable type was found, an undefined type
 diagnostic is placed in here. Other diagnostics (both related to the type being bound, or
 type arguments thereof) can be placed here also. </param>
	<returns>The best type that can be found, or and ErrorTypeSymbol if no reasonable type can be found.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindNamespaceOrTypeSyntax(Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 Bind a type or namespace using the given binder. 
 </summary>
	<param name="typeSyntax">The syntax to bind.</param>
	<returns>The best type or namespace that can be found, or and ErrorTypeSymbol if no reasonable type can be found.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ConstructAndValidateConstraints(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol},Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.TypeSyntax},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Apply generic type arguments, returning the constructed type. Produces errors for constraints
 that aren't validated. If the wrong number of type arguments are supplied, the set of types
 is silently truncated or extended with the type parameters.
 </summary>
	<param name="genericType">The type to construct from</param>
	<param name="typeArguments">The types to apply</param>
	<param name="syntaxWhole">The place to report errors for the generic type as a whole</param>
	<param name="syntaxArguments">The place to report errors for each generic type argument.</param>
	<param name="diagnostics">The diagnostics collection.</param>
	<returns>The constructed generic type.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ResolveOverloadedMembers``1(Roslyn.Compilers.ReadOnlyArray{``0},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.TypeSymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.ArgumentSyntax})">
	<summary>
 Resolves overloaded methods or constructors or properties for SemanticModel.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.BindTypeSyntax(Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 Bind a type name using the given binder. Returns a type symbol if the binding bound
 to something, or an error symbol if the binding failed. In either case, errors may
 be reported via the context. For example, if an inaccessible type or type with the
 wrong arity was found, the best possible type is returned, but an error is also
 generated.
 </summary>
	<param name="typeSyntax">The syntax to bind.</param>
	<param name="binder">The binder to bind within. This binder is used for looking up
 unqualified names, accessibility checking, reporting errors, and probably other
 stuff too.</param>
	<returns>The best type that can be found, or and ErrorTypeSymbol if no reasonable type can be found.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.CheckForForwardedType(Roslyn.Compilers.VisualBasic.AssemblySymbol,Roslyn.Compilers.VisualBasic.TypeSyntax@,System.String@,Roslyn.Compilers.VisualBasic.AssemblySymbol@,System.Boolean@)">
	<summary>
 If lookup failed for a qualified name, we don't know which part of the lookup failed.  Therefore, we have
 to check for a type forwarder for each prefix of the name.
 </summary>
	<param name="containingAssembly">Starting assembly.</param>
	<param name="typeSyntax">Full name of type that failed lookup.  Shortened as different prefixes are checked.</param>
	<param name="diagName">GetBaseNamesForDiagnostic(typeSyntax) (basically dot-delimited list of names).  Shortened as different prefixes are checked.</param>
	<param name="forwardedToAssembly">Set if some prefix matches a forwarded type.</param>
	<param name="encounteredForwardingCycle">True if forwardedToAssembly is non-null and the type indicated by typeSyntax/diagName is in a forwarder cycle.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.GetForwardedToAssembly(Roslyn.Compilers.VisualBasic.AssemblySymbol,System.String,System.Int32,System.Boolean@)">
	<summary>
 Look for a type forwarder for the given type in the containing assembly and any referenced assemblies.
 If one is found, search again in the target assembly.  Return the last assembly in the chain.
 </summary>
	<param name="containingAssembly">The assembly in which to look for the type forwarder.</param>
	<param name="fullName">The metadata name of the (potentially) forwarded type, including the arity (if non-zero).</param>
	<param name="arity">The arity of the forwarded type.</param>
	<param name="encounteredCycle">Set to true if a cycle was found in the type forwarders.</param>
	<returns></returns>
	<remarks>
 Since this method is intended to be used for error reporting, it stops as soon as it finds
 any type forwarder - it does not check other assemblies for consistency or better results.
 
 NOTE: unlike in C#, this method searches for type forwarders case-insensitively.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.BindNamespaceOrTypeSyntax(Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 Bind a type or namespace using the given binder. 
 </summary>
	<param name="typeSyntax">The syntax to bind.</param>
	<param name="binder">The binder to bind within. This binder is used for looking up
 unqualified names, accessibility checking, reporting errors, and probably other stuff too.</param>
	<returns>The best type or namespace that can be found, or and ErrorTypeSymbol if no reasonable type can be found.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.LookupTypeOrNamespaceSyntax(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.TypeSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,System.Boolean@,System.Boolean,System.Boolean,System.Boolean)">
	<summary>
 Lookup a typeSyntax, confining the lookup to namespaces or types. Returns a LookupResult
 that summarizes the results of the lookup, which might contain a Diagnostic associated with the lookup.
 However, other diagnostics associated with parts of the binding process (i.e., binding type arguments) 
 will be emitted via the diagnostic bag.
 
 The LookupResult will always have at most one symbol in it, since types and namespaces are not overloadable symbols.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.CheckSymbolIsType(Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Check that the given symbol is a type. If it is a namespace, report an error into the diagnostic bag
 and return an error symbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.LookupPredefinedTypeName(Roslyn.Compilers.VisualBasic.PredefinedTypeSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,System.Boolean@,System.Boolean)">
	<summary>
 Bind a built in type name to the correct type symbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.LookupArrayType(Roslyn.Compilers.VisualBasic.ArrayTypeSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,System.Boolean,System.Boolean)">
	<summary>
 Bind array type syntax to the correct type symbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.LookupNullableType(Roslyn.Compilers.VisualBasic.NullableTypeSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 Bind Nullable (?) type syntax to the correct type symbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.LookupBasicName(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.IdentifierNameSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,System.Boolean@)">
	<summary>
 Bind a basic name to a type or namespace.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.LookupGenericName(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.GenericNameSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,System.Boolean@,System.Boolean)">
	<summary>
 Bind a generic name to a type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.LookupDottedName(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.QualifiedNameSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,System.Boolean@,System.Boolean)">
	<summary>
 Bind a dotted name to a type or namespace.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.LookupGenericDottedName(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.QualifiedNameSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,System.Boolean@,System.Boolean)">
	<summary>
 Bind a generic dotted name to a type or namespace.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.LookupGlobalName(Roslyn.Compilers.VisualBasic.GlobalNameSyntax,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Bind to the global namespace.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.BindTypeArguments(Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 Bind a list of type arguments to their types.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TypeBinder.GetBaseNamesForDiagnostic(Roslyn.Compilers.VisualBasic.TypeSyntax)">
	<summary>
 Given a type syntax, strip out ?, (), (of xxx) stuff and return a string of the form
 x.y.z, for use in an error message.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Binder.TypeBinder">
	<summary>
 The type binder class handles binding of type names.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindStatement(Roslyn.Compilers.VisualBasic.StatementSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 The dispatcher method that handles syntax nodes for all stand-alone statements.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Binder.ArrayRankLimit">
	<summary> Defines max allowed rank of the array </summary>
	<remarks> Currently set to 32 because of COM+ array type limits </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DecodeLocalModifiersAndReportErrors(Roslyn.Compilers.VisualBasic.SyntaxTokenList,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Decodes a set of local declaration modifier flags and reports any errors with the flags.
 </summary>
	<param name="syntax">The syntax list of the modifiers.</param>
	<param name="diagBag">returns True if any errors are reported</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ComputeVariableType(Roslyn.Compilers.VisualBasic.LocalSymbol,Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.AsClauseSyntax,Roslyn.Compilers.VisualBasic.EqualsValueSyntax,Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.VisualBasic.TypeSymbol@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Compute the type of a local symbol using the type character, as clause and equals value expression.
 1. Try to compute the type based on the identifier/modified identifier and as clause.  If there is a type then we're done.
 2. If OptionInfer is on then evaluate the expression and use that to infer the type.
 
 ComputeVariableType will only bind the value if the symbol does not have an explicit type.
 </summary>
	<param name="symbol">The local symbol</param>
	<param name="modifiedIdentifierOpt">The symbols modified identifier is there is one</param>
	<param name="asClauseOpt">The optional as clause</param>
	<param name="equalsValueOpt">The optional initializing expression</param>
	<param name="valueExpression">The bound initializing expression</param>
	<param name="asClauseType">The bound as clause type</param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.InferForFromToVariableType(Roslyn.Compilers.VisualBasic.LocalSymbol,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.ForStepClauseSyntax,Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
  Infer the type of a for-from-to control variable.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.InferForEachVariableType(Roslyn.Compilers.VisualBasic.LocalSymbol,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.VisualBasic.TypeSymbol@,System.Boolean@,Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.VisualBasic.BoundLValuePlaceholder@,Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.VisualBasic.BoundRValuePlaceholder@,Roslyn.Compilers.VisualBasic.MethodSymbol@,System.Boolean@,System.Boolean@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
  Infer the type of a for-each control variable.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.InferVariableType(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.BoundExpression,System.Func{Roslyn.Compilers.DiagnosticInfo},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Infer the type of a variable declared with an initializing expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.VerifyLocalSymbolNameAndSetType(Roslyn.Compilers.VisualBasic.LocalSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Verifies that declaration of a local symbol does not cause name clashes.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.VerifyNameShadowingInMethodBody(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken,Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Should be called on the binder, at which the check should begin.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindBlock(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Binds a list of statements and puts in a scope.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindForBlockParts(Roslyn.Compilers.VisualBasic.ForBlockSyntax,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.LocalSymbol@,Roslyn.Compilers.VisualBasic.BoundExpression@,System.Boolean@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Binds all the common part for ForTo and ForEach loops except the loop body and the next variables.
 </summary>
	<param name="node">The node.</param>
	<param name="controlVariableSyntax">The control variable syntax.</param>
	<param name="declaredOrInferredLocalOpt">The declared or inferred local symbol.</param>
	<param name="controlVariable">The control variable.</param>
	<param name="diagnostics">The diagnostics.</param>
	<returns>true if there were errors; otherwise false</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindForLoopBodyAndNextControlVariables(Roslyn.Compilers.VisualBasic.ForBlockSyntax,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression}@,Roslyn.Compilers.VisualBasic.BoundBlock@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Binds loop body and the next variables for ForTo and ForEach loops.
 </summary>
	<remarks>
 The binding of the loop body and the next variables cannot happen before the local type inference has
 completed, which happens in the specialized binding functions for for each and for loops. Otherwise we would
 loose the diagnostics from the type inference.
 </remarks>
	<param name="loopBody">The loop body.</param>
	<param name="nextVariables">The next variables.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindForLoopUserDefinedOperator(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.BinaryOperatorKind,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Can return Nothing in case of failure.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.VerifyForControlVariableDeclaration(Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Verifies for control variable declaration and outputs diagnostics as needed.
 </summary>
	<param name="variableDeclarator">The variable declarator.</param>
	<param name="diagnostics">The diagnostics.</param><returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TryBindLoopControlVariable(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 This function tries to bind the given controlVariableSyntax. 
 If it was an identifier of a valid target, the bound node is written to controlVariable and true is returned.
 If something else was bound, that is not legal as a control variable (e.g. a property), a BoundBadNode is written 
 to controlVariable and false is returned.
 If nothing declared was found, false is returned and controlVariable is set to nothing. In this case it's safe to
 create a new local for the loop node.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GenerateWarningIfNoExplicitFieldReference(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Generates the warning if the control variable is reused from an outer scope and not fully qualified.
 </summary>
	<param name="variableReference">The variable reference.</param>
	<param name="diagnostics">The diagnostics.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.VerifyForLoopControlReference(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 If the the control variable was bound to a non bad expression, this function checks if the 
 bound expression is a variable and reports diagnostics appropriately.
 It reports the errors from 10.9.3 2.2
 </summary>
	<param name="controlVariable">The control variable.</param>
	<param name="diagnostics">The diagnostics.</param><returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.InterpretForEachStatementCollection(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol@,System.Boolean@,Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.VisualBasic.BoundLValuePlaceholder@,Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.VisualBasic.BoundRValuePlaceholder@,Roslyn.Compilers.VisualBasic.MethodSymbol@,System.Boolean@,System.Boolean@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Verifies that the collection is either a string, and array or matches the design pattern criteria and reports 
 diagnostics appropriately.
 </summary>
	<param name="collection">The collection of the for each statement.</param>
	<param name="currentType">If the collection meets all criteria, currentType contains the type of the element from 
 the collection that get's returned by the current property.</param>
	<param name="isEnumerable">if set to <c>true</c>, the collection is enumerable (matches design pattern, IEnumerable 
 or IEnumerable(Of T); otherwise (string or arrays) it's set to false.</param>
	<param name="diagnostics">The diagnostics.</param>
	<returns>The collection which might have been converted to IEnumerable or IEnumerable(Of T) if needed.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MatchesForEachCollectionDesignPattern(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol@,Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.VisualBasic.BoundLValuePlaceholder@,Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.VisualBasic.BoundRValuePlaceholder@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Checks if the type of the collection matches the for each collection design pattern.
 </summary>
	<remarks>
 The rules are that the collection type must have an accessible GetEnumerator method that takes no parameters and
 returns a type that has both:
  - an accessible MoveNext method that takes no parameters and returns a Boolean
  - an accessible Current property that takes no parameters and is not WriteOnly

 NOTE: this function ONLY checks for a function named "GetEnumerator" with the appropriate properties.
 In the spec $10.9 it has these conditions: a type C is a "collection type" if one of
    (1) it satisfies MatchesForEachCollectionDesignPattern (i.e. has a method named GetEnumerator() which
        returns a type with MoveNext/Current); or
    (2) it implements System.Collections.Generic.IEnumerable(Of T); or
    (3) it implements System.Collections.IEnumerable.

 This function ONLY checks for part (1). Callers are expected to check for (2)/(3) themselves. The
 scenario where something satisfies (2/3) but not (1) is
   Class C 
       Implements IEnumerable
       Function g1() as IEnumerator implements IEnumerable.GetEnumerator : End Function
 
 Clearly this class does not have a method _named_ GetEnumerator, but it does implement IEnumerable.
 </remarks>
	<param name="collectionType">The type of the for each collection.</param>
	<param name="collection">The bound collection expression.</param>
	<param name="currentType">Return type of the property named "Current" if found.</param>
	<param name="boundGetEnumeratorCall">A bound call to GetEnumerator on the collection if found.</param>
	<param name="boundEnumeratorPlaceholder">A bound placeholder value for the collection local if GetEnumerator 
 was bound successful</param>
	<param name="boundMoveNextCall">A bound call to MoveNext on the instance returned by GetEnumerator if found.</param>
	<param name="boundCurrentAccess">A bound property access for "Current" on the instance returned by GetEnumerator if found.</param>
	<param name="collectionPlaceholder">A placeholder for the collection expression.</param>
	<param name="temporaryDiagnostics">An empty diagnostic bag to capture diagnostics that have to be reported if the
 collection matches the design pattern and that can be used instead of the generic error message in case non of the
 for each collection criteria match.</param>
	<returns>If all required methods have been successfully looked up and bound, true is being returned; otherwise false.
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.CreateBoundInvocationExpressionFromMethodOrPropertyGroup(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.BoundMethodOrPropertyGroup,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Creates a BoundCall or BoundPropertyAccess from a MethodOrPropertyGroup.
 </summary>
	<remarks>
 This is not a general purpose helper!
 </remarks>
	<param name="syntax">The syntax node.</param>
	<param name="methodOrPropertyGroup">The method or property group.</param>
	<param name="diagnostics">The diagnostics.</param>
</member><member name="F:Roslyn.Compilers.VisualBasic.Binder.IsFunctionWithoutArguments">
	<summary>
 Checks if a given symbol is a function that takes no parameters.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Binder.IsReadablePropertyWithoutArguments">
	<summary>
 Checks if a given symbol is a property that is readable.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetMemberIfMatchesRequirements(System.String,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Func{Roslyn.Compilers.VisualBasic.Symbol,System.Boolean},Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Returns the lookup result if at least one found symbol matches the requirements that are verified
 by using the given symbolChecker. Extension methods will be considered in this check.
 </summary>
	<param name="name">The name of the method or property to look for.</param>
	<param name="container">The container to look in.</param>
	<param name="symbolChecker">The symbol checker which performs additional checks.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.IsOrInheritsFromOrImplementsInterface(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,System.Collections.Generic.HashSet{Roslyn.Compilers.VisualBasic.NamedTypeSymbol},Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Determines whether derivedType is, inherits from or implements the given interface.
 </summary>
	<param name="derivedType">The possible derived type.</param>
	<param name="interfaceType">Type of the interface.</param>
	<param name="matchingInterfaces">A list of matching interfaces.</param>
	<param name="binder">The binder.</param>
	<returns>
		<c>true</c> if derivedType is, inherits from or implements the interface; otherwise, <c>false</c>.
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindUsingBlock(Roslyn.Compilers.VisualBasic.UsingBlockSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Initially binding using blocks.
 A Using statement names a resource that is supposed to be disposed on completion.
 The resource can be an expression or a list of local variables with initializers.
 the type of the resource must implement System.IDispose
 A using statement of the form:
      using Expression
          list_of_statements
      end using

 when the resource is a using locally declared variable no temporary is generated but the variable is read-only
 A using statement of the form:
      using v as new myDispose
          list_of_statements
      end using
 It is also possible to use multiple variable resources:
      using v1 as new myDispose, v2 as myDispose = new myDispose()
          list_of_statements
      end using
</summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ReportMutableStructureConstraintsInUsing(Roslyn.Compilers.VisualBasic.TypeSymbol,System.String,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.DiagnosticBag)">
	<summary>Check the given type of and report WRN_MutableGenericStructureInUsing if needed.</summary>
	<remarks>This function should only be called for a type of a using variable.</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindSyncLockBlock(Roslyn.Compilers.VisualBasic.SyncLockBlockSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Binds a sync lock block.
 A SyncLock come in the following form:
 
 SyncLock &lt;expression&gt;
     &lt;body&gt;
 End SyncLock
 </summary>
	<param name="node">The node.</param>
	<param name="diagnostics">The diagnostics.</param><returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindQueryExpression(Roslyn.Compilers.VisualBasic.QueryExpressionSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Bind a Query Expression.
 This is the entry point.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindSubsequentQueryOperators(Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryClauseSyntax}.Enumerator,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Given a result of binding of initial set of collection range variables, the source,
 bind the rest of the operators in the enumerator.
 
 There is a special method to bind an operator of each kind, the common thing among them is that
 all of them take the result we have so far, the source, and return result of an application 
 of one or two following operators. 
 Some of the methods also take operators enumerator in order to be able to do a necessary look-ahead
 and in some cases even to advance the enumerator themselves.
 Join and From operators absorb following Select or Let, that is when the process of binding of 
 a single operator actually handles two and advances the enumerator. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindFromQueryExpression(Roslyn.Compilers.VisualBasic.QueryExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryClauseSyntax}.Enumerator,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Bind query expression that starts with From keyword, as opposed to the one that starts with Aggregate.
 
     From {collection range variables} [{other operators}]
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindAggregateQueryExpression(Roslyn.Compilers.VisualBasic.QueryExpressionSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryClauseSyntax}.Enumerator,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Bind query expression that starts with Aggregate keyword, as opposed to the one that starts with From.
 
     Aggregate {collection range variables} [{other operators}] Into {aggregation range variables}
 
 If Into clause has one item, a single value is produced. If it has multiple items, values are
 combined into an instance of an Anonymous Type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindAggregateClause(Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.VisualBasic.AggregateClauseSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryClauseSyntax}.Enumerator,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Given result of binding preceding query operators, the source, bind the following Aggregate operator.
 
     {Preceding query operators} Aggregate {collection range variables} [{other operators}] Into {aggregation range variables}
 
 Depending on how many items we have in the INTO clause,
 we will interpret Aggregate operator as follows:

 FROM a in AA              FROM a in AA
 AGGREGATE b in a.BB  =&gt;   LET count = (FROM b IN a.BB).Count()
 INTO Count()

 FROM a in AA              FROM a in AA
 AGGREGATE b in a.BB  =&gt;   LET Group = (FROM b IN a.BB)
 INTO Count(),             Select a, Count=Group.Count(), Sum=Group.Sum(b=&gt;b)
      Sum(b)

 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindFinalImplicitSelectClause(Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Apply implicit Select operator at the end of the query to 
 ensure that at least one query operator is called.
 
 Basically makes query like: 
     From a In AA
 into:
     From a In AA Select a
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindSelectClause(Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.VisualBasic.SelectClauseSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryClauseSyntax}.Enumerator,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Given result of binding preceding query operators, the source, bind the following Select operator.
 
     {Preceding query operators} Select {expression range variables}
 
 From a In AA Select b  ==&gt; AA.Select(Function(a) b)
 
 From a In AA Select b, c  ==&gt; AA.Select(Function(a) New With {b, c})
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindLetClause(Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.VisualBasic.LetClauseSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryClauseSyntax}.Enumerator,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 Given result of binding preceding query operators, the source, bind the following Let operator.
 
     {Preceding query operators} Let {expression range variables}
 
 Ex: From a In AA Let b  ==&gt; AA.Select(Function(a) New With {a, b})
 
 Ex: From a In AA Let b, c  ==&gt; AA.Select(Function(a) New With {a, b}).Select(Function({a, b}) New With {a, b, c})
 
 Note, that preceding Select operator can introduce unnamed range variable, which is dropped by the Let
 
 Ex: From a In AA Select a + 1 Let b ==&gt; AA.Select(Function(a) a + 1).Select(Function(unnamed) b)  
 
 Also, depending on the amount of expression range variables declared by the Let, and the following query operators,
 translation can produce a nested, as opposed to flat, compound variable.
 
 Ex: From a In AA Let b, c, d ==&gt; AA.Select(Function(a) New With {a, b}).
                                     Select(Function({a, b}) New With {{a, b}, c}).
                                     Select(Function({{a, b}, c}) New With {a, b, c, d})   
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MustProduceFlatCompoundVariable(Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryClauseSyntax}.Enumerator)">
	<summary>
 In some scenarios, it is safe to leave compound variable in nested form when there is an
 operator down the road that does its own projection (Select, Group By, ...). 
 All following operators have to take an Anonymous Type in both cases and, since there is no way to
 restrict the shape of the Anonymous Type in method's declaration, the operators should be
 insensitive to the shape of the Anonymous Type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MustProduceFlatCompoundVariable(Roslyn.Compilers.VisualBasic.JoinClauseSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryClauseSyntax}.Enumerator)">
	<summary>
 In some scenarios, it is safe to leave compound variable in nested form when there is an
 operator down the road that does its own projection (Select, Group By, ...). 
 All following operators have to take an Anonymous Type in both cases and, since there is no way to
 restrict the shape of the Anonymous Type in method's declaration, the operators should be
 insensitive to the shape of the Anonymous Type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindFromClause(Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.VisualBasic.FromClauseSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryClauseSyntax}.Enumerator@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Given result of binding preceding query operators, if any, bind the following From operator.
 
     [{Preceding query operators}] From {collection range variables}
 
 Ex: From a In AA  ==&gt; AA
 
 Ex: From a In AA, b in BB  ==&gt; AA.SelectMany(Function(a) BB, Function(a, b) New With {a, b})
 
 Ex: {source with range variable 'd'} From a In AA, b in BB  ==&gt; source.SelectMany(Function(d) AA, Function(d, a) New With {d, a}).
                                                                        SelectMany(Function({d, a}) BB, 
                                                                                   Function({d, a}, b) New With {d, a, b})
 
 Note, that preceding Select operator can introduce unnamed range variable, which is dropped by the From
 
 Ex: From a In AA Select a + 1 From b in BB ==&gt; AA.Select(Function(a) a + 1).
                                                   SelectMany(Function(unnamed) BB,
                                                              Function(unnamed, b) b)  
 
 Also, depending on the amount of collection range variables declared by the From, and the following query operators,
 translation can produce a nested, as opposed to flat, compound variable.
 
 Ex: From a In AA From b In BB, c In CC, d In DD ==&gt; AA.SelectMany(Function(a) BB, Function(a, b) New With {a, b}).
                                                        SelectMany(Function({a, b}) CC, Function({a, b}, c) New With {{a, b}, c}).
                                                        SelectMany(Function({{a, b}, c}) DD, 
                                                                   Function({{a, b}, c}, d) New With {a, b, c, d})   
 
 If From operator translation results in a SelectMany call and the From is immediately followed by a Select or a Let operator, 
 they are absorbed by the From translation. When this happens, operatorsEnumerator is advanced appropriately.
 
 Ex: From a In AA From b In BB Select a + b ==&gt; AA.SelectMany(Function(a) BB, Function(a, b) a + b)
 
 Ex: From a In AA From b In BB Let c ==&gt; AA.SelectMany(Function(a) BB, Function(a, b) new With {a, b, c})
 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindCollectionRangeVariables(Roslyn.Compilers.VisualBasic.QueryClauseSyntax,Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax},Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryClauseSyntax}.Enumerator@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 See comments for BindFromClause method, this method actually does all the work.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindInnerJoinClause(Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.VisualBasic.JoinClauseSyntax,System.Collections.Generic.HashSet{System.String},Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryClauseSyntax}.Enumerator@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Given result of binding preceding query operators, the outer, bind the following Join operator.
 
     [{Preceding query operators}] Join {collection range variable} 
                                        [{additional joins}] 
                                   On {condition}
 
 Ex: From a In AA Join b in BB On Key(a) Equals Key(b)  ==&gt; AA.Join(BB, Function(a) Key(a), Function(b) Key(b), 
                                                                    Function(a, b) New With {a, b})
 
 Ex: From a In AA                       AA.Join(
     Join b in BB                               BB.Join(CC, Function(b) Key(b), Function(c) Key(c),
          Join c in CC             ==&gt;                  Function(b, c) New With {b, c}),
          On Key(c) Equals Key(b)               Function(a) Key(a), Function({b, c}) Key(b),
     On Key(a) Equals Key(b)                    Function(a, {b, c}) New With {a, b, c})
                                                                    
 
 Also, depending on the amount of collection range variables in scope, and the following query operators,
 translation can produce a nested, as opposed to flat, compound variable.
 
 Ex: From a In AA                       AA.Join(BB, Function(a) Key(a), Function(b) Key(b),
     Join b in BB                               Function(a, b) New With {a, b}).
     On Key(a) Equals Key(b)               Join(CC, Function({a, b}) Key(a, b), Function(c) Key(c),
     Join c in CC             ==&gt;               Function({a, b}, c) New With {{a, b}, c}).
     On Key(c) Equals Key(a, b)            Join(DD, Function({{a, b}, c}) Key(a, b, c), Function(d) Key(d),
     Join d in DD                               Function({{a, b}, c}, d) New With {a, b, c, d})
     On Key(a, b, c) Equals Key(d)
 
 If Join is immediately followed by a Select or a Let operator, they are absorbed by the translation. 
 When this happens, operatorsEnumerator is advanced appropriately.
 
 Ex: From a In AA Join b in BB On Key(a) Equals Key(b)  ==&gt; AA.Join(BB, Function(a) Key(a), Function(b) Key(b), 
     Select a + b                                                   Function(a, b) a + b)
 
 Ex: From a In AA Join b in BB On Key(a) Equals Key(b)  ==&gt; AA.Join(BB, Function(a) Key(a), Function(b) Key(b), 
     Let c                                                   Function(a, b) New With {a, b, c})
 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindGroupJoinClause(Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.VisualBasic.GroupJoinClauseSyntax,System.Collections.Generic.HashSet{System.String},Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryClauseSyntax}.Enumerator,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Given result of binding preceding query operators, the outer, bind the following Group Join operator.
 
     [{Preceding query operators}] Group Join {collection range variable} 
                                              [{additional joins}] 
                                   On {condition}
                                   Into {aggregation range variables}
 
 Ex: From a In AA Group Join b in BB          AA.GroupJoin(BB, Function(a) Key(a), Function(b) Key(b), 
                  On Key(a) Equals Key(b) ==&gt;              Function(a, group_b) New With {a, group_b.Count()})
                  Into Count()
 
 Also, depending on the amount of collection range variables in scope, and the following query operators,
 translation can produce a nested, as opposed to flat, compound variable (see BindInnerJoinClause for an example).
 
 Note, that type of the group must be inferred from the set of available GroupJoin operators in order to be able to 
 interpret the aggregation range variables. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindGroupByClause(Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.VisualBasic.GroupByClauseSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Given result of binding preceding query operators, the source, bind the following Group By operator.
 
     [{Preceding query operators}] Group [{items expression range variables}] 
                                   By {keys expression range variables}
                                   Into {aggregation range variables}
 
 Ex: From a In AA Group By Key(a)          AA.GroupBy(Function(a) Key(a), 
                  Into Count()     ==&gt;                Function(key, group_a) New With {key, group_a.Count()})
                  
 Ex: From a In AA Group Item(a)            AA.GroupBy(Function(a) Key(a), 
                  By Key(a)        ==&gt;                Function(a) Item(a), 
                  Into Count()                        Function(key, group_a) New With {key, group_a.Count()})
 
 Note, that type of the group must be inferred from the set of available GroupBy operators in order to be able to 
 interpret the aggregation range variables. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindGroupByItems(Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.VisualBasic.GroupByClauseSyntax,Roslyn.Compilers.VisualBasic.Binder.QueryLambdaBinder@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.RangeVariableSymbol}@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Returns Nothing if items were omitted.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.InferGroupType(Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.VisualBasic.GroupByClauseSyntax,Roslyn.Compilers.VisualBasic.BoundQueryLambda,Roslyn.Compilers.VisualBasic.BoundQueryLambda,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.RangeVariableSymbol},Roslyn.Compilers.VisualBasic.BoundMethodGroup@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Infer type of the group for a Group By operator from the set of available GroupBy methods.
 
 In short, given already bound itemsLambda and keysLambda, this method performs overload
 resolution over the set of available GroupBy operator methods using fake Into lambda:
     Function(key, group As typeToBeInferred) New With {group}
 
 If resolution succeeds, the type inferred for the best candidate is our result.  
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.InferGroupType(Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.VisualBasic.GroupJoinClauseSyntax,Roslyn.Compilers.VisualBasic.BoundQueryLambda,Roslyn.Compilers.VisualBasic.BoundQueryLambda,Roslyn.Compilers.VisualBasic.BoundMethodGroup@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Infer type of the group for a Group Join operator from the set of available GroupJoin methods.
 
 In short, given already bound inner source and the join key lambdas, this method performs overload
 resolution over the set of available GroupJoin operator methods using fake Into lambda:
     Function(outerVar, group As typeToBeInferred) New With {group}
 
 If resolution succeeds, the type inferred for the best candidate is our result.  
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindIntoSelectorLambda(Roslyn.Compilers.VisualBasic.QueryClauseSyntax,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.RangeVariableSymbol},Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean,System.Collections.Generic.HashSet{System.String},Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.RangeVariableSymbol},Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax},System.Boolean,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.Binder.IntoClauseBinder@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.RangeVariableSymbol}@)">
	<summary>
 This is a helper method to create a BoundQueryLambda for an Into clause 
 of a Group By or a Group Join operator. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindWhereClause(Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.VisualBasic.WhereClauseSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Given result of binding preceding query operators, the source, bind the following Where operator.
 
     {Preceding query operators} Where {expression}
 
 Ex: From a In AA Where a &gt; 0 ==&gt; AA.Where(Function(a) a &gt; b)
 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindSkipWhileClause(Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.VisualBasic.PartitionWhileClauseSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Given result of binding preceding query operators, the source, bind the following Skip While operator.
 
     {Preceding query operators} Skip While {expression}
 
 Ex: From a In AA Skip While a &gt; 0 ==&gt; AA.SkipWhile(Function(a) a &gt; b)
 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindTakeWhileClause(Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.VisualBasic.PartitionWhileClauseSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Given result of binding preceding query operators, the source, bind the following Take While operator.
 
     {Preceding query operators} Take While {expression}
 
 Ex: From a In AA Skip While a &gt; 0 ==&gt; AA.TakeWhile(Function(a) a &gt; b)
 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindFilterQueryOperator(Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.VisualBasic.QueryClauseSyntax,System.String,Roslyn.Compilers.TextSpan,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 This helper method does all the work to bind Where, Take While and Skip While query operators.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindDistinctClause(Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.VisualBasic.DistinctClauseSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Given result of binding preceding query operators, the source, bind the following Distinct operator.
 
     {Preceding query operators} Distinct
 
 Ex: From a In AA Distinct ==&gt; AA.Distinct()
 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindSkipClause(Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.VisualBasic.PartitionClauseSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Given result of binding preceding query operators, the source, bind the following Skip operator.
 
     {Preceding query operators} Skip {expression}
 
 Ex: From a In AA Skip 10 ==&gt; AA.Skip(10)
 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindTakeClause(Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.VisualBasic.PartitionClauseSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Given result of binding preceding query operators, the source, bind the following Take operator.
 
     {Preceding query operators} Take {expression}
 
 Ex: From a In AA Take 10 ==&gt; AA.Take(10)
 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindPartitionClause(Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.VisualBasic.PartitionClauseSyntax,System.String,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 This helper method does all the work to bind Take and Skip query operators.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindOrderByClause(Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.VisualBasic.OrderByClauseSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Given result of binding preceding query operators, the source, bind the following Order By operator.
 
     {Preceding query operators} Order By {orderings}
 
 Ex: From a In AA Order By a ==&gt; AA.OrderBy(Function(a) a)
 
 Ex: From a In AA Order By a.Key1, a.Key2 Descending ==&gt; AA.OrderBy(Function(a) a.Key1).ThenByDescending(Function(a) a.Key2)
 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.QueryLambdaBinder.BindSelectClauseSelector(Roslyn.Compilers.VisualBasic.SelectClauseSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryClauseSyntax}.Enumerator,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.RangeVariableSymbol}@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Bind body of a lambda representing Select operator selector in context of this binder.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.QueryLambdaBinder.BindExpressionRangeVariables(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax},System.Boolean,Roslyn.Compilers.VisualBasic.QueryClauseSyntax,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.RangeVariableSymbol}@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Bind Select like selector based on the set of expression range variables in context of this binder.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.QueryLambdaBinder.BindExpressionRangeVariable(Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax,System.Boolean,Roslyn.Compilers.VisualBasic.Binder,System.Collections.Generic.HashSet{System.String},Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Bind ExpressionRangeVariableSyntax in context of this binder.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.QueryLambdaBinder.BindLetClauseVariableSelector(Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryClauseSyntax}.Enumerator,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.RangeVariableSymbol}@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Bind Let operator selector for a particular ExpressionRangeVariableSyntax.
 Takes care of "carrying over" of previously declared range variables as well as introduction of the new one.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.QueryLambdaBinder.BindAbsorbingJoinSelector(Roslyn.Compilers.VisualBasic.QueryClauseSyntax,Roslyn.Compilers.VisualBasic.SyntaxList{Roslyn.Compilers.VisualBasic.QueryClauseSyntax}.Enumerator,Roslyn.Compilers.VisualBasic.SyntaxNode@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.RangeVariableSymbol}@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Bind Join/From selector that absorbs following Select/Let in context of this binder.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.QueryLambdaBinder.BuildJoinSelector(Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.RangeVariableSymbol,Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Bind Join/Let like and mixed selector in context of this binder.
 
 Join like selector: Function(a, b) New With {a, b}
 
 Let like selector: Function(a) New With {a, letExpressionRangeVariable}
 
 Mixed selector: Function(a, b) New With {a, b, letExpressionRangeVariable}
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.QueryLambdaBinder.BindJoinKeys(Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.JoinClauseSyntax,Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.VisualBasic.BoundQueryClauseBase,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.RangeVariableSymbol},Roslyn.Compilers.VisualBasic.BoundQueryLambda@,Roslyn.Compilers.VisualBasic.Binder.QueryLambdaBinder@,Roslyn.Compilers.VisualBasic.BoundQueryLambda@,Roslyn.Compilers.VisualBasic.Binder.QueryLambdaBinder@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Bind key selectors for a Join/Group Join operator.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Binder.QueryLambdaBinder.JoinConditionSideDeterminationVisitor">
	<summary>
 Helper visitor to determine what join sides are referenced by an expression.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Binder.QueryLambdaBinder.EqualsOperandIsBadErrorVisitor">
	<summary>
 Helper visitor to report query specific errors for an operand of an Equals expression.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Binder.QueryLambdaBinder">
	<summary>
 This is a top level binder used to bind bodies of query lambdas.
 It also contains a bunch of helper methods to bind bodies of a particular kind.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.IntoClauseBinder.BindIntoSelector(Roslyn.Compilers.VisualBasic.QueryClauseSyntax,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.RangeVariableSymbol},Roslyn.Compilers.VisualBasic.BoundExpression,System.Collections.Generic.HashSet{System.String},Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax},System.Boolean,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.RangeVariableSymbol}@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Given aggregationVariables, bind Into selector in context of this binder.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.IntoClauseBinder.BindAggregationRangeVariable(Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax,System.Collections.Generic.HashSet{System.String},Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Bind AggregationRangeVariableSyntax in context of this binder.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Binder.IntoClauseBinder">
	<summary>
 Knows how to bind FunctionAggregationSyntax and GroupAggregationSyntax
 within particular [Into] clause. 
 
 Also implements Lookup/LookupNames methods to make sure that lookup without 
 container type, uses type of the group as the container type.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Binder.IntoClauseDisallowGroupReferenceBinder">
	<summary>
 Same as IntoClauseBinder, but disallows references to GroupAggregationSyntax.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindCollectionRangeVariable(Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax,System.Boolean,System.Collections.Generic.HashSet{System.String},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Bind CollectionRangeVariableSyntax, applying AsQueryable/AsEnumerable/Cast(Of Object) calls and 
 Select with implicit type conversion as appropriate.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ApplyImplicitCollectionConversion(Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax,Roslyn.Compilers.VisualBasic.BoundQueryPart,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Apply "conversion" to the source based on the target AsClause Type of the CollectionRangeVariableSyntax.
 Returns implicit BoundQueryClause or the source, in case of an early failure.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ConvertToQueryableType(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.TypeSymbol@)">
	<summary>
 Convert source expression to queryable type by inferring control variable type 
 and applying AsQueryable/AsEnumerable or Cast(Of Object) calls.   
 
 In case of success, returns possibly "converted" source and non-Nothing controlVariableType.
 In case of failure, returns passed in source and Nothing as controlVariableType.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.InferControlVariableType(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Given query operator source, infer control variable type from available
 'Select' methods. 
 
 Returns inferred type or Nothing.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.InferControlVariableType(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.Symbol},System.Boolean@)">
	<summary>
 Given a set of 'Select' methods, infer control variable type. 
 
 Returns inferred type or Nothing.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.InferControlVariableType(Roslyn.Compilers.VisualBasic.MethodSymbol)">
	<summary>
 Given a method, infer control variable type. 
 
 Returns inferred type or Nothing.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.LookupQueryOperator(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.BoundExpression,System.String,Roslyn.Compilers.VisualBasic.BoundTypeArguments)">
	<summary>
 Return method group or Nothing in case nothing was found.
 Note, returned group might have ResultKind = "Inaccessible".
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindQueryOperatorCall(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.BoundExpression,System.String,Roslyn.Compilers.VisualBasic.BoundMethodGroup,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.TextSpan,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 [methodGroup] can be Nothing if lookup didn't find anything.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ValidateAndConvertIsExpressionArgument(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Validate and apply appropriate conversion for the target argument of Is/IsNot expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ForceLiftToEmptyString(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 This helper is used to wrap nullable argument into something that would return null string if argument is null.

 Unlike conversion to a string where nullable nulls result in an exception,         
 concatenation requires that nullable nulls are treated as null strings. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindUserDefinedShortCircuitingOperator(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.BinaryOperatorKind,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.OverloadResolution.OverloadResolutionResult@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 This function builds a bound tree representing an overloaded short circuiting expression
 after determining that the necessary semantic conditions are met.
 
 An expression of the form:
 
     x AndAlso y  (where the type of x is X and the type of y is Y)
 
 is an overloaded short circuit operation if X and Y are user-defined types and an
 applicable operator And exists after applying normal operator resolution rules.
 
 Given an applicable And operator declared in type T, the following must be true:
 
     - The return type and parameter types must be T.
     - T must contain a declaration of operator IsFalse.
 
 If these conditions are met, the expression "x AndAlso y" is translated into:
 
     !T.IsFalse(temp = x) ? T.And(temp, y) : temp
 
 The temporary is necessary for evaluating x only once. Similarly, "x OrElse y" is
 translated into:
 
     !T.IsTrue(temp = x) ? T.Or(temp, y) : temp
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.SubstituteDBNullWithNothingString(Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Returns Symbol for String type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetSpecialTypeForBinaryOperator(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.SpecialType,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Get symbol for a special type, reuse symbols for operand types to avoid type 
 lookups and construction of new instances of symbols.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetNullableTypeForBinaryOperator(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Get symbol for a Nullable type of particular type, reuse symbols for operand types to avoid type 
 lookups and construction of new instances of symbols.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ConvertNothingLiterals(Roslyn.Compilers.VisualBasic.BinaryOperatorKind,Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 §11.12.2 Object Operands
 The value Nothing is treated as the default value of the type of 
 the other operand in a binary operator expression. In a unary operator expression, 
 or if both operands are Nothing in a binary operator expression, 
 the type of the operation is Integer or the only result type of the operator, 
 if the operator does not result in Integer.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindObjectCollectionOrMemberInitializer(Roslyn.Compilers.VisualBasic.ObjectCreationExpressionSyntax,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.BoundWithLValueExpressionPlaceholder,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Binds the object collection or member initializer from a object creation.
 E.g. "new CollType() From {...}" or "new AType() With {...}"
 </summary>
	<param name="initializedObjectType">The type of the created object expression.</param>
	<param name="syntaxNode">The object creation expression syntax.</param>
	<param name="diagnostics">The diagnostics.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindObjectInitializer(Roslyn.Compilers.VisualBasic.ObjectCreationExpressionSyntax,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.BoundWithLValueExpressionPlaceholder,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Bind the ObjectInitializer.
 During the binding we basically bind the member access for each initializer, as well as the value that will be assigned.
 The main information stored in the bound node is a list of assignment operators (that may contain placeholders), as
 well as the information whether expression creates a temporary or not.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindCollectionInitializer(Roslyn.Compilers.VisualBasic.ObjectCreationExpressionSyntax,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Binds a object collection initializer.
 During the binding of this node we are binding calls to Add methods of the created object. Once the "collection" 
 type passed the requirements (same as for each collection requirements + must have accessible Add method), all 
 diagnostics are handled by the overload resolution.
 The bound node contains a list of call expressions (that may contain placeholders).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindCollectionInitializerElement(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.VisualBasic.BoundWithLValueExpressionPlaceholder,Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Binds a call expression for a given top level object collection initializer.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ObjectInitializerBinder.TryBindOmittedLeftForMemberAccess(Roslyn.Compilers.VisualBasic.MemberAccessExpressionSyntax,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.Binder,System.Boolean@)">
	<summary>
 Use the receiver of the ObjectCreationExpression as the omitted left of a member access.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ObjectInitializerBinder.TryBindOmittedLeftForDictionaryAccess(Roslyn.Compilers.VisualBasic.MemberAccessExpressionSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Use the receiver of the ObjectCreationExpression to as the omitted left of a dictionary access.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ObjectInitializerBinder">
	<summary>
 Special binder for binding ObjectInitializers. 
 This binder stores a reference to the receiver of the initialization, because fields in an object initializer can be 
 referenced with an omitted left expression in an member access expression (e.g. .Fieldname = .OtherFieldname).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.Lookup(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.NamespaceOrTypeSymbol,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Lookup a member name in a namespace or type, returning a LookupResult that
 summarizes the results of the lookup. See LookupResult structure for a detailed
 discussing of the meaning of the results. The supplied binder is used for accessibility
 checked and base class suppression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.Lookup(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.NamespaceSymbol,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Lookup a member name in a namespace, returning a LookupResult that
 summarizes the results of the lookup. See LookupResult structure for a detailed
 discussing of the meaning of the results. The supplied binder is used for accessibility
 checked and base class suppression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.LookupImmediate(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.NamespaceSymbol,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Lookup an immediate (without decending into modules) member name in a namespace, 
 returning a LookupResult that summarizes the results of the lookup. 
 See LookupResult structure for a detailed discussion of the meaning of the results. 
 The supplied binder is used for accessibility checks and base class suppression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.LookupInModules(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.NamespaceSymbol,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Lookup a member name in modules of a namespace, 
 returning a LookupResult that summarizes the results of the lookup. 
 See LookupResult structure for a detailed discussion of the meaning of the results. 
 The supplied binder is used for accessibility checks and base class suppression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.Lookup(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.TypeSymbol,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Lookup a member name in a type, returning a LookupResult that
 summarizes the results of the lookup. See LookupResult structure for a detailed
 discussing of the meaning of the results. The supplied binder is used for accessibility
 checked and base class suppression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.LookupInClass(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.TypeSymbol,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Lookup a member name in a module, class, struct, enum, or delegate, returning a LookupResult that
 summarizes the results of the lookup. See LookupResult structure for a detailed
 discussing of the meaning of the results. The supplied binder is used for accessibility
 checks and base class suppression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.LookupInSubmissions(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.TypeSymbol,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Lookup a member name in a submission chain.
 </summary>
	<remarks>
 We start with the current submission class and walk the submission chain back to the first submission.
 The search has two phases
 1) We are looking for any symbol matching the given name, arity, and options. If we don't find any the search is over.
    If we find an overloadable symbol(s) (a method or a property) we start looking for overloads of this kind 
    (lookingForOverloadsOfKind) of symbol in phase 2.
 2) If a visited submission contains a matching member of a kind different from lookingForOverloadsOfKind we stop 
    looking further. Otherwise, if we find viable overload(s) we add them into the result. Overloads modifier is ignored.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.MergeInternalXmlHelperValueIfNecessary(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.TypeSymbol,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Include the InternalXmlHelper.Value extension property in the LookupResult
 if the container implements IEnumerable(Of XElement), the name is "Value",
 and the arity is 0.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.IsDerivedInterface(Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,Roslyn.Utilities.ConsList{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 Checks if two interfaces have a base-derived relationship
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.MergeInterfaceLookupResults(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Utilities.ConsList{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 Merges two lookup results while eliminating symbols that are shadowed.
 Note that the final result may contain unrelated and possibly conflicting symbols as
 this helper is not intended to catch ambiguities.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.CompactAndAppend(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.Symbol},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 first.Where(t IsNot Nothing).Concat(second.Where(t IsNot Nothing))
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.AddBaseInterfacesToTheSearch(Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.NamedTypeSymbol,System.Collections.Generic.Queue{Roslyn.Compilers.VisualBasic.NamedTypeSymbol},System.Collections.Generic.HashSet{Roslyn.Compilers.VisualBasic.NamedTypeSymbol})">
	<summary>
	</summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.AnyShadows(Roslyn.Compilers.VisualBasic.LookupResult)">
	<summary>
 if any symbol in the list Shadows. This implies that name is not visible through the base.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MemberLookup.LookupWithoutInheritance(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.TypeSymbol,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Lookup a member name in a type without considering inheritance, returning a LookupResult that
 summarizes the results of the lookup. See LookupResult structure for a detailed
 discussing of the meaning of the results.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Binder.MemberLookup">
	<summary>
 This class handles binding of members of namespaces and types.
 The key member is Lookup, which handles looking up a name
 in a namespace or type, by name and arity, and produces a 
 lookup result. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.Report_ERRID_ReadOnlyInClosure(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 If we are inside a lambda in a constructor and are passing ByRef a non-LValue field, which 
 would be an LValue field, if it were referred to in the constructor outside of a lambda, 
 we need to report an error because the operation will result in a simulated pass by
 ref (through a temp, without a copy back), which might be not the intent.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LambdaBodyBinder">
	<summary>
 Provides context for binding body of a Lambda.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.IsConstructorCallAllowed(Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax,Roslyn.Compilers.VisualBasic.BoundMethodOrPropertyGroup)">
	<summary>
 Returns if all the rules for a "Me.New" or "MyBase.New" constructor call are satisfied:
   a) In instance constructor body
   b) First statement of that constructor
   c) "Me", "MyClass", or "MyBase" is the receiver.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindDirectConstructorCall(Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax,Roslyn.Compilers.VisualBasic.BoundMethodGroup,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Bind a Me.New(...), MyBase.New (...), MyClass.New(...) constructor call. 
 (NOT a normal constructor call like New Type(...)).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.IsIndexableType(Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Determine if given type is one that could possibly be indexed or called:
    An array, delegate, or one with a property group.
    Also allows Object only if Option Strict is not On (since we can late bind to an indexer).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.HasDefaultPropertyGroup(Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Returns True if the type has a default property/method.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindDefaultPropertyGroup(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Returns a BoundPropertyGroup if the expression represents a valid
 default property access. If there is a default property but the property
 access is invalid, a BoundBadExpression is returned. If there is no
 default property for the expression type, Nothing is returned.
 
 Note, that default Query Indexer may be a method, not a property.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ShouldBindWithoutArguments(Roslyn.Compilers.VisualBasic.BoundMethodOrPropertyGroup@)">
	<summary>
 Tests whether or not the method or property group should be bound without arguments. 
 In case of method group it may also update the group by filtering out all subs
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.OptimizeLibraryCall(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Optimizes some runtime library calls through replacing them with a literal if possible.
 VB Spec 11.2 defines the following runtime functions as being constant:
  - Microsoft.VisualBasic.Strings.ChrW
  - Microsoft.VisualBasic.Strings.Chr, if the constant value is between 0 and 128
  - Microsoft.VisualBasic.Strings.AscW, if the constant string is not empty
  - Microsoft.VisualBasic.Strings.Asc, if the constant string is not empty
 </summary>
	<param name="method">The method.</param>
	<param name="arguments">The arguments of the method call.</param>
	<param name="syntax">The syntax node for report errors.</param>
	<param name="diagnostics">The diagnostics.</param>
	<param name="hasErrors">Set to true if there are conversion errors (e.g. Asc("")). Otherwise it's not written to.</param>
	<returns>The constant value that replaces this node, or nothing.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetSetOfTheBestCandidates(Roslyn.Compilers.VisualBasic.OverloadResolution.OverloadResolutionResult@,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.Symbol}@)">
	<summary>
Figure out the set of best candidates in the following preference order:
  1) Applicable
  2) TypeInferenceFailed
  3) ArgumentMismatch, GenericConstraintsViolated
  4) ArgumentCountMismatch
  5) BadGenericArity
  6) Ambiguous
  7) HasUseSiteError
 
 Also return the set of unique symbols behind the set.
 
 Returns type symbol for the common type, if any.
 Otherwise returns ErrorTypeSymbol.UnknownResultType.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ReportOverloadResolutionFailureForASingleCandidate(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.LookupResultKind,Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.ReadOnlyArray{System.String},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.Location},System.Boolean,System.Boolean,System.Boolean,System.Boolean,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.Symbol,System.Boolean)">
	<summary>
 Should be kept in sync with OverloadResolution.MatchArguments. Anything that 
 OverloadResolution.MatchArguments flags as an error should be detected by 
 this function as well. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ReportByRefConversionErrors(Roslyn.Compilers.VisualBasic.OverloadResolution.Candidate,Roslyn.Compilers.VisualBasic.ParameterSymbol,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Should be in sync with OverloadResolution.MatchArgumentToByRefParameter
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ReportByValConversionErrors(Roslyn.Compilers.VisualBasic.OverloadResolution.Candidate,Roslyn.Compilers.VisualBasic.ParameterSymbol,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.Symbol)">
	<summary>
 Should be in sync with OverloadResolution.MatchArgumentToByValParameter.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.PassArguments(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundExpression},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Should be kept in sync with OverloadResolution.MatchArguments, which populates 
 data this function operates on.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.IsCallStatementContext(Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax)">
	<summary>
 Return true if the node is an immediate child of a call statement.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.Binder.ProcessedFieldOrPropertyInitializers.HasAnyErrors">
	<summary> 
 Indicate the fact that binding of initializers produced a tree with errors. 
 This property does not indicate whether or not a diagnostic was produced during the 
 binding of the initializers. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Binder.ProcessedFieldOrPropertyInitializers">
	<summary>
 Used to store the bound field and property initializers and the associated list of
 bound assignment statements because they are reused for multiple constructors
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindFieldAndPropertyInitializers(Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.FieldOrPropertyInitializer}},Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.Binder.ProcessedFieldOrPropertyInitializers@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Binds all field initializers of a <see cref="T:Roslyn.Compilers.VisualBasic.SourceNamedTypeSymbol"/>.
 </summary>
	<param name="symbol">The named type symbol where the field initializers are declared.</param>
	<param name="scriptCtorOpt">Script constructor or Nothing if not binding top-level statements.</param>
	<param name="initializers">The initializers itself. For each partial type declaration there is an array of 
 field initializers</param>
	<param name="processedFieldInitializers">The structure storing the list of processed field initializers.</param>
	<param name="diagnostics">The diagnostics.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindArrayFieldImplicitInitializer(Roslyn.Compilers.VisualBasic.SourceFieldSymbol,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.BoundInitializer},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Bind an initializer for an implicitly allocated array field (for example: Private F(2) As Object).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindFieldInitializer(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.Symbol},Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.BoundInitializer},Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 Binds the field initializer. A bound field initializer contains the bound field access and bound init value.
 </summary>
	<param name="fieldSymbols">The field symbol.</param>
	<param name="equalsValueOrAsNewSyntax">The syntax node for the optional initialization.</param>
	<param name="boundInitializers">The array of bound initializers to add the newly bound ones to.</param>
	<param name="diagnostics">The diagnostics.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindConstFieldInitializer(Roslyn.Compilers.VisualBasic.SourceFieldSymbol,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.BoundInitializer},Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Checks for errors in the constant initialization of a field, and only returns a BoundFieldOrPropertyInitializer for
 decimals and dates because they aren't compile time constant in CLR. Other data type end up directly in metadata and 
 do not cause a BoundFieldOrPropertyInitializer node.
 </summary>
	<param name="fieldSymbol">The field symbol.</param>
	<param name="equalsValueOrAsNewSyntax">The syntax node for the optional initialization.</param>
	<param name="boundInitializers">The array of bound initializers to add the newly bound ones to.</param>
	<param name="diagnostics">The diagnostics.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindFieldAndEnumConstantInitializer(Roslyn.Compilers.VisualBasic.FieldSymbol,Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Binds constant initialization value of the field.
 </summary>
	<param name="fieldSymbol">The symbol.</param>
	<param name="equalsValueOrAsNewSyntax">The initialization syntax.</param>
	<param name="diagnostics">The diagnostics.</param><returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindLocalConstantInitializer(Roslyn.Compilers.VisualBasic.LocalSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax,Roslyn.Compilers.VisualBasic.EqualsValueSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Binds a constant local's value. 
 </summary>
	<param name="symbol">The local symbol.</param>
	<param name="type">The local symbol's type. It is passed in because this method is called while the type is being resolved and before it is set.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindParameterDefaultValue(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.EqualsValueSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Binds a parameter's default value syntax
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ImportData">
	<summary>
 Data for Binder.BindImportClause that exposes dictionaries of
 the members and aliases that have been bound during the
 execution of BindImportClause. It is the responsibility of derived
 classes to update the dictionaries in AddMember and AddAlias.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ImportsBinder.AllowAliasWithUseSiteError(Roslyn.Compilers.DiagnosticInfo)">
	<summary>
 Checks use site error and returns True in case the alias should still be created for the
 type with this site error. In current implementation checks for errors ##36924, 36925
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Binder.ImportsBinder">
	<summary>
 The Imports binder handles binding of Imports statements in files, and also the project-level imports.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindExpression(Roslyn.Compilers.VisualBasic.ExpressionSyntax,System.Boolean,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 The dispatcher method that handles syntax nodes for all stand-alone expressions.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BadExpression(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Create a BoundBadExpression node for the given syntax node. No symbols or bound nodes are associated with it.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BadExpression(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.BoundNode,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Create a BoundBadExpression node for the given childexpression, which is preserved as a sub-expression. 
 No ResultKind is associated
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BadExpression(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.BoundNode,Roslyn.Compilers.VisualBasic.LookupResultKind,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Create a BoundBadExpression node for the given childexpression, which is preserved as a sub-expression. 
 A ResultKind explains why the node is bad.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BadExpression(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundNode},Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Create a BoundBadExpression node for the given child expression, which is preserved as a sub-expression. Symbols
 associated with the child node are not given a result kind.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindQualifiedName(Roslyn.Compilers.VisualBasic.QualifiedNameSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 This function is only needed for SemanticModel to perform binding for erroneous cases.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindValue(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 BindValue evaluates the node and returns a BoundExpression.  BindValue snaps expressions to values.  For now that means that method groups
 become invocations.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.AdjustReceiverTypeOrValue(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.SyntaxNode,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Adjusts receiver of a call or a member access.
  * will turn Unknown property access into Get property access
  * will turn TypeOrValueExpression into a value expression
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.AdjustReceiverValue(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Adjusts receiver of a call or a member access if it is a value
  * will turn Unknown property access into Get property access
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindRValue(Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 BindRValue evaluates the node and returns a BoundExpression.  
 It ensures that the expression is a value that can be used on the right hand side of an assignment.  
 If not, it reports an error.
 
 Note that this function will reclassify all expressions to have their "default" type, i.e.
 Anonymous Delegate for a lambda, default array type for an array literal, will report an error 
 for an AddressOf, etc. So, if you are in a context where there is a known target type for the 
 expression, do not use this function. Instead, use BindValue followed by 
 ApplyImplicitConversion/ApplyConversion.  
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.IsLValueFieldAccess(Roslyn.Compilers.VisualBasic.FieldSymbol,Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Determine whether field access should be treated as LValue. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.KindOfContainingMethodAtRunTime">
	<summary>
 Return MethodKind corresponding to the method the code being interpreted is going to end up in.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GenerateDiagnosticsForDominantTypeInferenceInIfExpression(Roslyn.Compilers.VisualBasic.TypeSymbol,System.Int32,Roslyn.Compilers.VisualBasic.ExpressionSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary> Process the result of dominant type inference, generate diagnostics </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.IsInsideChainedConstructorCallArguments">
	<summary>
 True if inside in binding arguments of constructor 
 call with {'Me'/'MyClass'/'MyBase'}.New(...) from anothir constructor
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.CanAccessMyBase(System.Boolean,Roslyn.Compilers.VisualBasic.ERRID@)">
	<summary>
 Can we access MyBase in this location. If False is returned, 
 also returns the error id associated with that.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.CanAccessMe(System.Boolean,Roslyn.Compilers.VisualBasic.ERRID@)">
	<summary>
 Can we access Me in this location. If False is returned, 
 also returns the error id associated with that.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.CanAccessMyClass(System.Boolean,Roslyn.Compilers.VisualBasic.ERRID@)">
	<summary>
 Can we access MyClass in this location. If False is returned, 
 also returns the error id associated with that.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindSimpleName(Roslyn.Compilers.VisualBasic.LookupResult,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Second part of BindSimpleName.
 It is a separate function so that it could be called directly 
 when we have already looked up for the name.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindMemberAccess(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.SimpleNameSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary> 
 Method binds member access in case when we got hold 
 of a bound node representing the left expression 
 </summary>
	<remarks> 
 The method is protected, so that it can be called from other 
 binders overriding TryBindMemberAccessWithLeftOmitted
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TryBindOmittedLeftForMemberAccess(Roslyn.Compilers.VisualBasic.MemberAccessExpressionSyntax,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.Binder,System.Boolean@)">
	<summary> 
 Returns a bound node for left part of member access node with omitted left syntax. 
 In particular it handles member access inside With statement.
 
 By default the method delegates the work to it's containing binder or returns Nothing.
 </summary>
	<param name="accessingBinder">
 Specifies the binder which requests an access to the bound node for omitted left.
 </param>
	<param name="wholeMemberAccessExpressionBound">
 NOTE: in some cases, like for binding inside anonymous object creation expression, this 
 method returns bound node for the whole expression rather than only for omitted left part. 
 </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetLocalSymbolType(Roslyn.Compilers.VisualBasic.LocalSymbol,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Given a localSymbol and a syntaxNode where the symbol is used, safely return the symbol's type.
 </summary>
	<param name="localSymbol">The local symbol</param>
	<param name="node">The syntax node that references the symbol</param>
	<param name="diagnostics">diagnostic bag if errors are to be reported</param>
	<returns>Returns the symbol's type or an ErrorTypeSymbol if the local is referenced before its definition or if the symbol is still being bound.</returns>
	<remarks>This method safely returns a local symbol's type by checking for circular references or references before declaration.</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.TryBindOmittedLeftForDictionaryAccess(Roslyn.Compilers.VisualBasic.MemberAccessExpressionSyntax,Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.DiagnosticBag)">
	<summary> 
 Returns a bound node for left part of dictionary access node with omitted left syntax. 
 In particular it handles dictionary access inside With statement.
 
 By default the method delegates the work to it's containing binder or returns Nothing.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindArrayCreationExpression(Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
  Handle ArrayCreationExpressionSyntax
   new integer(n)(,) {...}
   new integer() {...}
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindArrayInitializerList(Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax,Roslyn.Compilers.VisualBasic.ArrayTypeSymbol,Roslyn.Compilers.VisualBasic.Binder.DimensionSize[],Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Binds CollectionInitializeSyntax. i.e. { expr, ... } from an ArrayCreationExpressionSyntax
 </summary>
	<param name="node">The collection initializer syntax</param>
	<param name="type">The type of array.</param>
	<param name="knownSizes">This is in/out.  It comes in with sizes from explicit bounds but will be updated based on the number of initializers for dimensions without bounds</param>
	<param name="diagnostics">Where to put errors</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindArrayInitializerList(Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax,Roslyn.Compilers.VisualBasic.Binder.DimensionSize[],System.Boolean@,System.Int32@,Roslyn.Compilers.VisualBasic.TypeSymbol@,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Binds CollectionInitializeSyntax. i.e. { expr, ... } from an ArrayCreationExpressionSyntax
 </summary>
	<param name="node">The collection initializer syntax</param>
	<param name="knownSizes">This is in/out.  It comes in with sizes from explicit bounds but will be updated based on the number of initializers for dimensions without bounds</param>
	<param name="hasDominantType">When the inferred type is Object() indicates that the dominant type algorithm computed this type.</param>
	<param name="numberOfCandidates">The number of candidates found during inference</param>
	<param name="inferredElementType">The inferred element type</param>
	<param name="diagnostics">Where to put errors</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindArrayBounds(Roslyn.Compilers.VisualBasic.ArgumentListSyntax,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.Binder.DimensionSize[],System.Boolean)">
	<summary>
 Bind the array bounds and return the sizes for each dimension.
 </summary>
	<param name="arrayBoundsOpt">The bounds</param>
	<param name="diagnostics">Where to put the errors</param>
	<param name="knownSizes">The bounds if they are constants, if argument is not specified this info is not returned </param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ReportDiagnosticAndProduceBadExpression(Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.ERRID,System.Object[])">
	<summary>
 Report a diagnostic, and also produce an error expression with error type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ReportDiagnosticAndProduceBadExpression(Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.DiagnosticInfo,Roslyn.Compilers.VisualBasic.BoundNode[])">
	<summary>
 Report a diagnostic, and also produce an error expression with error type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ReportDiagnosticAndProduceErrorTypeSymbol(Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.ERRID,System.Object[])">
	<summary>
 Report a diagnostic, and also produce an error expression with error type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ReportDiagnosticAndProduceErrorTypeSymbol(Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.DiagnosticInfo)">
	<summary>
 Report a diagnostic, and also produce an error expression with error type.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Binder.DelegateResolutionResult">
	<summary>
 Structure is used to store all information which is needed to construct and classify a Delegate creation 
 expression later on.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindAddressOfExpression(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Binds the AddressOf expression.
 </summary>
	<param name="node">The AddressOf expression node.</param>
	<param name="diagnostics">The diagnostics.</param><returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BindDelegateCreationExpression(Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.ArgumentListSyntax,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Binds the delegate creation expression.
 This comes in form of e.g.
 Dim del as new DelegateType(AddressOf methodName)
 </summary>
	<param name="delegateType">Type of the delegate.</param>
	<param name="argumentListOpt">The argument list.</param>
	<param name="node">Syntax node to attach diagnostics to in case the argument list is nothing.</param>
	<param name="diagnostics">The diagnostics.</param><returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.InterpretDelegateBinding(Roslyn.Compilers.VisualBasic.BoundAddressOfOperator,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean)">
	<summary>
 Resolves the target method for the delegate and classifies the conversion
 </summary>
	<param name="addressOfExpression">The bound AddressOf expression itself.</param>
	<param name="targetType">The delegate type to assign the result of the AddressOf operator to.</param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ResolveMethodForDelegateInvokeFullAndRelaxed(Roslyn.Compilers.VisualBasic.BoundAddressOfOperator,Roslyn.Compilers.VisualBasic.MethodSymbol,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Resolves the method for delegate invoke with all or relaxed arguments / return types. It also determines 
 the method conversion kind.
 </summary>
	<param name="addressOfExpression">The AddressOf expression.</param>
	<param name="toMethod">The delegate invoke method.</param>
	<param name="ignoreMethodReturnType">Ignore method's return type for the purpose of calculating 'methodConversions'.</param>
	<param name="diagnostics">The diagnostics.</param>
	<returns>The resolved method if any.</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ResolveMethodForDelegateInvokeFullOrRelaxed(Roslyn.Compilers.VisualBasic.BoundAddressOfOperator,Roslyn.Compilers.VisualBasic.MethodSymbol,System.Boolean,Roslyn.Compilers.DiagnosticBag,System.Boolean,System.Boolean@)">
	<summary>
 Resolves the method for delegate invoke with all or relaxed arguments / return types. It also determines 
 the method conversion kind.
 </summary>
	<param name="addressOfExpression">The AddressOf expression.</param>
	<param name="toMethod">The delegate invoke method.</param>
	<param name="ignoreMethodReturnType">Ignore method's return type for the purpose of calculating 'methodConversions'.</param>
	<param name="diagnostics">The diagnostics.</param>
	<param name="useZeroArgumentRelaxation">if set to <c>true</c> use zero argument relaxation.</param>
	<returns>The resolved method if any.</returns>
</member><member name="T:Roslyn.Compilers.VisualBasic.Binder.OptionStrictOffBinder">
	<summary>
 Makes it look like Option Strict is Off, all other operations
 are delegated up the chain.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetDelegateMethodConversionBasedOnArguments(Roslyn.Compilers.VisualBasic.OverloadResolution.CandidateAnalysisResult,Roslyn.Compilers.VisualBasic.MethodSymbol)">
	<summary>
 Determines the method conversion for delegates based on the arguments.
 </summary>
	<param name="bestResult">The resolution result.</param>
	<param name="delegateInvoke">The delegate invoke method.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ClassifyAddressOfConversion(Roslyn.Compilers.VisualBasic.BoundAddressOfOperator,Roslyn.Compilers.VisualBasic.TypeSymbol)">
	<summary>
 Classifies the address of conversion. 
 </summary>
	<param name="source">The bound AddressOf expression.</param>
	<param name="destination">The target type to convert this AddressOf expression to.</param><returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.CheckDelegateParameterModifier(Roslyn.Compilers.VisualBasic.Binder,Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.SyntaxToken,Roslyn.Compilers.VisualBasic.SourceParameterFlags,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Checks if a parameter is a ParamArray and reports this as an error.
 </summary>
	<param name="binder">The binder.</param>
	<param name="container">The containing type.</param>
	<param name="token">The current parameter token.</param>
	<param name="flag">The flags of this parameter.</param>
	<param name="diagnostics">The diagnostics.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ReclassifyAddressOf(Roslyn.Compilers.VisualBasic.BoundAddressOfOperator,Roslyn.Compilers.VisualBasic.Binder.DelegateResolutionResult@,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 Reclassifies the bound address of operator into a delegate creation expression (if there is no delegate 
 relaxation required) or into a bound lambda expression (which gets a delegate creation expression later on)
 </summary>
	<param name="addressOfExpression">The AddressOf expression.</param>
	<param name="delegateResolutionResult">The delegate resolution result.</param>
	<param name="targetType">Type of the target.</param>
	<param name="diagnostics">The diagnostics.</param><returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BuildDelegateRelaxationLambda(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.BoundMethodGroup,Roslyn.Compilers.VisualBasic.ConversionKind,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Build a lambda that has a shape of the [delegateInvoke] and calls 
 the only method from the [methodGroup] passing all parameters of the lambda
 as arguments for the call.
 Note, that usually the receiver of the [methodGroup] should be captured before entering the 
 relaxation lambda in order to prevent its reevaluation every time the lambda is invoked and 
 prevent its mutation. 
 
             !!! Therefore, it is not common to call this overload directly. !!!
 
 </summary>
	<param name="syntaxNode">Location to use for various synthetic nodes and symbols.</param>
	<param name="delegateInvoke">The Invoke method to "implement".</param>
	<param name="methodGroup">The method group with the only method in it.</param>
	<param name="delegateRelaxation">Delegate relaxation to store withing the new BoundLambda node.</param>
	<param name="diagnostics"></param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ApplyImplicitConversion(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 This function must return a BoundConversion node in case of non-identity conversion.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ApplyConversion(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.BoundExpression,System.Boolean,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 This function must return a BoundConversion node in case of explicit or non-identity conversion.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.CreateConversionAndReportDiagnostic(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.BoundExpression,System.Collections.Generic.KeyValuePair{Roslyn.Compilers.VisualBasic.ConversionKind,Roslyn.Compilers.VisualBasic.MethodSymbol},System.Boolean,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.DiagnosticBag,System.String)">
	<summary>
 This function must return a BoundConversion node in case of non-identity conversion.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.MakeVarianceConversionSuggestion(Roslyn.Compilers.VisualBasic.ConversionKind,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 Returns True if error or warning was reported.
 
 This function is invoked on the occassion of a Narrowing or NoConversion.
 It looks at the conversion. If the conversion could have been helped by variance in
 some way, it reports an error/warning message to that effect and returns true. This
 message is a substitute for whatever other conversion-failed message might have been displayed.

 Note: these variance-related messages will NOT show auto-correct suggestion of using CType. That's
 because, in these cases, it's more likely than not that CType will fail, so it would be a bad suggestion
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ReclassifyExpression(Roslyn.Compilers.VisualBasic.BoundExpression@,Roslyn.Compilers.VisualBasic.SyntaxKind,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.ConversionKind,System.Boolean,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Handle expression reclassification, if any applicable.
 
 If function returns True, the "argument" parameter has been replaced
 with result of reclassification (possibly an error node) and appropriate
 diagnostic, if any, has been reported.
 
 If function returns false, the "argument" parameter must be unchanged and no 
 diagnostic should be reported. 
 
 conversionSemantics can be one of these: 
       SyntaxKind.CTypeKeyword, SyntaxKind.DirectCastKeyword, SyntaxKind.TryCastKeyword
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetAttributes(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.Binder},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.AttributeSyntax},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.NamedTypeSymbol},Roslyn.Compilers.VisualBasic.AttributeData[],Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Gets but does not fully validate a symbol's attributes. Returns binding errors but not attribute usage and attribute specific errors.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Binder.AttributeExpressionVisitor">
	<summary>
 Walk a custom attribute argument bound node and return a CommonTypedConstant.  Verify that the expression is a constant expression.
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.Binder.AnonymousTypeCreationBinder._freeze">
	<summary>
 If set, the state of the binder shouldn't be modified by subsequent binding operations,
 which could be performed by SemanicModel in context of this binder.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Binder.AnonymousTypeCreationBinder">
	<summary>
 Binder to be used for binding New With { ... } expressions. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Binder.AnonymousTypeFieldInitializerBinder">
	<summary>
 Having this binder, which is created for each field initializer within AnonymousObjectCreationExpressionSyntax
 gives us the following advantages:
   - We no longer rely on transient state of AnonymousTypeField objects to detect out of order field references
     within initializers. This way we can be sure that result of binding performed by SemanticModel is consistent
     with result of initial binding of the entire node.
   - AnonymousTypeCreationBinder overrides CreateAnonymousObjectCreationExpression in such a way that it mutates
     its state. That overriden method shouldn't be called while we are binding each initializer (by queries, for example), 
     it should be called only by AnonymousTypeCreationBinder itself after all initializers are bound and we are producing 
     the resulting node. So having an extra binder in between takes care of that.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BinderSpecificLookupOptions(Roslyn.Compilers.VisualBasic.LookupOptions)">
	<summary>
 If the binding context requires specific binding options, then modify the given
 lookup options accordingly.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.Lookup(Roslyn.Compilers.VisualBasic.LookupResult,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions)">
	<summary>
 Lookup the given name in the binder and containing binders.
 Returns the result of the lookup. See the definition of LookupResult for details.
 </summary>
	<remarks>
 This method is virtual, but usually there is no need to override it. It
 calls the virtual LookupInSingleBinder, which should be overridden instead,
 for each binder in turn, and merges the results.
 Overriding this method is needed only in limited scenarios, for example for
 a binder that binds query [Into] clause and has implicit qualifier.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.LookupInSingleBinder(Roslyn.Compilers.VisualBasic.LookupResult,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Lookup in just a single binder, without delegating to containing binder. The original
 binder passed in is used for accessibility checking and so forth.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.CollectExtensionMethodsInSingleBinder(System.String,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.MethodSymbol},Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Collect extension methods with the given name that are in scope in this binder.
 The passed in ArrayBuilder must be empty. Extension methods from the same containing type
 must be grouped together.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.AddExtensionMethodLookupSymbolsInfoInSingleBinder(Roslyn.Compilers.VisualBasic.LookupSymbolsInfo,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Lookup all names of extension methods that are available from a single binder, without delegating
 to containing binder. The original binder passed in is used for accessibility checking
 and so forth.
 Names that are available are inserted into "nameSet". This is a hashSet that accumulates
 names, and should be created with the VB identifierComparer.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.LookupLabelByNameToken(Roslyn.Compilers.VisualBasic.SyntaxToken)">
	<summary>
 Lookups labels by label names, returns a label or Nothing
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.AddLookupSymbolsInfoInSingleBinder(Roslyn.Compilers.VisualBasic.LookupSymbolsInfo,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Lookup all names that are available from a single binder, without delegating
 to containing binder. The original binder passed in is used for accessibility checking
 and so forth.
 Names that are available are inserted into "nameSet". This is a hashSet that accumulates
 names, and should be created with the VB identifierComparer.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.CheckAccessibility(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Utilities.ConsList{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 Determine if "sym" is accessible from the location represented by this binder. For protected
 access, use the qualifier type "accessThroughType" if not Nothing (if Nothing just check protected
 access with no qualifier).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.IsAccessible(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.TypeSymbol,Roslyn.Utilities.ConsList{Roslyn.Compilers.VisualBasic.Symbol})">
	<summary>
 Determine if "sym" is accessible from the location represented by this binder. For protected
 access, use the qualifier type "accessThroughType" if not Nothing (if Nothing just check protected
 access with no qualifier).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetBinder(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Some nodes have special binder's for their contents
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetBinder(Roslyn.Compilers.VisualBasic.SeparatedSyntaxList{Roslyn.Compilers.VisualBasic.StatementSyntax})">
	<summary>
 Some nodes have special binder's for their contents
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.ContainingMember">
	<summary>
 The member containing the binding context
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.IsInQuery">
	<summary>
 Tells whether binding is happening in a query context.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.IsInLambda">
	<summary>
 Tells whether binding is happening in a lambda context.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.IsUnboundTypeAllowed(Roslyn.Compilers.VisualBasic.GenericNameSyntax)">
	<summary>
 Returns true if the node is in a position where an unbound type
 such as (C(of)) is allowed.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.ContainingType">
	<summary>
 The type containing the binding context
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.BindingTopLevelScriptCode">
	<summary>
 Returns true if the binder is binding top-level script code.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.ContainingNamespaceOrType">
	<summary>
 The namespace or type containing the binding context
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetSpecialType(Roslyn.Compilers.SpecialType,Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Get the built-in MSCORLIB type identified. If it's not available (an error type), then report the
 error with the given syntax and diagnostic bag. If the node and diagBag are Nothing, then don't report the error (not recommended).
 </summary>
	<param name="typeId">Type to get</param>
	<param name="node">Where to report the error, if any.</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetWellKnownType(Roslyn.Compilers.WellKnownType,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 This is a layer on top of the Compilation version that generates a diagnostic if the well-known
 type isn't found.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetSpecialTypeMember(Roslyn.Compilers.SpecialMember,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 This is a layer on top of the assembly version that generates a diagnostic if the well-known
 member isn't found.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetWellKnownTypeMember(Roslyn.Compilers.WellKnownMember,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 This is a layer on top of the Compilation version that generates a diagnostic if the well-known
 member isn't found.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.SourceModule">
	<summary>
 Get the source module.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.Compilation">
	<summary>
 Get the compilation.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetErrorSymbol(System.String,Roslyn.Compilers.DiagnosticInfo,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.Symbol},Roslyn.Compilers.VisualBasic.LookupResultKind)">
	<summary>
 Get an error symbol.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetLocation(Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken)">
	<summary>
 Get the Location associated with a given syntax node.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetLocation(Roslyn.Compilers.TextSpan)">
	<summary>
 Get the Location associated with a given TextSpan.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetSyntaxReference(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Get a SyntaxReference associated with a given syntax node.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.SyntaxTree">
	<summary>
 Returns the syntax tree.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.BasesBeingResolved">
	<summary>
 Called in member lookup right before going into the base class of a type. Results a set of named types whose
 bases classes are currently in the process of being resolved, so we shouldn't look into their bases
 again to prevent/detect circular references.
 </summary>
	<returns>Nothing if no bases being resolved, otherwise the set of bases being resolved.</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.IgnoreBaseClassesInLookup">
	<summary>
 Called during member lookup before going into the base class of a type. If returns
 true, the base class is ignored. Primarily used for binding Imports.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.OptionStrict">
	<summary>
 Current Option Strict mode.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.OptionInfer">
	<summary>
 True if Option Infer On is in effect. False if Option Infer Off is in effect.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.OptionExplicit">
	<summary>
 True if Option Explicit On is in effect. False if Option Explicit Off is in effect.
 Note that even if Option Explicit Off is in effect, there are places (field initializers)
 where implicit variable declaration is not permitted. See the ImplicitVariablesDeclarationAllowedHere
 property also.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.OptionCompareText">
	<summary>
 True if Option Compare Text is in effect. False if Option Compare Binary is in effect.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.CheckOverflow">
	<summary>
 True if integer overflow checking is off.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.AllImplicitVariableDeclarationsAreHandled">
	<summary>
 True if implicit variable declaration is available within this binder, and the binder
 has already finished binding all possible implicit declarations inside (and is not accepting)
 any more.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.ImplicitVariableDeclarationAllowed">
	<summary>
 True if implicit variable declaration is allow by the language here. Differs from OptionExplicit
 in that it is only try if this binder is associated with a region that allows implicit variable
 declaration (field initializers and attributes don't, for example).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DeclareImplicitLocalVariable(Roslyn.Compilers.VisualBasic.IdentifierNameSyntax,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Declare an implicit local variable. The type of the local is determined
 by the type character (if any) on the variable.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.ImplicitlyDeclaredVariables">
	<summary>
 Get all implicitly declared variables that were declared in this method body.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.DisallowFurtherImplicitVariableDeclaration">
	<summary>
 Disallow additonal local variable declaration
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetExitLabel(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Get the label that a Exit XXX statement should branch to, or Nothing if we are
 not inside a context that would be exited by that kind of statement. The passed in kind
 is the SyntaxKind for the exit statement that would target the label (e.g. SyntaxKind.ExitDoStatement).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetContinueLabel(Roslyn.Compilers.VisualBasic.SyntaxKind)">
	<summary>
 Get the label that a Continue XXX statement should branch to, or Nothing if we are
 not inside a context that would be exited by that kind of statement. The passed in kind
 is the SyntaxKind for the exit statement that would target the label (e.g. SyntaxKind.ContinueDoStatement).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetReturnLabel">
	<summary>
 Get the label that a Return statement should branch to, or Nothing if we are
 not inside a context that would be exited by that kind of statement. This method
 is equivalent to calling <see cref="M:Roslyn.Compilers.VisualBasic.Binder.GetExitLabel(Roslyn.Compilers.VisualBasic.SyntaxKind)"/> with the appropriate exit
 <see cref="T:Roslyn.Compilers.VisualBasic.SyntaxKind"/>.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetLocalForFunctionValue">
	<summary>
 Get the special local symbol with the same name as the enclosing function.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ReportDiagnostic(Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.VisualBasic.SyntaxNodeOrToken,Roslyn.Compilers.VisualBasic.ERRID)">
	<summary>
 Create a diagnostic at a particular syntax node and place it in a diagnostic bag.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.BindingLocation">
	<summary>
 Returns the type of construct being bound (BaseTypes, MethodSignature,
 etc.) to allow the Binder to provide different behavior in certain cases.
 Currently, this property is only used by ShouldCheckConstraints.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.IsEarlyAttributeBinder">
	<summary>
 Returns true if the binder is performing early decoding of a
 (well-known) attribute.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.ShouldCheckConstraints">
	<summary>
 Return True if type constraints should be checked when binding.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.Binder.HasImportedXmlNamespaces">
	<summary>
 Returns True if the binder, or any containing binder, has xmlns Imports.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetInScopeXmlNamespaces(System.Action{System.String,System.String})">
	<summary>
 Invoke the callback for each { prefix, namespace } pair from the explicitly declared
 namespaces in the XmlElement hierarchy. The order of the pairs is the order the xmlns
 attributes are declared on each element, and from innermost to outermost element.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ReportUseSiteErrorForSynthesizedAttribute(Roslyn.Compilers.WellKnownMember,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 This method reports use site errors if a required attribute constructor is missing.
 Some attributes are considered to be optional (e.g. the CompilerGeneratedAttribute). In this case the use site
 errors will be ignored.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.ReportUseSiteErrorForSynthesizedAttribute(Roslyn.Compilers.WellKnownMember,Roslyn.Compilers.VisualBasic.Compilation,Roslyn.Compilers.VisualBasic.Location,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 This method reports use site errors if a required attribute constructor is missing.
 Some attributes are considered to be optional (e.g. the CompilerGeneratedAttribute). In this case the use site
 errors will be ignored.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.Binder.GetWithStatementPlaceholderSubstitute(Roslyn.Compilers.VisualBasic.BoundValuePlaceholderBase)">
	<summary>
 Returns a placeholder substitute for a With statement placeholder specified or Nothing if not found

 Note: 'placeholder' is needed to make sure the binder can check that the placeholder is
 associated with the stement.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.Binder">
	<summary>
 A Binder object represents a general location from where binding is happening, and provides
 virtual methods for looking up unqualified names, reporting errors, and also other
 operations that need to know about where binding happened from (accessibility checking,
 etc.) It also contains most of the methods related to general binding of constructs,
 although some large sections are factored into their own classes.

 Yes, Binder is a big grab bag of features. The reason for this is that binders are threaded
 through essentially ALL binding functions. So, basically Binder has all the features that
 need to be threaded through binding.

 Binder objects form a linked list and each binder links to its containing binder. Each
 binder only handles operations that it knows how to handles, and passes on other calls to
 its containing binder. This maintains separation of concerns and allows binders to be strung
 together in various configurations to enable different binding scenarios (e.g., debugger
 expression evaluator).

 In general, binder objects should be constructed via the BinderBuilder class.

 Binder class has GetBinder methods that return binders for scopes nested into the current
 binder scope. One should not expect to get a binder from the functions unless a syntax that
 originates a scope is passed as the argument. Also, the functions do not cross lambda
 boundaries, if binder's scope contains a lambda expression, binder will not return any
 binders for nodes contained in the lambda body. In order to get them, the lambda must be
 bound to BoundLambda node, which exposes LambdaBinder, which can be asked for binders in the
 lambda body (but it will not descend into nested lambdas). Currently, only
 <see cref="T:Roslyn.Compilers.VisualBasic.ExecutableCodeBinder"/>, <see cref="T:Roslyn.Compilers.VisualBasic.MemberSemanticModel.IncrementalBinder"/>
 and <see cref="T:Roslyn.Compilers.VisualBasic.SpeculativeBinder"/> have special implementation of GetBinder functions,
 the rest just delegate to containing binder.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.BackstopBinder.IsUnboundTypeAllowed(Roslyn.Compilers.VisualBasic.GenericNameSyntax)">
	<summary>
 Returns true if the node is in a position where an unbound type
 such as (C(of)) is allowed.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.BackstopBinder">
	<summary>
 Backstop that forms the end of the binder chain. Does nothing, and should never actually get hit. Provides
 asserts that methods never get called.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceModuleBinder">
	<summary>
 A source module binder provides the context associated with a source module.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SourceFileBinder">
	<summary>
 A SourceFileBinder provides the context associated with a give source file, not including the
 Imports statements (which have their own binders). It primarily provides the services of getting
 locations of node, since it holds onto a SyntaxTree.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ProjectImportsBinder">
	<summary>
 A ProjectImportsBinder provides the equivalent of a SourceFileBinder, but for the project-level
 imports, which don't live in any file.
 It primarily provides the services of getting locations of nodes, since it holds onto a SyntaxTree, although
 that tree isn't technically a source tree.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamespaceBinder.CollectExtensionMethodsInSingleBinder(System.String,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.MethodSymbol},Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Collect extension methods with the given name that are in scope in this binder.
 The passed in ArrayBuilder must be empty. Extension methods from the same containing type
 must be grouped together. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.NamespaceBinder">
	<summary>
 A namespace binder provides the context for a namespace symbol; e.g., looking up names
 inside the namespace.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeBinder.GetBinder(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Some nodes have special binder's for their contents 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeBinder.LookupInSingleBinder(Roslyn.Compilers.VisualBasic.LookupResult,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Gets all symbols of the particular name as 
 a) members of this type
 b) members of base types 
 c) type parameters in this type (but not outer or base types)
 In that order.
 
 Note, that section "11.4.4 Simple Name Expression" of VB Language spec 
 implies that type parameters are examined first, and only then members 
 of the type are examined. But this is inconsistent with Dev10 behavior.
 
 Returns all members of that name, or empty list if none.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.NamedTypeBinder.CollectExtensionMethodsInSingleBinder(System.String,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.MethodSymbol},Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Collect extension methods with the given name that are in scope in this binder.
 The passed in ArrayBuilder must be empty. Extension methods from the same containing type
 must be grouped together. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.NamedTypeBinder">
	<summary>
 A NamedTypeBinder provides the context for a type symbol; e.g., looking up names
 inside the type.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodTypeParametersBinder.LookupInSingleBinder(Roslyn.Compilers.VisualBasic.LookupResult,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Looks up the name in the type parameters
 a) type parameters in this type (but not outer or base types)
 Returns all members of that name, or empty list if none.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MethodTypeParametersBinder">
	<summary>
 A MethodTypeParametersBinder provides the context for looking up type parameters on a method.
 It is split out since binding of type in the parameters and return value need to happen with a context
 that includes the type parameters, but we don't have a fully complete method symbol yet.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ExecutableCodeBinder.LookupInSingleBinder(Roslyn.Compilers.VisualBasic.LookupResult,System.String,System.Int32,Roslyn.Compilers.VisualBasic.LookupOptions,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Looks up the name in the parameters
 Returns all members of that name, or empty if none.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ExecutableCodeBinder">
	<summary>
 A ExecutableCodeBinder provides context for looking up parameters/labels in a body of an executable entity (a method, lambda, or top-level script code), 
 and also for the implementation of ContainingMember, GetLocalForFunctionValue and GetBinder. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.MethodBodyBinder.#ctor(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Create binder for binding the body of a method. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.MethodBodyBinder">
	<summary>
 Provides context for binding body of a MethodSymbol. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TopLevelCodeBinder.#ctor(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Create binder for binding the body of a method. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TopLevelCodeBinder">
	<summary>
 Provides context for binding top-level statements in a script. 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ImportedTypesAndNamespacesMembersBinder.CollectExtensionMethodsInSingleBinder(System.String,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.MethodSymbol},Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Collect extension methods with the given name that are in scope in this binder.
 The passed in ArrayBuilder must be empty. Extension methods from the same containing type
 must be grouped together. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ImportedTypesAndNamespacesMembersBinder">
	<summary>
 Provides lookup in imported namespaces and types (not the alias kind),
 either at file level or project level.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.TypesOfImportedNamespacesMembersBinder.CollectExtensionMethodsInSingleBinder(System.String,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.VisualBasic.MethodSymbol},Roslyn.Compilers.VisualBasic.Binder)">
	<summary>
 Collect extension methods with the given name that are in scope in this binder.
 The passed in ArrayBuilder must be empty. Extension methods from the same containing type
 must be grouped together. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.TypesOfImportedNamespacesMembersBinder">
	<summary>
 Provides lookup in types of imported namespaces, either at file level or project level.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ImportAliasesBinder">
	<summary>
 A ImportAliasesBinder provides lookup for looking up import aliases (A = Foo.Bar),
 either at file level or project level.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.IgnoreBaseClassesBinder">
	<summary>
 Causes lookups to ignore base classes. Used for binding
 Imports statements.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.BasesBeingResolvedBinder">
	<summary>
 Causes lookups to assume that the given set of classes are having their 
 bases being resolved, so lookups should not check for base classes.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.LocationSpecificBinder">
	<summary>
 A simple Binder that wraps another Binder and reports a specific
 binding location, but otherwise delegates to the other Binder.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.SpeculativeBinder">
	<summary>
 We don't have a way to represent locations inside speculative binding right now. For now:
 causes locations to be NoLocation.
 
 Also redirects GetBinder calls to a speculativeBinding.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AttributeSemanticModel">
	<summary>
 Binding info for attribute syntax and expressions that are part of a attribute.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AttributeBinder._root">
	<summary> Root syntax node </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AttributeBinder.Root">
	<summary> Field or property declaration statement syntax node </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AttributeBinder.GetBinder(Roslyn.Compilers.VisualBasic.SyntaxNode)">
	<summary>
 Some nodes have special binder's for their contents 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AttributeBinder">
	<summary>
 Binder used for attributes
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.InitializerRewriter.BuildConstructorBody(Roslyn.Compilers.VisualBasic.Compilation,Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.BoundStatement,Roslyn.Compilers.VisualBasic.Binder.ProcessedFieldOrPropertyInitializers,Roslyn.Compilers.VisualBasic.BoundBlock)">
	<summary>
 Builds a constructor body. 
 </summary>
	<remarks>
 Lowers initializers to fields assignments if not lowered yet and the first statement of the body isn't 
 a call to another constructor of the containing class. 
 </remarks>
	<returns>
 Bound block including 
  - call to a base constructor
  - field initializers and top-level code
  - remaining constructor statements (empty for a submission)
 </returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.InitializerRewriter.RewriteInitializersAsStatements(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.VisualBasic.BoundInitializer})">
	<summary>
 Rewrites GlobalStatementInitializers to ExpressionStatements and gets the initializers for fields and properties.
 </summary>
	<remarks>
 Initializers for fields and properties cannot be rewritten to their final form at this place because they might need 
 to be rewritten to replace their placeholder expressions to the final locals or temporaries (e.g. in case of a field
 declaration with "AsNew" and multiple variable names. The final rewriting will during local rewriting.
 The statement list returned by this function can be copied into all constructors without reprocessing it.
 </remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.InitializerRewriter.HasExplicitMeConstructorCall(Roslyn.Compilers.VisualBasic.BoundBlock,Roslyn.Compilers.VisualBasic.TypeSymbol,System.Boolean@)">
	<summary> 
 Determines if this constructor calls another constructor of the constructor's containing class. 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.InitializerRewriter">
	<summary>
 Turns the bound initializers into a list of bound assignment statements
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForLoopVerification.VerifyForLoops(Roslyn.Compilers.VisualBasic.BoundBlock,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 A BoundForLoopStatement node has a list of control variables (from the attached next statement).
 When binding the control variable of a for/for each loop that is nested in another for/for each loop, it must be
 checked that the control variable has not been used by a containing for/for each loop. Because bound nodes do not
 know their parents and we try to avoid passing around a stack of variables, we just walk the bound tree after the
 initial binding to report this error.
 In addition, it must be checked that the control variables of the next statement match the loop. Because the inner 
 most loop contains the next with control variables from outer binders, checking this here is also convenient.

 There are two diagnostics reported by this walker:
 1. BC30069: For loop control variable '{0}' already in use by an enclosing For loop.
 2. BC30070: Next control variable does not match For loop control variable '{0}'.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForLoopVerification.ForLoopVerificationWalker.PreVisitForAndForEachStatement(Roslyn.Compilers.VisualBasic.BoundForStatement)">
	<summary>
 Checks if the control variable was already used in an enclosing for loop
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForLoopVerification.ForLoopVerificationWalker.PostVisitForAndForEachStatement(Roslyn.Compilers.VisualBasic.BoundForStatement)">
	<summary>
 Checks if the control variables from the next statement match the control variable of the enclosing 
 for loop.
 Some loops may contain a next with multiple variables.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.ForLoopVerification.ReferencedSymbol(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Gets the referenced symbol of the bound expression.
 Used for matching variables between For and Next statements.
 </summary>
	<param name="expression">The bound expression.</param>
</member><member name="T:Roslyn.Compilers.VisualBasic.VariablesDeclaredWalker">
	<summary>
 A region analysis walker that records declared variables.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.UnassignedVariablesWalker">
	<summary>
 An analysis that computes the set of variables that may be used
 before being assigned anywhere within a method.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.RegionReachableWalker">
	<summary>
 A region analysis walker that computes whether or not the region completes normally.  It does this by determining 
 if the point at which the region ends is reachable.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.VariablesDeclared">
	<summary>
 A collection of the local variables that are declared within the region. Note that the region must be 
 bounded by a method's body or a field's initializer, so parameter symbols are never included in the result.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.DataFlowsIn">
	<summary>
 A collection of the local variables for which a value assigned outside the region may be used inside the region.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.DataFlowsOut">
	<summary>
 A collection of the local variables for which a value assigned inside the region may be used outside the region.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.AlwaysAssigned">
	<summary>
 A collection of the local variables for which a value is always assigned inside the region.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.ReadInside">
	<summary>
 A collection of the local variables that are read inside the region.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.WrittenInside">
	<summary>
 A collection of local variables that are written inside the region.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.ReadOutside">
	<summary>
 A collection of the local variables that are read outside the region.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.WrittenOutside">
	<summary>
 A collection of local variables that are written inside the region.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.DataFlowAnalysis.Captured">
	<summary>
 A collection of the local variables that have been referenced in anonymous functions
 and therefore must be moved to a field of a frame class.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.DataFlowAnalysis">
	<summary>
 This class implements the region data flow analysis operations.  Region data flow analysis provides information
 how data flows into and out of a region.  The analysis is done lazily. When created, it performs no analysis, but
 simply caches the arguments. Then, the first time one of the analysis results is used it computes that one
 result and caches it. Each result is computed using a custom algorithm.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ControlFlowAnalysis.EntryPoints">
	<summary>
 A collection of statements outside the region that jump into the region.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ControlFlowAnalysis.ExitPoints">
	<summary>
 A collection of statements inside the region that jump to locations outside the region.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ControlFlowAnalysis.EndPointIsReachable">
	<summary>
 Returns true if and only if the last statement in the region can complete normally or the region contains no
 statements.
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.ControlFlowAnalysis.ReturnStatements">
	<summary>
 A collection of return, exit sub, exit function, exit operator and exit property statements found within the region that return to the enclosing method.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ControlFlowAnalysis">
	<summary>
 This class implements the region control flow analysis operations.  Region control flow analysis provides
 information about statements which enter and leave a region. The analysis done lazily. When created, it performs
 no analysis, but simply caches the arguments. Then, the first time one of the analysis results is used it
 computes that one result and caches it. Each result is computed using a custom algorithm.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.RegionAnalysisContext.compilation">
	<summary> Current compilation </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.RegionAnalysisContext.symbol">
	<summary> Method, field or property symbol </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.RegionAnalysisContext.boundNode">
	<summary> Bound node defining the root of the bound subtree to be analyzed </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.RegionAnalysisContext.firstInRegion">
	<summary> Region being analyzed: start node </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.RegionAnalysisContext.lastInRegion">
	<summary> Region being analyzed: end node </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.RegionAnalysisContext.region">
	<summary> Region itself </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.RegionAnalysisContext.Failed">
	<summary> True if the input was bad, such as no first and last nodes </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.RegionAnalysisContext.#ctor(Roslyn.Compilers.VisualBasic.Compilation,Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.BoundNode,Roslyn.Compilers.VisualBasic.BoundNode,Roslyn.Compilers.VisualBasic.BoundNode,Roslyn.Compilers.TextSpan)">
	<summary>
 Construct context from model and region
 
 'boundNode' defines a bound sub-tree to be analyzed and is being used in 
 both region-based and not region based analysis processes. 
 
 The last three parameters define a region. In most cases firstInRegion and lastInRegion 
 are being used for identifying when we should enter or leave the region. 
 
 Text span is also being passed to define the region which is used in few places. Those 
 places can be rewritten to use first/last bound nodes, but simple [region.Contains(...)] 
 check simplifies the code significantly. (Note, C# implementation uses the same logic, 
 but calculates the region's text span based on first/last node; in VB to perform such 
 calculation would have to traverse bound subtree under first/last nodes to detect 
 region boundaries; we avoid this additional cost by passing the original text span as 
 a separate parameter because we do have it anyways)
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.RegionAnalysisContext.#ctor(Roslyn.Compilers.VisualBasic.Compilation)">
	<summary>
 Construct context wiht Failed flag
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.RegionAnalysisContext">
	<summary>
 Represents analysis context attributes such as compilation, region, etc...
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ReadWriteWalker">
	<summary>
 A region analysis walker that records reads and writes of all variables, both inside and outside the region.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.ExitPointsWalker">
	<summary>
 A region analysis walker that records jumps out of the region.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.EntryPointsWalker">
	<summary>
 A region analysis walker that records jumps into the region.  Works by overriding NoteBranch, which is
 invoked by a superclass when the two endpoints of a jump have been identified.
 </summary>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.FlowAnalysisPass.Analyze(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.BoundBlock,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 The flow analysis pass.  This pass reports required diagnostics for unreachable
 statements and uninitialized variables (through the call to FlowAnalysisWalker.Analyze).
 </summary>
	<param name="method">the method to be analyzed</param>
	<param name="block">the method's body</param>
	<param name="diagnostics">the receiver of the reported diagnostics</param>
</member><member name="F:Roslyn.Compilers.VisualBasic.FlowAnalysisRegionInfo.FirstInRegion">
	<summary> Region being analyzed: start node </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.FlowAnalysisRegionInfo.LastInRegion">
	<summary> Region being analyzed: end node </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.FlowAnalysisRegionInfo.Region">
	<summary> Region itself </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.DataFlowsOutWalker">
	<summary>
 A region analysis walker that computes the set of variables for
 which their assigned values flow out of the region.
 A variable assigned inside is used outside if an analysis that
 treats assignments in the region as un-assigning the variable would
 cause "unassigned" errors outside the region.</summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.DataFlowsInWalker.InvalidRegion">
	<summary>
 If invalid region is dynamically detected this string contains text description of the reason.
 
 Currently only the following case can cause the region to be invalidated:
 
   - We have declaration of several variables using 'As New' having object
     initializer with implicit receiver; if region included such a receiver,
     it should include the whole declaration. Example:
         Dim a, b As New Clazz(...) With { .X = [| .Y |] }
 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.DataFlowsInWalker">
	<summary>
 A region analysis walker that computes the set of variables whose values flow into (are used in)
 the region.
 An variable assigned outside is used inside if an analysis
 that leaves the variable unassigned on entry to the region would cause the
 generation of "unassigned" errors within the region.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.DataFlowPass.SlotKind.NotTracked">
	<summary>
  Special slot for untracked variables
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.DataFlowPass.SlotKind.Unreachable">
	<summary>
 Special slot for tracking whether code is reachable
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.DataFlowPass.SlotKind.FunctionValue">
	<summary>
 Special slot for tracking the implicit local for the function return value
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.DataFlowPass.SlotKind.FirstAvailable">
	<summary>
 The first available slot for variables
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.DataFlowPass.initiallyAssignedVariables">
	<summary>
 Some variables that should be considered initially assigned.  Used for region analysis.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.DataFlowPass._trackStructsWithIntrinsicTypedFields">
	<summary>
 Defines whether or not fields of intrinsic type should be tracked. Such fields should 
 not be tracked for error reporting purposes, but should be tracked for region flow analysis
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.DataFlowPass._unusedVariables">
	<summary>
 Variables that were used anywhere, in the sense required to suppress warnings about unused variables.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.DataFlowPass.writtenVariables">
	<summary>
 Variables that were initialized or written anywhere.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.DataFlowPass._variableSlot">
	<summary> 
 A mapping from local variables to the index of their slot in a flow analysis local state. 
 WARNING: if variable identifier maps into SlotKind.NotTracked, it may mean that VariableIdentifier 
          is a structure without traceable fields. This mapping is created in MakeSlotImpl(...)
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.DataFlowPass.variableBySlot">
	<summary>
 A mapping from the local variable slot to the symbol for the local variable itself.  This is used in the
 implementation of region analysis (support for extract method) to compute the set of variables "always
 assigned" in a region of code.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.DataFlowPass.nextVariableSlot">
	<summary>
 Variable slots are allocated to local variables sequentially and never reused.  This is
 the index of the next slot number to use.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.DataFlowPass.alreadyReported">
	<summary>
 Tracks variables for which we have already reported a definite assignment error.  This
 allows us to report at most one such error per variable.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowPass.Analyze(Roslyn.Compilers.VisualBasic.FlowAnalysisInfo,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 Perform data flow analysis, reporting all necessary diagnostics.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowPass.VariableSlot(Roslyn.Compilers.VisualBasic.Symbol,System.Int32)">
	<summary>
 Locals are given slots when their declarations are encountered.  We only need give slots to local variables, and 
 the "Me" variable of a structure constructs. Other variables are not given slots, and are therefore not tracked 
 by the analysis.  This returns SlotKind.NotTracked for a variable that is not tracked, for fields of structs 
 that have the same assigned status as the container, and for structs that (recursively) contain no data members.
 We do not need to track references to variables that occur before the variable is declared, as those are reported 
 in an earlier phase as "use before declaration". That allows us to avoid giving slots to local variables before
 processing their declarations.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowPass.MakeSlotsForExpression(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Return the slot for a variable, or SlotKind.NotTracked if it is not tracked (because, for example, it is an empty struct).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowPass.MakeSlot(Roslyn.Compilers.VisualBasic.Symbol,System.Int32)">
	<summary>
 Force a variable to have a slot.
 </summary>
	<param name="local"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowPass.IsSlotAlreadyReported(Roslyn.Compilers.VisualBasic.TypeSymbol,System.Int32)">
	<summary> Calculates the flag of being already reported; for structure types
 the slot may be reported if ALL the children are reported </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowPass.MarkSlotAsReported(Roslyn.Compilers.VisualBasic.TypeSymbol,System.Int32)">
	<summary> Marks slot as reported, propagates 'reported' flag to the children if necessary </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowPass.SetSlotUnassigned(System.Int32)">
	<summary> Unassign a slot for a regular variable </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowPass.SetSlotAssigned(System.Int32)">
	<summary> Assign a slot for a regular variable </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.DataFlowPass.typeToMembersCache">
	<summary> Hash structure fields as we may query them many times </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowPass.CheckAssigned(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.AbstractFlowPass{Roslyn.Compilers.VisualBasic.DataFlowPass.LocalState}.ReadWriteContext)">
	<summary>
 Check that the given variable is definitely assigned.  If not, produce an error.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowPass.CheckAssigned(Roslyn.Compilers.VisualBasic.BoundFieldAccess,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.AbstractFlowPass{Roslyn.Compilers.VisualBasic.DataFlowPass.LocalState}.ReadWriteContext)">
	<summary> Version of CheckAssigned for bound field access </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowPass.IsAssigned(Roslyn.Compilers.VisualBasic.BoundExpression,System.Int32@)">
	<summary> Check node for being assigned, return the value of unassigned slot in unassignedSlot </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowPass.ReportUnassigned(Roslyn.Compilers.VisualBasic.Symbol,Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.AbstractFlowPass{Roslyn.Compilers.VisualBasic.DataFlowPass.LocalState}.ReadWriteContext,System.Int32,Roslyn.Compilers.VisualBasic.BoundFieldAccess)">
	<summary>
 Report a given variable as not definitely assigned.  Once a variable has been so
 reported, we suppress further reports of that variable.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowPass.Assign(Roslyn.Compilers.VisualBasic.BoundNode,Roslyn.Compilers.VisualBasic.BoundExpression,System.Boolean)">
	<summary>
 Mark a variable as assigned (or unassigned).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowPass.DeclaredVariableIsAlwaysAssignedBeforeInitializer(Roslyn.Compilers.VisualBasic.SyntaxNode,Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.BoundValuePlaceholderBase@)">
	<summary>
 A variable declared with As New can be considered assigned before the initializer is executed in case the variable
 is a value type. The reason is that in this case the initialization happens in place (not in a temporary) and 
 the variable already got the object creation expression assigned.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.DataFlowPass.VariableIdentifier">
	<summary> Represents variable symbol combined with the containing variable slot </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.DataFlowPass.AmbiguousLocalsPseudoSymbol">
	<summary> 
 AmbiguousLocalsPseudoSymbol is a pseudo-symbol used in flow analysis representing 
 a symbol of the implicit receiver in case Dim statement defines more than one variable,
 but uses the same object initializer for all of them, like: 
     Dim a,b As New C() With { .X = .Y } 
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.DataFlowPass.SlotCollection">
	<summary>
 Collection of 0, 1 or more slots. Allows returning of several slots by some 
 DataFlowPass methods to handle cases where implicit receiver represents 
 several variables, like in:
     Dim a, b, c As New C(...) With {...}
 
 Because such constructions are very rare in real user code, the collection only 
 allocates an array builder for storing several values if there are indeed more 
 than one slot to be stored. Because the collection may optionally create an 
 array builder, collection's Free() method must be called when appropriate.
 
 Note that the collection is mutable, so one can add or modify the values.
 If some collection elements get replaced with 'SlotKind.NotTracked' collection
 does NOT "shrink", i.e. once allocated the array builder is not freed even if 
 all the elements are set to 'SlotKind.NotTracked'.
 
 Collection cannot store 'SlotKind.Unreachable' (0) which has a special meaning.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowPass.IntersectBitArrays(Roslyn.Compilers.BitArray@,Roslyn.Compilers.BitArray)">
	<summary>
 Intersect bit arrays taking into account 'all bits set' flag
 </summary>
	<remarks>receiver will be changed as a result</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowPass.UnionBitArrays(Roslyn.Compilers.BitArray@,Roslyn.Compilers.BitArray)">
	<summary>
 Union bit arrays taking into account 'all bits set' flag
 </summary>
	<remarks>receiver will be changed as a result</remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.DataFlowPass.LocalState.Clone">
	<summary>
 Produce a duplicate of this flow analysis state.
 </summary>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.ControlFlowPass.Analyze(Roslyn.Compilers.VisualBasic.FlowAnalysisInfo,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
	<summary>
 Perform control flow analysis, reporting all necessary diagnostics.  Returns true if the end of
 the body might be reachable..
 </summary>
	<param name="diagnostics"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.ControlFlowPass.LocalState.Clone">
	<summary> Produce a duplicate of this flow analysis state. </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AlwaysAssignedWalker">
	<summary>
 A region analysis walker that computes the set of variables that are always assigned a value in the region.
 A variable is "always assigned" in a region if an analysis of the
 region that starts with the variable unassigned ends with the variable
 assigned.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.compilation">
	<summary>
 The compilation in which the analysis is taking place.  This is needed to determine which
 conditional methods will be compiled and which will be omitted.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.symbol">
	<summary>
 The symbol of method whose body is being analyzed or field or property whose 
 initializer is being analyzed
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.methodOrInitializerMainNode">
	<summary>
 The bound code of the method or initializer being analyzed
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.labels">
	<summary>
 The flow analysis state at each label, computed by merging the state from branches to
 that label with the state when we fall into the label.  Entries are created when the
 label is encountered.  One case deserves special attention: when the destination of the
 branch is a label earlier in the code, it is possible (though rarely occurs in practice)
 that we are changing the state at a label that we've already analyzed. In that case we
 run another pass of the analysis to allow those changes to propagate. This repeats until
 no further changes to the state of these labels occurs.  This can result in quadratic
 performance in unlikely but possible code such as this: "int x; if (cond) goto l1; x =
 3; l5: print x; l4: goto l5; l3: goto l4; l2: goto l3; l1: goto l2;"
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.labelsSeen">
	<summary> All of the labels seen so far in this forward scan of the body </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.backwardBranchChanged">
	<summary>
 Set to true after an analysis scan if the analysis was incomplete due to a backward
 "goto" branch changing some analysis result.  In this case the caller scans again (until
 this is false). Since the analysis proceeds by monotonically changing the state computed
 at each label, this must terminate.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1._pendingBranches">
	<summary> Actual storage for PendingBranches </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.State">
	<summary> The definite assignment and/or reachability state at the point currently being analyzed. </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.MeParameter">
	<summary>
 'Me' parameter, relevant for methods, fields, properties, otherwise Nothing
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.TrackUnassignments">
	<summary>
 Used only in the data flows out walker, we track unassignments as well as assignments
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.nesting">
	<summary>
 The current lexical nesting in the BoundTree. 
 </summary>
	<remarks></remarks>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.diagnostics">
	<summary>
 Where all diagnostics are deposited.
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.suppressConstantExpressions">
	<summary> Indicates whether or not support of constant expressions (boolean and nothing)
 is enabled in this analyzer. In general, constant expressions support is enabled in analysis
 exposed to public API consumer and disabled when used from command-line compiler. </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.#ctor(Roslyn.Compilers.VisualBasic.FlowAnalysisInfo,System.Boolean)">
	<summary>
 Construct an object for outside-region analysis
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.#ctor(Roslyn.Compilers.VisualBasic.FlowAnalysisInfo,Roslyn.Compilers.VisualBasic.FlowAnalysisRegionInfo,System.Boolean,System.Boolean)">
	<summary>
 Construct an object for region-aware analysis
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.SetConditionalState(`0,`0)">
	<summary> Set conditional state </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.SetState(`0)">
	<summary> Set unconditional state </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.Split">
	<summary> Split state </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.Unsplit">
	<summary> Intersect and unsplit state </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.PendingBranches">
	<summary>
 Pending escapes generated in the current scope (or more deeply nested scopes). When jump
 statements (goto, break, continue, return) are processed, they are placed in the
 Me._pendingBranches buffer to be processed later by the code handling the destination
 statement. As a special case, the processing of try-finally statements might modify the
 contents of the Me._pendingBranches buffer to take into account the behavior of
 "intervening" finally clauses.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.Scan">
	<summary>
 Perform a single pass of flow analysis.  Note that after this pass,
 this.backwardBranchChanged indicates if a further pass is required.
 </summary>
	<returns>False if the region is invalid</returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.Analyze">
	<returns>False if the region is invalid</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.MethodParameters">
	<summary>
 If analysis is being performed in a context of a method returns method's parameters, 
 otherwise returns an empty array
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.ShouldAnalyzeByRefParameters">
	<summary>
 Specifies whether or not method's ByRef parameters should be analyzed. If there's more than one location in
 the method being analyzed, then the method is partial and we prefer to report an out parameter in partial
 method error.
 Note: VB doesn't support "out" so it doesn't warn for unassigned parameters. However, check variables passed
 byref are assigned so that data flow analysis detects parameters flowing out.
 </summary>
	<returns>true if the out parameters of the method should be analyzed</returns>
</member><member name="P:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.MethodSymbol">
	<summary>
 Method symbol or nothing
 TODO: Need to try and get rid of this property
 </summary>
</member><member name="P:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.MethodReturnType">
	<summary>
 If analysis is being performed in a context of a method returns method's return type, 
 otherwise returns Nothing
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.LabelState(Roslyn.Compilers.VisualBasic.LabelSymbol)">
	<summary>
 Return the flow analysis state associated with a label.
 </summary>
	<param name="label"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.SetUnreachable">
	<summary>
 Set the current state to one that indicates that it is unreachable.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.LoopHead(Roslyn.Compilers.VisualBasic.BoundLoopStatement)">
	<summary>
 Called at the point in a loop where the backwards branch would go to.
 </summary>
	<param name="node"></param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.LoopTail(Roslyn.Compilers.VisualBasic.BoundLoopStatement)">
	<summary>
 Called at the point in a loop where the backward branch is placed.
 </summary>
	<param name="node"></param>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.ResolveBreaks(`0,Roslyn.Compilers.VisualBasic.LabelSymbol)">
	<summary>
 Used to resolve exit statements in each statement form that has an Exit statement
 (loops, switch).
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.ResolveContinues(Roslyn.Compilers.VisualBasic.LabelSymbol)">
	<summary>
 Used to resolve continue statements in each statement form that supports it.
 </summary>
	<param name="continueLabel"></param>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.NoteBranch(Roslyn.Compilers.VisualBasic.AbstractFlowPass{`0}.PendingBranch,Roslyn.Compilers.VisualBasic.BoundStatement,Roslyn.Compilers.VisualBasic.BoundLabelStatement)">
	<summary>
 Subclasses override this if they want to take special actions on processing a goto
 statement, when both the jump and the label have been located.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.ResolveBranches(Roslyn.Compilers.VisualBasic.BoundLabelStatement)">
	<summary>
 To handle a label, we resolve all pending forward references to branches to that label.  Returns true if the state of
 the label changes as a result. 
 </summary>
	<param name="target"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.SavePending">
	<summary>
 When branching into constructs that don't support jumps into/out of (i.e. lambdas), 
 we save the pending branches when visiting more nested constructs.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.RestorePending(Roslyn.Compilers.VisualBasic.AbstractFlowPass{`0}.SavedPending,System.Boolean)">
	<summary>
 We use this to restore the old set of pending branches and labels after visiting a construct that contains nested statements.
 </summary>
	<param name="oldPending">The old pending branches/labels, which are to be merged with the current ones</param>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.ResolveBranches(System.Collections.Generic.HashSet{Roslyn.Compilers.VisualBasic.LabelSymbol})">
	<summary>
 We look at all pending branches and attempt to resolve the branches with labels if the nesting of the 
 block is the nearest common parent to the branch and the label. Because the code is evaluated recursively 
 outward we only need to check if the current nesting is a prefix of both the branch and the label nesting.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.Unimplemented(Roslyn.Compilers.VisualBasic.BoundNode,System.String)">
	<summary>
 Report an unimplemented language construct.
 </summary>
	<param name="node"></param>
	<param name="feature"></param>
	<returns></returns>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.Visit(Roslyn.Compilers.VisualBasic.BoundNode,System.Boolean)">
	<summary>
 Visit a node.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.VisitAlways(Roslyn.Compilers.VisualBasic.BoundNode,System.Boolean)">
	<summary>
 Visit a node, process 
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.VisitCondition(Roslyn.Compilers.VisualBasic.BoundExpression)">
	<summary>
 Visit a boolean condition expression.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.VisitRvalue(Roslyn.Compilers.VisualBasic.BoundExpression,Roslyn.Compilers.VisualBasic.AbstractFlowPass{`0}.ReadWriteContext,System.Boolean)">
	<summary>
 Visit a general expression, where we will only need to determine if variables are
 assigned (or not). That is, we will not be needing AssignedWhenTrue and
 AssignedWhenFalse.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.DefaultVisit(Roslyn.Compilers.VisualBasic.BoundNode)">
	<summary>
 Since each language construct must be handled according to the rules of the language specification,
 the default visitor reports that the construct for the node is not implemented in the compiler.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.FieldAccessMayRequireTracking(Roslyn.Compilers.VisualBasic.BoundFieldAccess)">
	<summary> Bound field access passed may require tracking if it is an access to a non-shared structure field </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.BoundNodeFinder._nodeToFind">
	<summary> Note: Nothing if node is found </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.BoundNodeFinder">
	<summary>
 The visitor which searches for a bound node inside a bound subtree
 </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1._firstInRegion">
	<summary> Start of the region being analyzed, or Nothing if it is not a region based analysis </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1._lastInRegion">
	<summary> End of the region being analyzed, or Nothing if it is not a region based analysis </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1._region">
	<summary> Current region span, valid only for region based analysis </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1._regionPlace">
	<summary> Tells whether we are analyzing the position before, during, or after the region </summary>
</member><member name="F:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.loopHeadState">
	<summary>
 A cache of the state at the backward branch point of each loop.  This is not needed
 during normal flow analysis, but is needed for region analysis.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.IsInsideRegion(Roslyn.Compilers.TextSpan)">
	<summary> Checks if the text span passed is inside the region </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.EnterRegion">
	<summary>
 Subclasses may override EnterRegion to perform any actions at the entry to the region.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.LeaveRegion">
	<summary>
 Subclasses may override LeaveRegion to perform any action at the end of the region.
 </summary>
</member><member name="T:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.BlockNesting">
	<summary>
 BlockLevel is used to keep track of the lexical nesting level of label and goto statements. 
 The other most block has a path of {}
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.LabelStateAndNesting">
	<summary>
 The state associated with a label includes the statement itself, the local state and the nesting.
 </summary>
	<remarks></remarks>
</member><member name="T:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.PendingBranch">
	<summary>
 A pending branch.  There are created for a return, break, continue, or goto statement.  The
 idea is that we don't know if the branch will eventually reach its destination because of an
 intervening finally block that cannot complete normally.  So we store them up and handle them
 as we complete processing each construct.  At the end of a block, if there are any pending
 branches to a label in that block we process the branch.  Otherwise we relay it up to the
 enclosing construct as a pending branch of the enclosing construct.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.IntersectWith(`0@,`0@)">
	<summary>
 Mutate 'self' flow analysis state to reflect the fact that there is a control-flow
 convergence with the 'other' flow analysis state.  Return true if and only if the
 state has changed as a result of the Join.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.UnionWith(`0@,`0@)">
	<summary>
 Mutate 'self' flow analysis state to reflect the fact that there is a control-flow
 sequence with the 'other' flow analysis state - in other words, this occurs and then
 the other.
 </summary>
</member><member name="M:Roslyn.Compilers.VisualBasic.AbstractFlowPass`1.AbstractLocalState.Clone">
	<summary>
 Produce a duplicate of this flow analysis state.
 </summary>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:Roslyn.Compilers.VisualBasic.Analyzer.AnalyzeMethodBody(Roslyn.Compilers.VisualBasic.MethodSymbol,Roslyn.Compilers.VisualBasic.BoundBlock,Roslyn.Compilers.DiagnosticBag)">
	<summary>
 Analyses method body for error conditions such as definite assignments, unreachable code etc...
 
 This analysis is done when doing the full compile or when responding to GetCompileDiagnostics.
 This method assume that the trees are already bound and will not do any rewriting/lowering
 It is possible and common for this analysis to be done in the presence of errors.
 </summary>
</member>
</members>
</doc>